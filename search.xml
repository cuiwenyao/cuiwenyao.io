<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Initial Server Setup with Ubuntu</title>
    <url>/2021/04/21/Initial-Server-Setup-with-Ubuntu/</url>
    <content><![CDATA[<h1 id="Initial-Server-Setup-with-Ubuntu"><a href="#Initial-Server-Setup-with-Ubuntu" class="headerlink" title="Initial Server Setup with Ubuntu"></a>Initial Server Setup with Ubuntu</h1><ul>
<li>When you first create a new ubuntu 18.04 server, there are a new configuration steps that you should take early on as part of the basic setup. This will increase the security and usability of your server and will give you a solid foundation for subsequent actions.</li>
<li>This guide below demonstrates how to manually complete the steps recommended for new ubuntu 18.04 servers. Following this procedure manually can be useful to learn some basic system administration skills and as an exercise to fully understand the actions being taking on my server. As an alternative, if you wish to get up and running more quickly, you can run my initial server setup script which automates these steps.<h4 id="step-1-logging-in-as-root"><a href="#step-1-logging-in-as-root" class="headerlink" title="step 1 logging in as root"></a>step 1 logging in as root</h4></li>
<li>If you are not already connected to your server, go ahead and log in as root user using the following command, substitute server’s ip with your server’s public ip address.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh root@server&#39;s ip</span><br></pre></td></tr></table></figure></li>
<li>Accept the warning about host authenticity if it appears. If you are using password authentication, provide your root password to login in. If you are using an SSH key that is passphrase protected, you may be prompted to enter the passphrase the first time you use the key each session. If this is your first time logging into the server with a password, you may also be prompted to change the root password.</li>
<li><strong>about root</strong><blockquote>
<p>The root user is the administrative user in a Linux environment that has very broad privileges. Because of the heightened privileges of the root account, you are discouraged form using it on a regular basis. This is because part of the power inherent with the root account is the ability to make very destructive changes, even by accident.</p>
<p>The next step is to set up an alternative user account with a reduced scope of influence for day-to-day work. I will teach you how to gain increased privileges during the times when you need them.</p>
</blockquote>
</li>
</ul>
<h4 id="step2-creating-a-new-user"><a href="#step2-creating-a-new-user" class="headerlink" title="step2 creating a new user"></a>step2 creating a new user</h4><ul>
<li>Once you are logged in as root, we are prepared to add the new user account that we will use to log in from now on.</li>
<li>This example create a new user named wenyao<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adduser wenyao</span><br></pre></td></tr></table></figure></li>
<li>You will be asked a few questions, starting with the account password.</li>
<li>Enter a strong password and, optionally, fill in any of the additional information if you would like. This is not required and you can just hit enter to skip.</li>
</ul>
<h4 id="step3-granting-administrative-privileges"><a href="#step3-granting-administrative-privileges" class="headerlink" title="step3 granting administrative privileges"></a>step3 granting administrative privileges</h4><ul>
<li>Now, we have a new user account with regular account privileges. However, we may sometimes need to do administrative tasks.</li>
<li>To avoid having to log out of our normal user and log back in as the root account, we can set up what is known as superuser or root privileges for our normal account. This allow our normal user to run commands with administrative privileges by putting the word “sudo” before each command.</li>
<li>To add these privileges to our new user, we need add the new user to the “sudo” group. By default, on ubuntu 18.04, users who belong to the “sudo” group are allow to use the “sudo” command.</li>
<li>As root, run this command to add new user to the sudo group.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod -aG sudo wenyao</span><br></pre></td></tr></table></figure></li>
<li>Now, when logged in as your regular user, you can type “sudo” before commands to perform actions with superuser privileges.</li>
</ul>
<h4 id="step4-setting-up-a-basic-firewall"><a href="#step4-setting-up-a-basic-firewall" class="headerlink" title="step4 setting up a basic firewall"></a>step4 setting up a basic firewall</h4><ul>
<li><p>ubuntu 18.04 servers can use the UFW firewall to make sure only connections to certain services are allowed. We can set up a basic firewall very easily using this application.</p>
</li>
<li><p>Different applications can register their profiles with UFW upon installation. These profiles allow UFW to manager these applications by name. OpenSSH, the service allowing us to connect to our server now, has a profile registered with UFW. You can see this by typing:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ufw app list</span><br></pre></td></tr></table></figure></li>
<li><p>the output will looks like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Available applications:</span><br><span class="line">  OpenSSH</span><br></pre></td></tr></table></figure></li>
<li><p>We need make sure that the firewall allows SSH connections so that we can log back in next time. We can allow these connections by typing:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ufw allow OpenSSH</span><br></pre></td></tr></table></figure></li>
<li><p>Afterwards, we can enable the firewall by typing:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ufw enable</span><br></pre></td></tr></table></figure></li>
<li><p>You can see that SSH connections are allowed by typing:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ufw status</span><br></pre></td></tr></table></figure></li>
<li><p>the output will looks like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">OpenSSH                    ALLOW       Anywhere</span><br><span class="line">OpenSSH (v6)               ALLOW       Anywhere (v6)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>As the firewall is currently blocking all connections except for SSH. If you install and configure additional services, you will need to adjust the firewall setting to allow acceptable traffic in. </p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>build a mail server for myself</title>
    <url>/2021/04/16/build-a-mail-server-for-myself/</url>
    <content><![CDATA[<h1 id="build-a-mail-server-for-myself"><a href="#build-a-mail-server-for-myself" class="headerlink" title="build a mail server for myself"></a>build a mail server for myself</h1><h2 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h2><ul>
<li>centos7.6<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4></li>
<li>解析域名添加两条记录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A 记录</span><br><span class="line">记录类型：A</span><br><span class="line">主机记录：@</span><br><span class="line">记录值：ip address</span><br><span class="line"></span><br><span class="line">MX 记录</span><br><span class="line">记录类型：MX</span><br><span class="line">主机记录：@</span><br><span class="line">记录值：我的域名</span><br></pre></td></tr></table></figure></li>
<li>生效检查</li>
</ul>
<ol>
<li>ping mydomain, 如果返回了刚刚解析的ip地址，则成功。</li>
<li>检查MX记录, nslookup -q=mx mydomain,如果返回的信息中有域名，则成功。</li>
</ol>
<h4 id="postfix"><a href="#postfix" class="headerlink" title="postfix"></a>postfix</h4><ol>
<li>安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install postfix</span><br></pre></td></tr></table></figure></li>
<li>配置，参考如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postconf -e &#39;myhostname &#x3D; server.cuimouren.cn&#39;</span><br><span class="line">postconf -e &#39;mydestination &#x3D; localhost, localhost.localdomain&#39;</span><br><span class="line">postconf -e &#39;myorigin &#x3D; $mydomain&#39;</span><br><span class="line">postconf -e &#39;mynetworks &#x3D; 127.0.0.0&#x2F;8&#39;</span><br><span class="line">postconf -e &#39;inet_interfaces &#x3D; all&#39;</span><br><span class="line">postconf -e &#39;inet_protocols &#x3D; all&#39;</span><br><span class="line">postconf -e &#39;mydestination &#x3D; $myhostname, localhost.$mydomain, localhost, $mydomain&#39;</span><br><span class="line">postconf -e &#39;home_mailbox &#x3D; Maildir&#x2F;&#39;</span><br><span class="line">postconf -e &#39;smtpd_sasl_type &#x3D; dovecot&#39;</span><br><span class="line">postconf -e &#39;smtpd_sasl_path &#x3D; private&#x2F;auth&#39;</span><br><span class="line">postconf -e &#39;smtpd_sasl_auth_enable &#x3D; yes&#39;</span><br><span class="line">postconf -e &#39;broken_sasl_auth_clients &#x3D; yes&#39;</span><br><span class="line">postconf -e &#39;smtpd_sasl_authenticated_header &#x3D; yes&#39;</span><br><span class="line">postconf -e &#39;smtpd_recipient_restrictions &#x3D; permit_mynetworks, permit_sasl_authenticated, reject_unauth_destination&#39;</span><br><span class="line">postconf -e &#39;smtpd_use_tls &#x3D; yes&#39;</span><br><span class="line">postconf -e &#39;smtpd_tls_cert_file &#x3D; &#x2F;etc&#x2F;pki&#x2F;dovecot&#x2F;certs&#x2F;dovecot.pem&#39;</span><br><span class="line">postconf -e &#39;smtpd_tls_key_file &#x3D; &#x2F;etc&#x2F;pki&#x2F;dovecot&#x2F;private&#x2F;dovecot.pem&#39;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>配置中 Postfix 使用 sasl 和 tls 来完成身份认证和传输信息加密。<br>试验中使用了 Dovecot 默认的 ssl 证书和私钥，如果你需要修改为自己的，请替换最后两行配置的路径。</li>
</ul>
<ol start="3">
<li>配置 smtps</li>
</ol>
<ul>
<li>部分邮件客户端依赖于使用 465 端口提供加密连接，所以我们修改配置，允许 Postfix 使用 465 端口发送邮件。打开 /etc/postfix/master.cf 文件，将如下两行前的 # 去除：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smtps inet n - n - - smtpd</span><br><span class="line">-o smtpd_tls_wrappermode&#x3D;yes</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>启动</li>
</ol>
<ul>
<li>使用以下命令，将 Postfix 设为自动启动并首次启动该服务：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable postfix.service</span><br><span class="line">systemctl start  postfix.service</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li>log</li>
</ol>
<ul>
<li>Postfix 系统的日志文件在系统的这个目录下的 /var/log/maillog 文件，此文件记录了 Postfix 服务器的运行状态信息。<h4 id="dovecot"><a href="#dovecot" class="headerlink" title="dovecot"></a>dovecot</h4></li>
</ul>
<ol>
<li>安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install dovecot</span><br></pre></td></tr></table></figure></li>
<li>配置</li>
</ol>
<ul>
<li>打开 /etc/dovecot/dovecot.conf 文件，在最下方加入以下配置：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssl_cert &#x3D; &lt;&#x2F;etc&#x2F;pki&#x2F;dovecot&#x2F;certs&#x2F;dovecot.pem</span><br><span class="line">ssl_key &#x3D; &lt;&#x2F;etc&#x2F;pki&#x2F;dovecot&#x2F;private&#x2F;dovecot.pem</span><br><span class="line"></span><br><span class="line">protocols &#x3D; imap pop3 lmtp</span><br><span class="line">listen &#x3D; *</span><br><span class="line">mail_location &#x3D; Maildir:~&#x2F;Maildir</span><br><span class="line">disable_plaintext_auth &#x3D; no</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>如果前面你修改为了自己的 ssl 证书和私钥，请替换开始两行配置的路径。</li>
<li>打开 /etc/dovecot/conf.d/10-master.conf 文件，找到 service auth 部分，将以下行前面的 # 去除：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unix_listener &#x2F;var&#x2F;spool&#x2F;postfix&#x2F;private&#x2F;auth &#123;  </span><br><span class="line">       mode &#x3D; 0666  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>启动<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable dovecot.service</span><br><span class="line">systemctl start  dovecot.service</span><br></pre></td></tr></table></figure></li>
<li>log</li>
</ol>
<ul>
<li>查看 /var/log/maillog 是否启动成功，如下所示为成功。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jun 26 12:00:28 localhost postfix&#x2F;postfix-script[28338]: starting the Postfix mail system</span><br><span class="line">Jun 26 12:00:29 localhost postfix&#x2F;master[28340]: daemon started -- version 2.10.1, configuration &#x2F;etc&#x2F;postfix</span><br><span class="line">Jun 26 12:28:40 localhost dovecot: master: Dovecot v2.2.10 starting up for imap, pop3, lmtp (core dumps disabled)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4></li>
<li>添加用户<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uaeradd username</span><br></pre></td></tr></table></figure></li>
<li>设置密码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure>
<h4 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h4></li>
<li>su mailuser 切换用户</li>
<li>发送邮件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;邮件内容&quot; | mail -s &quot;邮件主题&quot;  目标邮箱</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>使用</category>
        <category>mail</category>
      </categories>
      <tags>
        <tag>vps</tag>
        <tag>mail</tag>
        <tag>myself</tag>
      </tags>
  </entry>
  <entry>
    <title>code-server</title>
    <url>/2021/04/21/code-server/</url>
    <content><![CDATA[<h1 id="code-server"><a href="#code-server" class="headerlink" title="code-server"></a>code-server</h1><ul>
<li>code-server is a cloud ide platform, which can enable us to code through browser anywhere. But how to set up the code-server on ubuntu 18.04</li>
<li>Eeee, to practice my English, I prefer to using English in my blog, unless there is something I can’t express by using my poor English.<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4></li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkdir ~/code-server</span><br><span class="line">cd ~/code-server</span><br><span class="line">proxychains wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/cdr/</span>code-server<span class="regexp">/releases/</span>download<span class="regexp">/v3.10.1/</span>code-server-<span class="number">3.10</span>.<span class="number">1</span>-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xzvf code-server-<span class="number">3.10</span>.<span class="number">1</span>-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">mv code-server-<span class="number">3.10</span>.<span class="number">1</span>-linux-amd64 code-server</span><br><span class="line"></span><br><span class="line">rm -rf <span class="regexp">/usr/</span>lib/code-server</span><br><span class="line"></span><br><span class="line">cp -r code-server <span class="regexp">/usr/</span>lib/code-server</span><br><span class="line"></span><br><span class="line">ln -s <span class="regexp">/usr/</span>lib<span class="regexp">/code-server/</span>code-server <span class="regexp">/usr/</span>bin/code-server</span><br><span class="line"></span><br><span class="line">mkdir <span class="regexp">/var/</span>lib/code-server</span><br><span class="line"></span><br><span class="line">vi <span class="regexp">/lib/</span>systemd<span class="regexp">/system/</span>code-server.service</span><br></pre></td></tr></table></figure>
<p><strong>填入以下内容</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=code-server</span><br><span class="line"><span class="attr">After</span>=nginx.service</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">Environment</span>=PASSWORD=your_password</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/code-server --bind-addr <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span> --user-data-dir /var/lib/code-server --auth password</span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p><strong>启动</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">systemctl <span class="keyword">start</span> code-<span class="keyword">server</span></span><br><span class="line">systemctl <span class="keyword">enable</span> code-<span class="keyword">server</span></span><br><span class="line">systemctl status code-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>

<p><strong>export</strong><br>使用nginx使得外网可以访问</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span>code-server</span><br></pre></td></tr></table></figure>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> code-server.your-domain;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://localhost:8080/;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade $http_upgrade;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Connection upgrade;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Accept-Encoding gzip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ln -s <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span>code-server <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-enabled/</span>code-server</span><br><span class="line"></span><br><span class="line">nginx -t</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>

<p><strong>Securing Your Domain</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add</span>-apt-repository ppa:certbot/certbot</span><br><span class="line">apt install python-certbot-nginx</span><br><span class="line">ufw allow <span class="keyword">https</span></span><br><span class="line">ufw reload</span><br><span class="line">certbot <span class="comment">--nginx -d code-server.your-domain</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>code-server 3.9.3之后的版本在markdown preview 时滚轮不同步。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>linux</tag>
        <tag>code-server</tag>
      </tags>
  </entry>
  <entry>
    <title>git的使用</title>
    <url>/2021/03/23/git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h1><h2 id="创建git库"><a href="#创建git库" class="headerlink" title="创建git库"></a>创建git库</h2><h4 id="初始化git"><a href="#初始化git" class="headerlink" title="初始化git"></a>初始化git</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir gittest</span><br><span class="line">cd gittest</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<h4 id="将要添加的文件加入git管理"><a href="#将要添加的文件加入git管理" class="headerlink" title="将要添加的文件加入git管理"></a>将要添加的文件加入git管理</h4><p>  <strong>add 从工作区到暂存区</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add [filename]</span><br></pre></td></tr></table></figure>
<p>或者将目录下所有文件都加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<h4 id="自定义所要添加的文件"><a href="#自定义所要添加的文件" class="headerlink" title="自定义所要添加的文件"></a>自定义所要添加的文件</h4><p>总是手动add每一个太麻烦了，但总有些不希望添加进去的，可以这样。</p>
<ul>
<li>创建一个文件名为的文件<blockquote>
<p>.gitignore</p>
</blockquote>
</li>
<li>文件内容为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file</span><br><span class="line">.*</span><br><span class="line">!.gitignore</span><br><span class="line">!file1</span><br></pre></td></tr></table></figure></li>
<li>这表示名为file的文件要加进去</li>
<li>所有文件都要加进去</li>
<li>忽略 .gitignore</li>
<li>忽略 file1</li>
</ul>
<h4 id="提交到仓库"><a href="#提交到仓库" class="headerlink" title="提交到仓库"></a>提交到仓库</h4><p><strong>commit 将暂存区提交到仓库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m [提交描述]</span><br></pre></td></tr></table></figure>
<p> <strong>每次commit之前都要add所要进行管理的文件</strong> </p>
<h4 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">简略版</span><br><span class="line">git status -s</span><br></pre></td></tr></table></figure>
<h4 id="查看文件更改情况"><a href="#查看文件更改情况" class="headerlink" title="查看文件更改情况"></a>查看文件更改情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff [filename]</span><br></pre></td></tr></table></figure>

<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p><strong>在commit之后后悔了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log </span><br><span class="line">git log --oneline &#x2F;&#x2F;简略版</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用git log 查看之前提交的记录，记下回退的版本号commit id 输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard [commit id]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>注意只有在head指向的版本之前的,</strong> 切换版本到当前版本之后的 输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4></li>
<li><p>丢弃对工作区的修改 add之前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- [filename]</span><br></pre></td></tr></table></figure></li>
<li><p><em>checkout就是用版本库里的版本替换工作区的版本</em>*</p>
</li>
<li><p>丢弃对暂存区的修改 add之后 commit之前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD [filename]</span><br></pre></td></tr></table></figure>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h4 id="创建ssh-key"><a href="#创建ssh-key" class="headerlink" title="创建ssh key"></a>创建ssh key</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;myemail@163.com&quot;</span><br></pre></td></tr></table></figure>
<p>在用户目录里找到id_rsa.pub,将里面的数据复制到GitHub中,这样就可以从本地电脑推送到GitHub中了.</p>
<h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add repo1 git@github.com:yishuilingbo&#x2F;gittest.git</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="查看本地所有仓库"><a href="#查看本地所有仓库" class="headerlink" title="查看本地所有仓库"></a>查看本地所有仓库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<h4 id="推送到远程库"><a href="#推送到远程库" class="headerlink" title="推送到远程库"></a>推送到远程库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u [库名] [分支名]</span><br></pre></td></tr></table></figure></li>
<li><p>加上了-u参数，Git不但会把本地的分支内容推送的远程新的分支，还会把本地的分支和远程的分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<h4 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库"></a>删除远程库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rm [库名]</span><br></pre></td></tr></table></figure>
<h4 id="克隆库"><a href="#克隆库" class="headerlink" title="克隆库"></a>克隆库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:yishuilingbo&#x2F;gittest.git</span><br><span class="line">cd [库名]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h4 id="建立新的分支"><a href="#建立新的分支" class="headerlink" title="建立新的分支"></a>建立新的分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch [branchname]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git switch branch [branchname]</span><br></pre></td></tr></table></figure>
<h4 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git switch -c [branchname]</span><br></pre></td></tr></table></figure>
<h4 id="合并分支到当前分支"><a href="#合并分支到当前分支" class="headerlink" title="合并分支到当前分支"></a>合并分支到当前分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge [来源分支名]</span><br></pre></td></tr></table></figure>
<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d [branchname]</span><br></pre></td></tr></table></figure>
<ul>
<li>若该分支没有被合并过，以下强制删除<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -D [branchname]</span><br></pre></td></tr></table></figure>
<h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4></li>
<li>当两个不同的分支对同一对象进行修改并提交之后会发生 merge conflict<br>此时需要查看冲突文件手动解决冲突。<h4 id="查看分支合并图"><a href="#查看分支合并图" class="headerlink" title="查看分支合并图"></a>查看分支合并图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure>
简洁版<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br></pre></td></tr></table></figure>
<h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4>通常合并分支的时候，git会采用<strong>fast forward</strong>模式。这种模式下，git只是把分支指针向前移动，此时，删除掉分支之后将会丢失分支信息。若要强制禁止<strong>fast forward</strong>,git就会在merge的时候生成一个新的commit,这样即使删除该分支，也可以从log上查看历史信息。</li>
<li>强制禁止<strong>fast forward</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge --no-ff -m [commit 描述] [来源分支名]</span><br></pre></td></tr></table></figure>
<h4 id="修复main分支上的bug流程"><a href="#修复main分支上的bug流程" class="headerlink" title="修复main分支上的bug流程"></a>修复main分支上的bug流程</h4></li>
</ul>
<ol>
<li>当前在dev分支，先保存工作现场<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></li>
<li>切换到main分支，并建立新的分支bugfix</li>
<li>在新的分支上修改bug,然后提交后合并到main   产生一个commit id fixbug</li>
<li>回到dev分支，回复现场<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash pop  &#x2F;&#x2F;这将删除这条stash</span><br><span class="line">或者</span><br><span class="line">git stash list &#x2F;&#x2F;查看stash list</span><br><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></li>
<li>将修复的信息复制到当前dev分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cherry-pick [commit id]</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="多人合作冲突"><a href="#多人合作冲突" class="headerlink" title="多人合作冲突"></a>多人合作冲突</h4><ol>
<li>pull 下来之后手动解决冲突在再合并push</li>
</ol>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ol>
<li>切换到要创建标签的分支上<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag [标签名]</span><br></pre></td></tr></table></figure>
默认标签打在最新的commit上面</li>
<li>对历史commit打标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --pretty&#x3D;oneline --abbrev-commit  &#x2F;&#x2F;列出历史commit</span><br><span class="line">git tag [tag] [commit id]</span><br></pre></td></tr></table></figure></li>
<li>指定标签信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -a [tag] -m [info] [commit id]</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>标签总是和对应的commit挂钩</strong></p>
<h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git tag -d [tag]</span><br></pre></td></tr></table></figure>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>标签只存储到本地，不会自动推送到远程，可以这样推送到远程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git push [库名] [tag]</span><br><span class="line">git push [库名] --tags  <span class="comment">//一次性推送所有标签</span></span><br></pre></td></tr></table></figure>
<h4 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git push [库名] :ref/tags/[tag]</span><br></pre></td></tr></table></figure>
<h2 id="git报错"><a href="#git报错" class="headerlink" title="git报错"></a>git报错</h2><h4 id="refusing-to-merge-unrelated-histories"><a href="#refusing-to-merge-unrelated-histories" class="headerlink" title="refusing to merge unrelated histories"></a>refusing to merge unrelated histories</h4><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><ul>
<li>首先再github上创建一个仓库</li>
<li>在本地初始化一个仓库。</li>
<li>添加远程仓库</li>
<li>git push -u ge main</li>
<li>报错为<blockquote>
<p>$ git push -u ge main<br>To github.com:yishuilingbo/XYY-Game-Engine.git<br>! [rejected]        main -&gt; main (non-fast-forward)<br>error: failed to push some refs to ‘github.com:yishuilingbo/XYY-Game-Engine.git’<br>hint: Updates were rejected because the tip of your current branch is behind<br>hint: its remote counterpart. Integrate the remote changes (e.g.<br>hint: ‘git pull …’) before pushing again.</p>
</blockquote>
</li>
</ul>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li>本地仓库和远程仓库实际上是独立的两个仓库。假如之前是直接clone的方式在本地建立起远程github仓库的克隆本地仓库就不会有这问题了。<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$git pull [库名] [分支名] --allow-unrelated-histories</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="接着解决冲突然后-push即可"><a href="#接着解决冲突然后-push即可" class="headerlink" title="接着解决冲突然后 push即可"></a>接着解决冲突然后 push即可</h4></li>
</ul>
<h2 id="多仓库-multiple-ssh-keys-on-one-computer"><a href="#多仓库-multiple-ssh-keys-on-one-computer" class="headerlink" title="多仓库 multiple ssh keys on one computer"></a>多仓库 multiple ssh keys on one computer</h2><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>生成ssh key ,并给生成的文件使用绝对路径特定地命名。</li>
<li>在 .ssh 目录下新建config文件，内容为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#gittest</span><br><span class="line">Host gittest.github.com</span><br><span class="line">	HostName github.com</span><br><span class="line">	User git</span><br><span class="line">	IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_gittest</span><br><span class="line">	IdentitiesOnly yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#coebase</span><br><span class="line">Host codebase.github.com</span><br><span class="line">	HostName github.com</span><br><span class="line">	User git</span><br><span class="line">	IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_codebase</span><br><span class="line">	IdentitiesOnly yes</span><br><span class="line"></span><br><span class="line">#coebases</span><br><span class="line">Host blog.github.com</span><br><span class="line">	HostName github.com</span><br><span class="line">	User git</span><br><span class="line">	IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_codebase</span><br><span class="line">	IdentitiesOnly yes</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>修改本地仓库地config中的url<br>eg:<br>gittest地config本来为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">	url &#x3D; git@github.com:yishuilingbo&#x2F;gittest.git</span><br><span class="line">	fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*</span><br></pre></td></tr></table></figure>
修改为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">	url &#x3D; git@gittest.github.com:yishuilingbo&#x2F;gittest.git</span><br><span class="line">	fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*</span><br></pre></td></tr></table></figure>
即添加上gittest.</li>
<li>在GitHub上的仓库中添加刚刚生成的deploy key</li>
</ol>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>即对于不同的仓库使用不同的key,并且使用别名来区分不同的仓库。<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4></li>
<li><a href="https://gist.github.com/jexchan/2351996">https://gist.github.com/jexchan/2351996</a></li>
</ul>
]]></content>
      <categories>
        <category>使用</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h1 id="hexo-quick-start"><a href="#hexo-quick-start" class="headerlink" title="hexo quick start"></a>hexo quick start</h1><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>hello_world</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的使用</title>
    <url>/2021/03/22/hexo%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="hello-hexo"><a href="#hello-hexo" class="headerlink" title="hello hexo"></a>hello hexo</h1><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><ul>
<li>安装git</li>
<li>安装Node.js<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2></li>
<li>window cmd 下输入 npm install -g hexo-cli<h2 id="使用hexo"><a href="#使用hexo" class="headerlink" title="使用hexo"></a>使用hexo</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hexo init &lt;foldername&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="安装server与deployer"><a href="#安装server与deployer" class="headerlink" title="安装server与deployer"></a>安装server与deployer</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &#x2F;&#x2F;生成文章</span><br><span class="line">hexo c  &#x2F;&#x2F;清理</span><br><span class="line">hexo g  &#x2F;&#x2F;生成</span><br><span class="line">hexo s  &#x2F;&#x2F;启动本地服务</span><br><span class="line">hexo d  &#x2F;&#x2F;部署</span><br><span class="line">简单地使用为 hexo g -d</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="以上就是hexo的基础使用了。"><a href="#以上就是hexo的基础使用了。" class="headerlink" title="以上就是hexo的基础使用了。"></a>以上就是hexo的基础使用了。</h4><hr>
<h2 id="配置github-page"><a href="#配置github-page" class="headerlink" title="配置github page"></a>配置github page</h2><ul>
<li>建立一个GitHub仓库</li>
<li>将仓库配置为GitHub page</li>
<li>输入自己的域名 cuimouren.cn</li>
</ul>
<h2 id="解析自己的域名到GitHub-page"><a href="#解析自己的域名到GitHub-page" class="headerlink" title="解析自己的域名到GitHub page"></a>解析自己的域名到GitHub page</h2><h4 id="添加如下的域名解析记录"><a href="#添加如下的域名解析记录" class="headerlink" title="添加如下的域名解析记录"></a>添加如下的域名解析记录</h4><ul>
<li>主机记录： @</li>
<li>记录类型： CNAME</li>
<li>线路类型： 默认</li>
<li>记录值：     yishuilingbo.github.io  即GitHub page分配的网址</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr>
<h4 id="到此就完成了框架性的工作"><a href="#到此就完成了框架性的工作" class="headerlink" title="到此就完成了框架性的工作"></a>到此就完成了框架性的工作</h4><hr>
<h2 id="‘菜’的坑"><a href="#‘菜’的坑" class="headerlink" title="‘菜’的坑"></a>‘<strong>菜’的坑</strong></h2><h3 id="注意得在cmd环境下进行操作，powershell不行。"><a href="#注意得在cmd环境下进行操作，powershell不行。" class="headerlink" title="注意得在cmd环境下进行操作，powershell不行。"></a>注意得在cmd环境下进行操作，powershell不行。</h3><h3 id="Hexo在部署到Github后CNAME文件会消失或改变的解决方法"><a href="#Hexo在部署到Github后CNAME文件会消失或改变的解决方法" class="headerlink" title="Hexo在部署到Github后CNAME文件会消失或改变的解决方法"></a>Hexo在部署到Github后CNAME文件会消失或改变的解决方法</h3><h4 id="问题经过"><a href="#问题经过" class="headerlink" title="问题经过:"></a>问题经过:</h4><ul>
<li><p>在转移网站后,在 Github网页上修改CNAME文件中指向的域名后,重新部署Hexo时发现CNAME指向的域名是之前的网站,而没有编程修改后的域名.排查后发现:</p>
</li>
<li><p>Hexo在Github上部署后,如果配置了一个自定义域名时,会自动在项目仓库根目录想新建一个CNAME文件,但是重新部署后CNAME会消失或者变成修改之前的状态,导致需要再次手动修改.</p>
</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h4><ul>
<li>直接修改 hexo目录 下 source 文件夹内的CNAME文件的内容,用编辑器打开,第一行输入需要配置的域名.这样在部署的时候CNAME 文件会自动部署到Github.不用再次手动修改.</li>
</ul>
<h3 id="注意配置git的username-与-email"><a href="#注意配置git的username-与-email" class="headerlink" title="注意配置git的username 与 email"></a>注意配置git的username 与 email</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;name&quot;</span><br><span class="line">git config --global user.email &quot;email@gmail.com&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="git网络问题"><a href="#git网络问题" class="headerlink" title="git网络问题"></a>git网络问题</h3><h4 id="设置git的代理"><a href="#设置git的代理" class="headerlink" title="设置git的代理"></a>设置git的代理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy 127.0.0.1:7890</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="deployer-not-found"><a href="#deployer-not-found" class="headerlink" title="deployer not found"></a>deployer not found</h3><ul>
<li>npm install hexo-deployer-git –save</li>
</ul>
<h3 id="permission-denied"><a href="#permission-denied" class="headerlink" title="permission denied"></a>permission denied</h3><ul>
<li>hexo 只支持单用户凭证，所以需要去控制面板中更改git:<a href="https://github.com/">https://github.com</a> 的用户凭证即可。使用哪一个github用户时就更新成哪一个。</li>
</ul>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>linux base</title>
    <url>/2021/04/19/linux-base/</url>
    <content><![CDATA[<h1 id="linux-base"><a href="#linux-base" class="headerlink" title="linux base"></a>linux base</h1><h4 id="centos6-定时重启"><a href="#centos6-定时重启" class="headerlink" title="centos6 定时重启"></a>centos6 定时重启</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;crontab</span><br><span class="line">按照提示添加 </span><br><span class="line">00 06 * * * root reboot</span><br><span class="line">载入内存</span><br><span class="line">crontab &#x2F;etc&#x2F;crontab</span><br><span class="line">启动服务并设置开机自启动</span><br><span class="line">systemctl enable crond.service</span><br><span class="line">systemctl restart crond.service</span><br><span class="line">查看定时配置</span><br><span class="line">crontab -l</span><br><span class="line">查看系统启动记录</span><br><span class="line">last reboot</span><br><span class="line">who -b</span><br></pre></td></tr></table></figure>
<h4 id="ubuntu-设置root-ssh-登录"><a href="#ubuntu-设置root-ssh-登录" class="headerlink" title="ubuntu 设置root ssh 登录"></a>ubuntu 设置root ssh 登录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">重置 root 的密码</span><br><span class="line">sudo passwd root</span><br><span class="line">su</span><br><span class="line">vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config </span><br><span class="line">将 PermitRootLogin 参数修改为 yes。</span><br><span class="line">将 PasswordAuthentication 参数修改为 yes。</span><br><span class="line">若 sshd_config 配置文件中无此配置项，则添加 PasswordAuthentication yes 项即可。</span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>
<h4 id="远程复制"><a href="#远程复制" class="headerlink" title="远程复制"></a>远程复制</h4><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul>
<li>问题描述：<br>安装postgresql开发环境的时候，配置环境变量，写入export PGHOME到 /etc/profile中，由于需要重启机器才能使修改全面生效；<br>在不重启电脑的情况下，每次打开终端都得source一下才能生效。如何才能立刻生效呢？</li>
</ul>
<p>解决方法：由于每次启动终端的时候，都会执行 /etc/bashrc ，所以可以把source /etc/profile 命令<br>写入到 /etc/bashrc 文件中，实现环境变量立刻全面生效的效果。</p>
<h4 id="忘记root密码"><a href="#忘记root密码" class="headerlink" title="忘记root密码"></a>忘记root密码</h4><p>按住shift键reboot进入grub,选择advanced option，进入recovery mode, 选择root drop to root shell prompt</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux command</title>
    <url>/2021/04/21/linux-journey/</url>
    <content><![CDATA[<h1 id="linux-command"><a href="#linux-command" class="headerlink" title="linux command"></a>linux command</h1><h2 id="command-line"><a href="#command-line" class="headerlink" title="command line"></a>command line</h2><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><ul>
<li>let’s start with a siple command, echo. The command just prints out the arguments to the display.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo hello,world!</span><br></pre></td></tr></table></figure>
<h4 id="pwd-print-working-directory"><a href="#pwd-print-working-directory" class="headerlink" title="pwd (print working directory)"></a>pwd (print working directory)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>
<h4 id="cd-change-directory"><a href="#cd-change-directory" class="headerlink" title="cd (change directory)"></a>cd (change directory)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;test</span><br><span class="line">cd test2</span><br></pre></td></tr></table></figure></li>
<li>. ( current directory)</li>
<li>.. (parent directory)</li>
<li>~ (home directory)</li>
<li>- (previous directory)</li>
</ul>
<h4 id="ls-list-directories"><a href="#ls-list-directories" class="headerlink" title="ls (list directories)"></a>ls (list directories)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls </span><br><span class="line">ls &#x2F;home</span><br><span class="line">ls -a   show all of the files include the files which are hidden.</span><br><span class="line">ls -l   l means long, this command will show the files with their detile.</span><br><span class="line">ls -la  show all the files with their detile.</span><br><span class="line">ls -R   recursively list directory contents.</span><br><span class="line">ls -r   reverse order while sorting.</span><br><span class="line">ls -t   sort by modification time, newest first.</span><br></pre></td></tr></table></figure>

<h4 id="touch-create-a-filw"><a href="#touch-create-a-filw" class="headerlink" title="touch (create a filw)"></a>touch (create a filw)</h4><ul>
<li>touch allows you to create new empty files.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch myfile</span><br></pre></td></tr></table></figure></li>
<li>touch is also used to change timestamps on existing files and directories. <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch myfile</span><br><span class="line">touch mydirectory</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="file-show-the-type-of-the-file’s-contents"><a href="#file-show-the-type-of-the-file’s-contents" class="headerlink" title="file (show the type of the file’s contents)"></a>file (show the type of the file’s contents)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file myfile</span><br></pre></td></tr></table></figure>

<h4 id="cat-show-the-content-of-files"><a href="#cat-show-the-content-of-files" class="headerlink" title="cat (show the content of files)"></a>cat (show the content of files)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat file1 file2</span><br></pre></td></tr></table></figure>

<h4 id="less-show-less-of-a-file"><a href="#less-show-less-of-a-file" class="headerlink" title="less (show less of a file)"></a>less (show less of a file)</h4><ul>
<li>if you are viewing text files larger than a simple output.(which means it is too big to view on your screen.) you can use less to open it, that can make it easy to view the file.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget linuxqq_2.0.0-b2-1089_x86_64.sh</span><br><span class="line">mv linuxqq_2.0.0-b2-1089_x86_64.sh qq</span><br><span class="line">less qq</span><br></pre></td></tr></table></figure></li>
<li>the text is displayed in a paged manner, so you can navigate through a text file page by page.<blockquote>
<p>q  quit out of less and back to your shell<br>Page up, Page down, up and down Navigate.<br>g move to the beginning of the text file<br>G move to the end of the file<br>h help<br>/search search the content behind /</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less qq</span><br><span class="line">&#x2F;qq</span><br></pre></td></tr></table></figure>

<h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history   show commands you have typed</span><br><span class="line">ctrl-R 	  </span><br><span class="line">clear 	  clear the screen</span><br></pre></td></tr></table></figure>
<h4 id="cp-copy"><a href="#cp-copy" class="headerlink" title="cp (copy)"></a>cp (copy)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp myfile &#x2F;home&#x2F;files</span><br><span class="line">cp *.jpg &#x2F;home&#x2F;jpgs</span><br><span class="line">cp -r directoryone&#x2F; &#x2F;home&#x2F;document   copy the directory</span><br><span class="line">cp -i my file &#x2F;home&#x2F;files   prompt you before overwriting a same-name-file.</span><br></pre></td></tr></table></figure>
<h4 id="mv-move"><a href="#mv-move" class="headerlink" title="mv (move)"></a>mv (move)</h4><ul>
<li>rename file or directory<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv a b</span><br><span class="line">mv directory1 directory2</span><br></pre></td></tr></table></figure></li>
<li>move files and directories  to somewhere<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv a b directory1 directory2 &#x2F;home</span><br></pre></td></tr></table></figure></li>
<li>wanna a prompt<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv -i directory1 directory2</span><br></pre></td></tr></table></figure></li>
<li>make a backup of the file which is going to be overwritten.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv b a</span><br><span class="line">the previous file a will be back up and renamed as ~a</span><br></pre></td></tr></table></figure>
<h4 id="mkdir-make-a-directory"><a href="#mkdir-make-a-directory" class="headerlink" title="mkdir (make a directory)"></a>mkdir (make a directory)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir one two</span><br></pre></td></tr></table></figure></li>
<li>wanna to create subdirectories?<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p one&#x2F;one two&#x2F;tow</span><br></pre></td></tr></table></figure>
<h4 id="rm-remove"><a href="#rm-remove" class="headerlink" title="rm (remove)"></a>rm (remove)</h4></li>
<li>delete a file. the file being deleted will not been pushing into a trash can, so be careful about rm. <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm filea</span><br></pre></td></tr></table></figure></li>
<li>force to delete <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -f filea</span><br></pre></td></tr></table></figure></li>
<li>wanna a prompt<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -i filea</span><br></pre></td></tr></table></figure></li>
<li>delete directories<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -r directory </span><br><span class="line">or </span><br><span class="line">rmdir directory</span><br></pre></td></tr></table></figure>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;home -name qq</span><br></pre></td></tr></table></figure></li>
<li>find a directory<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;home -type d -name mydirectory</span><br></pre></td></tr></table></figure>
<h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help echo</span><br><span class="line">echo --help</span><br></pre></td></tr></table></figure>
<h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man ls</span><br></pre></td></tr></table></figure>
<h4 id="whatis-briefly-describe-a-file"><a href="#whatis-briefly-describe-a-file" class="headerlink" title="whatis (briefly describe a file)"></a>whatis (briefly describe a file)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whatis cat</span><br></pre></td></tr></table></figure>
<h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4></li>
<li>set a alias for a command. the alias are saved in ~/.bashrc<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias foobar&#x3D;&#39;ls la&#39;</span><br></pre></td></tr></table></figure></li>
<li>unlias<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unalias foobar</span><br></pre></td></tr></table></figure>
<h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4></li>
<li>exit the shell<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">or </span><br><span class="line">logout</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>以下信息来源于</strong> <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html">linux tools quick tutorial</a></p>
<h4 id="命令帮助"><a href="#命令帮助" class="headerlink" title="命令帮助"></a>命令帮助</h4><ul>
<li>简要说明命令的作用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whatis [command]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>正则匹配<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whatis -w &quot;m*&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>详细说明<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info [command]</span><br><span class="line">man [command]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>查看路径<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which [command]</span><br></pre></td></tr></table></figure></li>
<li>查看程序的搜索路径,当系统中安装了一个软件的多个版本的话，这个命令可以帮助确定版本。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis [command]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h4><h4 id="创建和删除"><a href="#创建和删除" class="headerlink" title="创建和删除"></a>创建和删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir</span><br><span class="line">touch </span><br><span class="line">rm</span><br><span class="line">mv </span><br><span class="line">cp</span><br></pre></td></tr></table></figure>
<h4 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br><span class="line">cd -  #切换到上一个工作目录</span><br><span class="line">cd ~  #回到home目录</span><br><span class="line">cd ..&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="查找目录与文件"><a href="#查找目录与文件" class="headerlink" title="查找目录与文件"></a>查找目录与文件</h4><h4 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h4><p>dd</p>
<blockquote>
<p>if=file #read from file instead of stdin<br>of-file write to file instead of stdout<br>by=bytes #read and write bytes bytes at a time (指定块大小)<br>count=blocks #copy only blocks input blocks 指定块数量<br>seek=blocks #把块输出到文件时指定要跳过的几块<br>conv=convs #指定追加数据时的操作 notrunc 是不打断文件。<br>dd if=mbr.bin of=hd60M.hd bs=512 count=1 seek=0 conv=notrunc</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nonetag</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown的使用方法</title>
    <url>/2021/03/22/markdown%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="markdown-的使用方法"><a href="#markdown-的使用方法" class="headerlink" title="markdown 的使用方法"></a>markdown 的使用方法</h1><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><ul>
<li>星号数量为标题等级<h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4></li>
<li>markdown换行直接在后面加上两个以上的空格就好。<h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><blockquote>
<p>*斜体文本*<br>_斜体文本_<br>**粗体文本**<br>__粗体文本__<br>***粗斜体文本***<br>___粗斜体文本___    </p>
</blockquote>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4></li>
<li>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<hr>
<hr>
<hr>
<h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><ul>
<li>在文字的两端加上两个波浪线 <del>即可</del><blockquote>
<p><del>删除</del></p>
</blockquote>
<h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4></li>
<li>下划线可以通过 HTML 的 <u> 标签来实现：</u><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;带下划线文本&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure>
<h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4></li>
</ul>
<p>创建脚注格式类似这样 [^RUNOOB]。</p>
<p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul>
<li>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容。</li>
<li>有序列表使用数字并加上 . 号来表示。<h6 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h6></li>
<li>列表嵌套只需在子列表中的选项前面添加四个空格即可。</li>
</ul>
<ol>
<li>一</li>
<li>二<ol>
<li>一</li>
<li>二</li>
<li>三</li>
</ol>
</li>
<li>三</li>
</ol>
<ul>
<li><p>一</p>
</li>
<li><p>二</p>
</li>
<li><p>the <code>asd</code>.</p>
</li>
</ul>
<h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><ul>
<li>在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</li>
</ul>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ul>
<li>用 ``` 包裹一段代码，并指定一种语言<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><blockquote>
<p>[百度](baidu.com)<br>&lt;baidu.com&gt;</p>
</blockquote>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><blockquote>
<p>![picture](/img/love.png)</p>
</blockquote>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><ul>
<li>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</li>
</ul>
<blockquote>
<p>|  表头   | 表头  |<br>|  —  | —  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |    </p>
</blockquote>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<blockquote>
<p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。   </p>
</blockquote>
<blockquote>
<p>| 左对齐 | 右对齐 | 居中对齐 |<br>| :—–| —-: | :—-: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |   </p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<h4 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h4><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 CentOS 搭建 Discuz 论坛</title>
    <url>/2021/04/19/%E5%9F%BA%E4%BA%8E-CentOS-%E6%90%AD%E5%BB%BA-Discuz-%E8%AE%BA%E5%9D%9B/</url>
    <content><![CDATA[<h1 id="基于-CentOS-搭建-Discuz-论坛"><a href="#基于-CentOS-搭建-Discuz-论坛" class="headerlink" title="基于 CentOS 搭建 Discuz 论坛"></a>基于 CentOS 搭建 Discuz 论坛</h1><h4 id="准备LAMP环境"><a href="#准备LAMP环境" class="headerlink" title="准备LAMP环境"></a>准备LAMP环境</h4><ul>
<li>LAMP 是 Linux、Apache、MySQL 和 PHP 的缩写，是 Discuz 论坛系统依赖的基础运行环境。</li>
<li>MySQL<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install mysql-server </span><br><span class="line">service mysqld restart</span><br><span class="line">设置MySQL的账户和密码</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;mysqladmin -u root password &#39;mypassword&#39; </span><br><span class="line">设置开机自启动</span><br><span class="line">chkconfig mysqld on</span><br></pre></td></tr></table></figure></li>
<li>apache<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install httpd</span><br><span class="line">service httpd restart</span><br><span class="line">chkconfig httpd on</span><br></pre></td></tr></table></figure></li>
<li>php<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install php php-fpm -php-mysql -y</span><br><span class="line">service php-fpm restart</span><br><span class="line">查看php-fpm 进程监听的窗口</span><br><span class="line">netstat -nlpt |grep php-fpm</span><br><span class="line">chkconfig php-fpm on</span><br></pre></td></tr></table></figure></li>
<li>discuz<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载</span><br><span class="line">wget https:&#x2F;&#x2F;labs-1253675457.cos.ap-guangzhou.myqcloud.com&#x2F;Discuz_X3.2_SC_UTF8.zip</span><br><span class="line">unzip Discuz_X3.2_SC_UTF8.zip</span><br><span class="line">由于PHP默认访问 &#x2F;var&#x2F;www&#x2F;html&#x2F; 文件夹，所以我们需要把upload文件夹里的文件都复制到 &#x2F;var&#x2F;www&#x2F;html&#x2F; 文件夹</span><br><span class="line">cp -r upload&#x2F;* &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">给 &#x2F;var&#x2F;www&#x2F;html 目录及其子目录赋予权限</span><br><span class="line">chmod -R 777 &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">service httpd restart</span><br></pre></td></tr></table></figure></li>
<li>域名</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>discuz</tag>
      </tags>
  </entry>
  <entry>
    <title>零碎的技术</title>
    <url>/2021/04/21/%E9%9B%B6%E7%A2%8E%E7%9A%84%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="零碎的技术"><a href="#零碎的技术" class="headerlink" title="零碎的技术"></a>零碎的技术</h1><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><blockquote>
<p>记录类型:<br>A记录：将域名指向一个IPv4地址（例如：10.10.10.10），需要增加A记录<br>CNAME记录：如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录<br>主机记录：<br>www ：将域名解析为<a href="http://www.example.com,填写www;/">www.example.com，填写www；</a><br>@ ：将域名解析为example.com（不带www），填写@或者不填写；</p>
</blockquote>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>use nginx on ubuntu 18.04</title>
    <url>/2021/04/25/use-nginx-on-ubuntu-18-04/</url>
    <content><![CDATA[<h1 id="nginx-on-ubuntu-18-04"><a href="#nginx-on-ubuntu-18-04" class="headerlink" title="nginx on ubuntu 18.04"></a>nginx on ubuntu 18.04</h1><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><ol>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04">How To Install Nginx on Ubuntu 18.04</a></li>
<li><a href="http://nginx.org/en/docs/beginners_guide.html">nginx beginner’s guide</a><h4 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h4></li>
</ol>
<ul>
<li>nginx is one of the most popular web servers in the world and is responsible for hosting some of the largest and high-traffic sites on the internet. it is more resource-friendly than apache in most cases and can be used as a web server or reverse proxy.</li>
<li>in this guild, we will discuss how to install nginx on my ubuntu 18.04 server.<h4 id="step1-install-nginx"><a href="#step1-install-nginx" class="headerlink" title="step1 (install nginx)"></a>step1 (install nginx)</h4></li>
<li>because nginx is available in ubuntu’s default repositories, it is possible to install it from these repositories using the apt packaging system.</li>
<li>it may be the first interaction with the apt packaging system, so i’d like to update my local package index so that i have access to the most recent package listings. afterwards, i can install nginx<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install nginx</span><br></pre></td></tr></table></figure></li>
<li>after accepting the procedure, apt will install nginx and any required dependencies to my server.<h4 id="step2-adjusting-the-firewall"><a href="#step2-adjusting-the-firewall" class="headerlink" title="step2 (adjusting the firewall)"></a>step2 (adjusting the firewall)</h4></li>
<li>before testing nginx, the firewall software needs to be adjusted to allow access to the service. nginx registers itself as a service with ufw upon installation, making it straightforward to allow nginx access.</li>
<li>list the application configurations that ufw know how to work with by typing:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ufw app list</span><br></pre></td></tr></table></figure></li>
<li>you should get a listing of the application profiles.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Available applications:</span><br><span class="line">  Nginx Full</span><br><span class="line">  Nginx HTTP</span><br><span class="line">  Nginx HTTPS</span><br><span class="line">  OpenSSH</span><br></pre></td></tr></table></figure></li>
<li>Nginx Full: this profile opens both port 80(normal, unencrypted web traffic) and port 443(TLS/SSL encrypted traffic)</li>
<li>Nginx HTTP: this profile opens only the port 80.</li>
<li>Nginx HTTPS: this profile opens only port 443.</li>
<li>it is recommended that you enable the most restrictive profile that will still allow the traffic you have configured. however, i have not configured SSL for my server, i will only need to allow traffic on port 80.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ufw enable &quot;Nginx HTTP&quot;</span><br></pre></td></tr></table></figure>
<h4 id="checking-your-web-server"><a href="#checking-your-web-server" class="headerlink" title="checking your web server"></a>checking your web server</h4></li>
<li>at the end of the installation process, ubuntu starts nginx, the web server should already be up and running. we can check with the systemd init system to make sure the service is running by typing:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure></li>
<li>output:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">● nginx.service - A high performance web server and a reverse proxy server</span><br><span class="line">   Loaded: loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Sun 2021-04-25 17:46:15 CST; 7min ago</span><br><span class="line">     Docs: man:nginx(8)</span><br><span class="line">  Process: 1156 ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx -g daemon on; master_process on; (code&#x3D;exited, s</span><br><span class="line">  Process: 1039 ExecStartPre&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx -t -q -g daemon on; master_process on; (code&#x3D;</span><br><span class="line"> Main PID: 1170 (nginx)</span><br><span class="line">    Tasks: 2 (limit: 2121)</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;nginx.service</span><br><span class="line">           ├─1170 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -g daemon on; master_process on;</span><br><span class="line">           └─1176 nginx: worker process</span><br><span class="line"></span><br><span class="line">Apr 25 17:46:15 VM-4-14-ubuntu systemd[1]: Starting A high performance web server and a re</span><br><span class="line">Apr 25 17:46:15 VM-4-14-ubuntu systemd[1]: nginx.service: Failed to parse PID from file &#x2F;r</span><br><span class="line">Apr 25 17:46:15 VM-4-14-ubuntu systemd[1]: Started A high performance web server and a rev</span><br><span class="line">lines 1-15&#x2F;15 (END)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>as you can see above, the service appears to have started successfully, however, the best way to test this is to actually request a page from nginx.</li>
<li>you can access the default nginx landing page to confirm that the software is running properly by navigating to your server’s ip address. you can get your ipv4 address on the internet by typing:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -4 icanhazip.com</span><br></pre></td></tr></table></figure></li>
<li>enter it to your browser’s address bar, you will see the default nginx landing page.<h4 id="step4-manager-the-nginx-process"><a href="#step4-manager-the-nginx-process" class="headerlink" title="step4 (manager the nginx process)"></a>step4 (manager the nginx process)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br><span class="line">systemctl stop nginx</span><br><span class="line">systemctl restart nginx</span><br><span class="line">systemctl reload nginx</span><br><span class="line">systemctl enable nginx</span><br><span class="line">systemctl disable nginx</span><br></pre></td></tr></table></figure>
<h4 id="step5-setting-up-server-blocks"><a href="#step5-setting-up-server-blocks" class="headerlink" title="step5 (setting up server blocks)"></a>step5 (setting up server blocks)</h4></li>
<li>when using the nginx web server, server blocks(similar to virtual hosts in apache)can be used to encapsulate configuration details and host more than one domain form a single server. i will set a domain called nginx.cuimouren.cn to test this.</li>
<li>nginx on ubuntu has one server block enabled by default that is configured to serve documents out of a directory at /var/www/html. while this works well for one single site, it can become unwieldly if you are hosting multiple sites. instead of modifying /var/www/html, let’s create a directory structure within /var/www for my nginx.cuimouren.cn site, leaving /var/www/html in place as the default directory to be served if a client request does not match any other sites.</li>
<li>create a directory for nginx.cuimouren.cn, using -p flag to create any necessary parent directories. i will using my github page as a test.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;var&#x2F;www&#x2F;nginx.cuimouren.cn</span><br><span class="line">cd &#x2F;var&#x2F;www&#x2F;nginx.cuimouren.cn</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;yishuilingbo&#x2F;yishuilingbo.github.io.git</span><br><span class="line">cd yishuilingbo.github.io</span><br><span class="line">mv * ..&#x2F;</span><br><span class="line">rm -rf yishuilingbo.github.io</span><br></pre></td></tr></table></figure></li>
<li>in order for nginx to server this content, it’s necessary to create a server block with the correct directives, instead of modifying the default configuration file directly, let’s make a new one.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;nginx.cuimouren.cn</span><br></pre></td></tr></table></figure></li>
<li>write like these<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen [::]:80;</span><br><span class="line"></span><br><span class="line">        root &#x2F;var&#x2F;www&#x2F;nginx.cuimouren.cn;</span><br><span class="line">        index index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">        server_name nginx.cuimouren.cn www.nginx.cuimouren.cn;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">                try_files $uri $uri&#x2F; &#x3D;404;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>enable the file by creating a link form it to the “sites-enabled” directory, which nginx reads from during startup<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;nginx.cuimouren.cn &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;</span><br></pre></td></tr></table></figure></li>
<li>test to make sure that there are no syntax error in any nginx files.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure></li>
<li>restart nginx<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure></li>
<li>look my site on the browser.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx.cuimouren.cn</span><br></pre></td></tr></table></figure>
<h4 id="step6-securing-my-domain"><a href="#step6-securing-my-domain" class="headerlink" title="step6 securing my domain"></a>step6 securing my domain</h4></li>
<li>in this section, i will secure my domain using a let’s encrypt tls sertificate, which i will provision using certbot.<br>to install the lastest version of sertbot, i will need to add its package repository to my server by running the following command:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add-apt-repository ppa:certbot&#x2F;certbot</span><br><span class="line">#install its nginx plugin</span><br><span class="line">apt install python-sertbot-nginx</span><br><span class="line">ufw allow https</span><br><span class="line">ufw reload</span><br><span class="line">certbot --nginx -d mydomain</span><br></pre></td></tr></table></figure></li>
<li>i recommand to use the second option in order to maximize security.</li>
</ul>
<h4 id="step7-getting-familiar-with-important-nginx-files-and-directories"><a href="#step7-getting-familiar-with-important-nginx-files-and-directories" class="headerlink" title="step7 (getting familiar with important nginx files and directories)"></a>step7 (getting familiar with important nginx files and directories)</h4><ul>
<li>now that you know how to manage the nginx service itself, you should take a few minutes to familiarize yourself with a few important directories and files.</li>
</ul>
<h6 id="content"><a href="#content" class="headerlink" title="content"></a>content</h6><ul>
<li><strong>/var/www/html</strong><blockquote>
<p>the actual web content, which by default only consists of the nginx page you saw earlier, is served out of the <strong>/var/www/html</strong> directory, this can be changed by altering nginx configuration files.</p>
</blockquote>
</li>
</ul>
<h6 id="server-configuration"><a href="#server-configuration" class="headerlink" title="server configuration"></a>server configuration</h6><ul>
<li><p><strong>/etc/nginx</strong></p>
<blockquote>
<p>the nginx configuration direction. all of the nginx configuration files reside here.</p>
</blockquote>
</li>
<li><p>** /etc/nginx/nginx.conf**</p>
<blockquote>
<p>the main nginx configuration file. this can be modified to make changes to the nginx global configuration.</p>
</blockquote>
</li>
<li><p><strong>/etc/nginx/sites-available</strong></p>
<blockquote>
<p>the directory where per-site server blocks can be stored. nginx will not use the configuration files found in this directory unless they are linked to the <strong>sites-enabled</strong> directory. typically, all server block configuration is done in the directory, and then enabled by linking to the other directory.</p>
</blockquote>
</li>
<li><p><strong>/etc/nginx/sites-enabled</strong></p>
<blockquote>
<p>the directory where enabled per-site server blocks are stored. typically, these are created by linking to configuration files found in the <strong>sites-available</strong> directory.</p>
</blockquote>
</li>
<li><p><strong>/etc/nginx/snippets</strong></p>
<blockquote>
<p>this directory contains configuration fragments that can be included elsewhere in the nginx configuration. potentially repeatable configuration segments are good candidates for refactoring into snippets.</p>
</blockquote>
</li>
</ul>
<h6 id="server-logs"><a href="#server-logs" class="headerlink" title="server logs"></a>server logs</h6><ul>
<li><p><strong>/var/log/nginx/access.log</strong></p>
<blockquote>
<p>every request to your web server is recorded in the log file unless nginx is configured to do otherwise.</p>
</blockquote>
</li>
<li><p><strong>/var/log/nginx/error/log</strong></p>
<blockquote>
<p>any nginx error will be recorded in this log.</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>ngiinx</tag>
      </tags>
  </entry>
  <entry>
    <title>proxy trojan</title>
    <url>/2021/04/21/proxy-trojan/</url>
    <content><![CDATA[<h1 id="proxy-trojan"><a href="#proxy-trojan" class="headerlink" title="proxy trojan"></a>proxy trojan</h1><h4 id="trojan-server-服务端"><a href="#trojan-server-服务端" class="headerlink" title="trojan server 服务端"></a>trojan server 服务端</h4><ul>
<li>傻瓜式一键部署，（等我Linux学有所成了再自己一步一步地配置）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -O https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;atrandys&#x2F;trojan&#x2F;master&#x2F;trojan_mult.sh &amp;&amp; chmod +x trojan_mult.sh &amp;&amp; .&#x2F;trojan_mult.sh</span><br></pre></td></tr></table></figure></li>
<li>按照提示进行部署。需要手动输入域名和密码。</li>
<li>结果会输出一个如下的配置，config。保存这个配置(config.json)，待会要用。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;run_type&quot;: &quot;client&quot;,</span><br><span class="line">    &quot;local_addr&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;: 1080,</span><br><span class="line">    &quot;remote_addr&quot;: &quot;domain&quot;,</span><br><span class="line">    &quot;remote_port&quot;: 443,</span><br><span class="line">    &quot;password&quot;: [</span><br><span class="line">        &quot;password&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;log_level&quot;: 1,</span><br><span class="line">    &quot;ssl&quot;: &#123;</span><br><span class="line">        &quot;verify&quot;: true,</span><br><span class="line">        &quot;verify_hostname&quot;: true,</span><br><span class="line">        &quot;cert&quot;: &quot;&quot;,</span><br><span class="line">        &quot;cipher_tls13&quot;:&quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;,</span><br><span class="line">        &quot;sni&quot;: &quot;&quot;,</span><br><span class="line">        &quot;alpn&quot;: [</span><br><span class="line">            &quot;h2&quot;,</span><br><span class="line">            &quot;http&#x2F;1.1&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;reuse_session&quot;: true,</span><br><span class="line">        &quot;session_ticket&quot;: false,</span><br><span class="line">        &quot;curves&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tcp&quot;: &#123;</span><br><span class="line">        &quot;no_delay&quot;: true,</span><br><span class="line">        &quot;keep_alive&quot;: true,</span><br><span class="line">        &quot;fast_open&quot;: false,</span><br><span class="line">        &quot;fast_open_qlen&quot;: 20</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="trojan-client-客户端"><a href="#trojan-client-客户端" class="headerlink" title="trojan client 客户端"></a>trojan client 客户端</h4><h6 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h6></li>
<li>windows 下推荐使用clash。</li>
<li>github 上下载 clash for windows,安装。</li>
<li>clash 配置示例如下。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port: 7890</span><br><span class="line">socks-port: 7891</span><br><span class="line">redir-port: 7892</span><br><span class="line">allow-lan: false</span><br><span class="line">mode: rule</span><br><span class="line">log-level: info</span><br><span class="line">external-controller: 127.0.0.1:9090</span><br><span class="line">proxies:</span><br><span class="line">  - type: trojan</span><br><span class="line">    name: 0.trojan</span><br><span class="line">    server: server&#39;ip</span><br><span class="line">    port: 443</span><br><span class="line">    password: 密码</span><br><span class="line">    sni: download.windowsupdate.com</span><br><span class="line">    skip-cert-verify: true</span><br><span class="line"></span><br><span class="line">    url: http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204</span><br><span class="line">    interval: 300</span><br></pre></td></tr></table></figure>
<h6 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h6></li>
<li>以Ubuntu为例</li>
<li>下载Trojan<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;src</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;trojan-gfw&#x2F;trojan&#x2F;releases&#x2F;download&#x2F;v1.16.0&#x2F;trojan-1.16.0-linux-amd64.tar.xz</span><br><span class="line">tar xvf trojan-1.16.0-linux-amd64.tar.xz</span><br><span class="line">cd &#x2F;usr&#x2F;src&#x2F;trojan</span><br><span class="line">vi config.json</span><br></pre></td></tr></table></figure></li>
<li>将上面server生成的config复制到这里。即可。</li>
<li>为Trojan注册服务。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;trojan.service &lt;&lt;-EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;trojan</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">PIDFile&#x3D;&#x2F;usr&#x2F;src&#x2F;trojan&#x2F;trojan.pid</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;src&#x2F;trojan&#x2F;trojan -c &#x2F;usr&#x2F;src&#x2F;trojan&#x2F;config.json -l &#x2F;usr&#x2F;src&#x2F;trojan&#x2F;trojan.log</span><br><span class="line">ExecReload&#x3D;&#x2F;bin&#x2F;kill -HUP \$MAINPID</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line">RestartSec&#x3D;1s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li>
<li>启动Trojan<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start trojan</span><br></pre></td></tr></table></figure></li>
<li>检查是否启动成功<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps aux | grep trojan | grep -v grep</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看到有类似 /usr/src/trojan/trojan 的内容展示，即表示trojan正在运行<br>如果未启动成功，通过这个命令查看日志： cat /usr/src/trojan/trojan.log<br>还可以执行 curl ip.sb –socks5 127.0.0.1:1080, 查看结果是否为Trojan代理的IP</p>
</blockquote>
</li>
<li>设置开机启动<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable trojan</span><br></pre></td></tr></table></figure></li>
<li>命令行使用Trojan代理，免去使用镜像却又找不到之苦。<blockquote>
<p>安装配置proxychains，全局翻墙通过proxychains实现，即将任何程序和Trojan的proxy建立链接，原理和浏览器的代理相似。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install proxychains</span><br><span class="line">vi &#x2F;etc&#x2F;proxychains.conf</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在最后的ProxyList里注释默认的socks代理： socks4 前增加#表示注释<br>在最后的ProxyList里加入Trojan的代理设置： socks5 127.0.0.1 1080<br>测试本地IP: curl -4 ip.sb，将显示自己的IP<br>测试代理IP: proxychains curl -4 ip.sb，将显示Trojan代理的IP<br>后续使用的命令行需要代理时，只需要在前面加上 proxychains 即可<br>如 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains wget https:&#x2F;&#x2F;github.com&#x2F;cdr&#x2F;code-server&#x2F;releases&#x2F;download&#x2F;v3.9.3&#x2F;code-server-3.9.3-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hahahaha,，没错，我要开始配置code-server了。见下一讲 code-server.</p>
</blockquote>
</li>
</ul>
<h4 id="linux-加速"><a href="#linux-加速" class="headerlink" title="linux 加速"></a>linux 加速</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget &quot;https:&#x2F;&#x2F;github.com&#x2F;chiakge&#x2F;Linux-NetSpeed&#x2F;raw&#x2F;master&#x2F;tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; .&#x2F;tcp.sh</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>proxy</tag>
        <tag>trojan</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 编程</title>
    <url>/2021/05/06/shell-%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="shell-编程"><a href="#shell-编程" class="headerlink" title="shell 编程"></a>shell 编程</h1><ul>
<li>最近在用Linux倒腾一些东西，发现好多东西都可以使用写成一个shell脚本来简化，所以学习一下shell.</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;hello,world!&quot;</span><br></pre></td></tr></table></figure>
<h4 id="shell-变量"><a href="#shell-变量" class="headerlink" title="shell 变量"></a>shell 变量</h4> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意不能加空格</span></span><br><span class="line">myname=<span class="string">&quot;cuiwenyao&quot;</span></span><br><span class="line">echo $&#123;myname&#125;</span><br><span class="line">hername=<span class="string">&quot;qinmengyao&quot;</span></span><br><span class="line">echo $&#123;myname&#125; <span class="string">&quot;love&quot;</span> $&#123;hername&#125;</span><br><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="built_in">string</span>=<span class="string">&quot;$&#123;myname&#125; &quot;</span>love<span class="string">&quot; $&#123;hername&#125;&quot;</span></span><br><span class="line">echo <span class="built_in">string</span></span><br><span class="line"><span class="comment">//获取长度</span></span><br><span class="line">echo $&#123;<span class="meta">#myname&#125;</span></span><br><span class="line"><span class="comment">//提取字串</span></span><br><span class="line"><span class="built_in">string</span>=$&#123;myname:<span class="number">1</span>:<span class="number">2</span>&#125;</span><br><span class="line">echo <span class="built_in">string</span></span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li>bash 只支持一维数组。</li>
<li>shell用小括号表示数组，数组元素用空格分开。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">myarray=(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line">echo $&#123;myarray[<span class="number">0</span>]&#125;</span><br><span class="line">myarray[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">echo $&#123;myarray[<span class="number">0</span>]&#125;</span><br><span class="line"><span class="comment">//获取所有元素</span></span><br><span class="line">echo $&#123;myarray[@]&#125;</span><br><span class="line"><span class="comment">//获取数组长度</span></span><br><span class="line">echo $&#123;<span class="meta">#myarray[@]&#125;</span></span><br><span class="line">echo $&#123;<span class="meta">#myarray[*]&#125;</span></span><br><span class="line"><span class="comment">//获取单个元素的长度</span></span><br><span class="line">echo $&#123;<span class="meta">#myarray[0]&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
<td>`expr $a + $b`</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>`expr $a - $b`</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>`expr $a * $b`</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>`expr $a / $b`</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>`expr $a % $b`</td>
</tr>
<tr>
<td>=</td>
<td>赋值</td>
<td>`expr $a = $b`</td>
</tr>
<tr>
<td>==</td>
<td>相等。</td>
<td>`expr $a == $b`</td>
</tr>
<tr>
<td>!=</td>
<td>不相等。</td>
<td>`expr $a != $b`</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">20</span></span><br><span class="line">r=`expr $&#123;a&#125; + $&#123;b&#125;`</span><br><span class="line">echo $&#123;r&#125;</span><br><span class="line">r=`expr $&#123;a&#125; - $&#123;b&#125;`</span><br><span class="line">echo $&#123;r&#125;</span><br><span class="line">r=`expr $&#123;a&#125; \* $&#123;b&#125;`</span><br><span class="line">echo $&#123;r&#125;</span><br><span class="line">r=`expr $&#123;a&#125; / $&#123;b&#125;`</span><br><span class="line">echo $&#123;r&#125;</span><br><span class="line">r=`expr $&#123;a&#125; % $&#123;b&#125;`</span><br><span class="line">echo $&#123;r&#125;</span><br></pre></td></tr></table></figure>
<h6 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h6><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>相等</td>
<td>[${a} -eq ${b}]</td>
</tr>
<tr>
<td>-ne</td>
<td>不相等</td>
<td>[${a} -ne ${b}]</td>
</tr>
<tr>
<td>-gt</td>
<td>大于</td>
<td>[${a} -gt ${b}]</td>
</tr>
<tr>
<td>-lt</td>
<td>小于</td>
<td>[${a} -lt ${b}]</td>
</tr>
<tr>
<td>-ge</td>
<td>大于等于</td>
<td>[${a} -ge ${b}]</td>
</tr>
<tr>
<td>-le</td>
<td>小于等于</td>
<td>[${a} -le ${b}]</td>
</tr>
<tr>
<td>!</td>
<td>非</td>
<td>[！false]</td>
</tr>
<tr>
<td>-o</td>
<td>或</td>
<td>[${a} -lt 20 -o ${b} -gt 100]</td>
</tr>
<tr>
<td>-a</td>
<td>与</td>
<td>[${a} -lt 20 -a ${b} -gt 100]</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>[[${a} -lt 20 || ${b} -gt 100]]</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>[[${a} -lt 20 &amp;&amp; ${b} -gt 100]]</td>
</tr>
</tbody></table>
<h6 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h6><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>检测两个字符串是否相等，相等返回 true。</td>
<td>[ $a = $b ] 返回 false。</td>
</tr>
<tr>
<td>!=</td>
<td>检测两个字符串是否相等，不相等返回 true。</td>
<td>[ $a != $b ] 返回 true。</td>
</tr>
<tr>
<td>-z</td>
<td>检测字符串长度是否为0，为0返回 true。</td>
<td>[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td>-n</td>
<td>检测字符串长度是否为0，不为0返回 true。</td>
<td>[ -n $a ] 返回 true。</td>
</tr>
<tr>
<td>str</td>
<td>检测字符串是否为空，不为空返回 true。</td>
<td>[ $a ] 返回 true。</td>
</tr>
</tbody></table>
<h6 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h6><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>是否是块设备文件</td>
<td>[ -b $file ]</td>
</tr>
<tr>
<td>-c</td>
<td>是否是字符设备文件</td>
<td>[ -c $file ]</td>
</tr>
<tr>
<td>-d</td>
<td>是否是目录</td>
<td>[ -d $file ]</td>
</tr>
<tr>
<td>-f</td>
<td>是否是普通文件（既不是目录，也不是设备文件）</td>
<td>[ -f $file ]</td>
</tr>
<tr>
<td>-g</td>
<td>是否设置了 SGID 位</td>
<td>[ -g $file ]</td>
</tr>
<tr>
<td>-k</td>
<td>是否设置了粘着位</td>
<td>[ -k $file ]</td>
</tr>
<tr>
<td>-p</td>
<td>是否是有名管道</td>
<td>[ -p $file ]</td>
</tr>
<tr>
<td>-u</td>
<td>是否设置了 SUID 位</td>
<td>[ -u $file ]</td>
</tr>
<tr>
<td>-r</td>
<td>文件是否可读</td>
<td>[ -r $file ]</td>
</tr>
<tr>
<td>-w</td>
<td>是否可写</td>
<td>[ -w $file ]</td>
</tr>
<tr>
<td>-x</td>
<td>是否可执行</td>
<td>[ -x $file ]</td>
</tr>
<tr>
<td>-s</td>
<td>是否为空</td>
<td>[ -s $file ]</td>
</tr>
<tr>
<td>-e</td>
<td>检测文件（包括目录）是否存在</td>
<td>[ -e $file ]</td>
</tr>
</tbody></table>
<h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><ul>
<li>shell的流程不可为空。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line">num1&#x3D;$[2*4]</span><br><span class="line">num2&#x3D;$[1+5]</span><br><span class="line">if test $[num1] -eq 8</span><br><span class="line">then</span><br><span class="line">    echo &#39;两个数字相等!&#39;</span><br><span class="line">elif test $[num1] -lt $[num2]</span><br><span class="line">then </span><br><span class="line">    echo &#39;两个数字不相等!&#39;</span><br><span class="line">else</span><br><span class="line">    echo &#39;this is else&#39;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">array&#x3D;(1 2 3 4)</span><br><span class="line">for var in $&#123;array[@]&#125;</span><br><span class="line">do </span><br><span class="line">    echo $&#123;var&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;while 测试 1&quot;</span><br><span class="line">var&#x3D;5</span><br><span class="line">while (( $&#123;var&#125;&lt;&#x3D;10 ))</span><br><span class="line">do </span><br><span class="line">    echo $&#123;var&#125;</span><br><span class="line">    var&#x3D;&#96;expr $&#123;var&#125; + 1&#96;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;while 测试 2&quot;</span><br><span class="line">var&#x3D;5</span><br><span class="line">while test $&#123;var&#125; -ne 10</span><br><span class="line">do </span><br><span class="line">    echo $&#123;var&#125;</span><br><span class="line">    let &quot;var++&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;while 测试 3&quot;</span><br><span class="line">echo &quot;按下ctrl+d退出&quot;</span><br><span class="line">echo &quot;输入a,b的值,我会帮你输出和&quot;</span><br><span class="line">while read a b</span><br><span class="line">do </span><br><span class="line">    if test $&#123;a&#125; -eq 10 </span><br><span class="line">    then </span><br><span class="line">        echo &quot;退出&quot;</span><br><span class="line">        break</span><br><span class="line">    fi</span><br><span class="line">    echo &#96;expr $&#123;a&#125; + $&#123;b&#125;&#96;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;until 测试 1&quot;</span><br><span class="line">var&#x3D;0</span><br><span class="line">until test $&#123;var&#125; -eq 10</span><br><span class="line">do</span><br><span class="line">    echo $&#123;var&#125;</span><br><span class="line">    var&#x3D;&#96;expr $&#123;var&#125; + 1&#96;</span><br><span class="line">    echo $&#123;var&#125;</span><br><span class="line">    let &quot;var++&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;case 测试 1&quot;</span><br><span class="line">var&#x3D;1</span><br><span class="line">case $&#123;var&#125; in</span><br><span class="line">1)</span><br><span class="line">    echo &quot;1&quot;</span><br><span class="line">    ;;</span><br><span class="line">2) </span><br><span class="line">    echo &quot;2&quot;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">fun()&#123;</span><br><span class="line">    echo &quot;这个函数会对三个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($&#123;aNum&#125;+$&#123;anotherNum&#125;+$&#123;1&#125;))</span><br><span class="line">&#125;</span><br><span class="line">fun 10</span><br><span class="line">echo &quot;三个数字之和为 $? !&quot;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td>$-</td>
<td>显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
<h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. test.sh</span><br><span class="line">source test.sh</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>os 001 bochs</title>
    <url>/2021/05/11/os-001-bochs/</url>
    <content><![CDATA[<h1 id="make-an-os-001"><a href="#make-an-os-001" class="headerlink" title="make an os -001"></a>make an os -001</h1><ul>
<li>积攒了这么久，终于要开始写一个操作系统了，加油。</li>
</ul>
<h4 id="bochs"><a href="#bochs" class="headerlink" title="bochs"></a>bochs</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;cfhcable.dl.sourceforge.net&#x2F;project&#x2F;bochs&#x2F;bochs&#x2F;2.6.2&#x2F;bochs-2.6.2.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>解压进入目录中</li>
<li>configure</li>
</ul>
<blockquote>
<p>./configure –prefix=/lib/bochs –enable-debugger –enable-disasm  –enable-iodebug  –enable-x86-debugger  –with-x –with-x11</p>
</blockquote>
<ul>
<li><p>make<br>make会出现lpthread未链接的信息，则添加以下内容。<br>修改Makefile 在93行加入以下信息</p>
<blockquote>
<p>./configure –prefix=/lib/bochs –enable-debugger –enable-disasm  –enable-iodebug  –enable-x86-debugger  –with-x –with-x11<br>191行与192行改为</p>
<p>$(LIBS) \    </p>
<pre><code>   -lpthread
</code></pre>
</blockquote>
</li>
<li><p>make install</p>
</li>
<li><p>Makefile的示例如下<br><a href="/file/bochs/Makefile">makefile</a></p>
</li>
<li><p>配置bochs的启动选项<br><a href="/file/bochs/conf">conf</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Bochs配置文件</span><br><span class="line"></span><br><span class="line"># 机器内存: 32MB</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line"># 对应真实机器的bios</span><br><span class="line">romimage: file&#x3D;&#x2F;lib&#x2F;bochs&#x2F;share&#x2F;bochs&#x2F;BIOS-bochs-latest</span><br><span class="line"># 对应真实机器的VGA bios</span><br><span class="line">vgaromimage: file&#x3D;&#x2F;lib&#x2F;bochs&#x2F;share&#x2F;bochs&#x2F;VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"># 启动方式</span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line">log: bochs.out</span><br><span class="line"></span><br><span class="line"># 关闭鼠标</span><br><span class="line">mouse: enabled&#x3D;0</span><br><span class="line">keyboard:keymap&#x3D;&#x2F;lib&#x2F;bochs&#x2F;share&#x2F;bochs&#x2F;keymaps&#x2F;x11-pc-us.map</span><br><span class="line"># 硬盘设置</span><br><span class="line"></span><br><span class="line">ata0: enabled&#x3D;1, ioaddr1&#x3D;0x1f0, ioaddr2&#x3D;0x3f0, irq&#x3D;14</span><br><span class="line">ata0-master: type&#x3D;disk, path&#x3D;&quot;hd60M.img&quot;, mode&#x3D;flat, cylinders&#x3D;121, heads&#x3D;16, spt&#x3D;63</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>添加环境变量<br>在 <strong>/etc/profile</strong> 的最后一行添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;lib&#x2F;bochs&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure></li>
<li><p>启动bochs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boshs</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc 使用入门</title>
    <url>/2021/05/13/gcc-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="gcc-使用入门"><a href="#gcc-使用入门" class="headerlink" title="gcc 使用入门"></a>gcc 使用入门</h1><p>GCC是GUN Compiler Collection 的简称，除了编译程序之外，还包含其他的相关工具。</p>
<h4 id="程序的编译过程"><a href="#程序的编译过程" class="headerlink" title="程序的编译过程"></a>程序的编译过程</h4><p>对于GUN编译器来说，程序的编译要经过预处理、编译、汇编、连接四个阶段。</p>
<h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>输入c语言源文件 <strong>*.c</strong> ,输出中间文件 <strong>*.i</strong> ,该阶段主要处理源文件中的预处理指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>

<h6 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h6><p>输入中间文件 <strong>*.i</strong> ,输出汇编语言文件 <strong>*.s</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure>

<h6 id="汇编阶段"><a href="#汇编阶段" class="headerlink" title="汇编阶段"></a>汇编阶段</h6><p>输入汇编语言源 <strong>*.s</strong> ,输出机器语言文件 <strong>*.o</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure>

<h6 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h6><p>讲输入的机器代码文件 <strong>*.o</strong> 与其他的机器代码文件和库文件汇集成一个可执行的二进制代码文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc test.o -o test</span><br></pre></td></tr></table></figure>

<h4 id="常用命令编译选项"><a href="#常用命令编译选项" class="headerlink" title="常用命令编译选项"></a>常用命令编译选项</h4><h6 id="无选项编译链接"><a href="#无选项编译链接" class="headerlink" title="无选项编译链接"></a>无选项编译链接</h6><p>用法：gcc test.c<br>作用：将 test.c 预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认<br>输出为 a.out。</p>
<h6 id="选项-o"><a href="#选项-o" class="headerlink" title="选项 -o"></a>选项 -o</h6><p>用法：gcc test.c -o test<br>作用：将 test.c 预处理、汇编、编译并链接形成可执行文件 test。-o 选项用来指定输出文<br>件的文件名。</p>
<h6 id="选项-E"><a href="#选项-E" class="headerlink" title="选项 -E"></a>选项 -E</h6><p>用法：gcc -E test.c -o test.i<br>作用：将 test.c 预处理输出 test.i 文件。</p>
<h6 id="选项-S"><a href="#选项-S" class="headerlink" title="选项 -S"></a>选项 -S</h6><p>用法：gcc -S test.i<br>作用：将预处理输出文件 test.i 汇编成 test.s 文件。</p>
<h6 id="选项-c"><a href="#选项-c" class="headerlink" title="选项 -c"></a>选项 -c</h6><p>用法：gcc -c test.s<br>作用：将汇编输出文件 test.s 编译输出 test.o 文件。</p>
<h6 id="无选项链接"><a href="#无选项链接" class="headerlink" title="无选项链接"></a>无选项链接</h6><p>用法：gcc test.o -o test<br>作用：将编译输出文件 test.o 链接成最终可执行文件 test。</p>
<h6 id="选项-O"><a href="#选项-O" class="headerlink" title="选项-O"></a>选项-O</h6><p>用法：gcc -O1 test.c -o test<br>作用：使用编译优化级别 1 编译程序。级别为 1~3，级别越大优化效果越好，但编译时间越<br>长。</p>
<h4 id="多源文件的编译方法"><a href="#多源文件的编译方法" class="headerlink" title="多源文件的编译方法"></a>多源文件的编译方法</h4><p>如果有多个源文件，基本上有两种编译方法：<br>[假设有两个源文件为 test.c 和 testfun.c]</p>
<ol>
<li>多个文件一起编译<br>用法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc testfun.c test.c -o test</span><br></pre></td></tr></table></figure>
作用：将 testfun.c 和 test.c 分别编译后链接成 test 可执行文件。     </li>
<li>分别编译各个源文件，之后对编译后输出的目标文件链接。<br>用法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -c testfun.c &#x2F;&#x2F;将 testfun.c 编译成 testfun.o</span><br><span class="line">gcc -c test.c &#x2F;&#x2F;将 test.c 编译成 test.o</span><br><span class="line">gcc -o testfun.o test.o -o test &#x2F;&#x2F;将 testfun.o 和 test.o 链接成 test</span><br></pre></td></tr></table></figure>
以上两种方法相比较，第一中方法编译时需要所有文件重新编译，而第二种方法可以只<br>重新编译修改的文件，未修改的文件不用重新编译。</li>
</ol>
]]></content>
      <categories>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>os 003 protected mode</title>
    <url>/2021/05/14/os-003-protected-mode/</url>
    <content><![CDATA[<h1 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected mode"></a>protected mode</h1><h4 id="保护模式简介"><a href="#保护模式简介" class="headerlink" title="保护模式简介"></a>保护模式简介</h4><h6 id="实模式的缺陷"><a href="#实模式的缺陷" class="headerlink" title="实模式的缺陷"></a>实模式的缺陷</h6><ol>
<li><p>实模式下操作系统与用户程序属于听一个特权级，容易引起系统崩溃。</p>
</li>
<li><p>程序引用的地址指向真实的物理地址，即逻辑地址等于物理地址，不利于内存分片管理，容易造成内存碎片化。</p>
</li>
<li><p>用户程序可以随意访问任意内存。</p>
</li>
<li><p>一个短只能访问64KB地址，太小了，操作不方便。</p>
</li>
<li><p>一次只能运行一个程序。</p>
</li>
<li><p>只有20根地址线，只能寻址1M的空间，太小啦。   </p>
</li>
</ol>
<blockquote>
<p>为了克服实模式低劣的内存管理方式，开发出了保护模式。  </p>
</blockquote>
<h6 id="保护模式的特点"><a href="#保护模式的特点" class="headerlink" title="保护模式的特点"></a>保护模式的特点</h6><ol>
<li>寄存器扩展。</li>
<li>寻址空间扩展为4GB。</li>
<li>对内存分段并进行描述。全局描述符表，全局描述符表寄存器，段描述符缓冲寄存器。</li>
<li></li>
</ol>
<h6 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h6><p>进入保护模式的步骤为：</p>
<ol>
<li>打开A20</li>
<li>加载gdt</li>
<li>将cr0的pe位置1</li>
<li>jmp 刷新流水线</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;-----------------  打开A20  ----------------</span><br><span class="line">in al,0x92</span><br><span class="line">or al,0000_0010B</span><br><span class="line">out 0x92,al</span><br><span class="line"></span><br><span class="line">;-----------------  加载GDT  ----------------</span><br><span class="line">lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------  cr0第0位置1  ----------------</span><br><span class="line">mov eax, cr0</span><br><span class="line">or eax, 0x00000001</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>

<h4 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h4><h6 id="段描述符的结构"><a href="#段描述符的结构" class="headerlink" title="段描述符的结构"></a>段描述符的结构</h6><table>
<thead>
<tr>
<th>位</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>高32位</td>
<td></td>
</tr>
<tr>
<td>31-24</td>
<td>段基址31-24</td>
</tr>
<tr>
<td>23</td>
<td>G</td>
</tr>
<tr>
<td>22</td>
<td>D/B</td>
</tr>
<tr>
<td>21</td>
<td>L</td>
</tr>
<tr>
<td>20</td>
<td>AVL</td>
</tr>
<tr>
<td>19-16</td>
<td>段界限19-16</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
</tr>
<tr>
<td>14-13</td>
<td>DPL</td>
</tr>
<tr>
<td>12</td>
<td>S</td>
</tr>
<tr>
<td>11-8</td>
<td>TYPE</td>
</tr>
<tr>
<td>7-0</td>
<td>段基址23-16</td>
</tr>
<tr>
<td>低32位</td>
<td></td>
</tr>
<tr>
<td>31-16</td>
<td>段基址15-0</td>
</tr>
<tr>
<td>15-0</td>
<td>段界限15-0</td>
</tr>
</tbody></table>
<ol>
<li>实际的段界限值=（描述符中的段界限值+1）*（段界限的粒度，1B 或者 4KB) - 1</li>
<li>G=0，粒度为1B，G=1，粒度为4KB.<br>3、E=0，向上扩展，常用于代码段与数据段。E=1，向下扩展，常用于栈段。</li>
</ol>
<h6 id="全局描述符表-GDT"><a href="#全局描述符表-GDT" class="headerlink" title="全局描述符表 GDT"></a>全局描述符表 GDT</h6><p>全局描述符表相当于描述符的数组，每一个元素是8字节的描述符，使用选择子进行索引。GDT中的第0个描述符是不可用的。</p>
<h6 id="全局描述符表寄存器-GDTR"><a href="#全局描述符表寄存器-GDTR" class="headerlink" title="全局描述符表寄存器 GDTR"></a>全局描述符表寄存器 GDTR</h6><p>GDT存在于内存中，GDTR是一个专门指向全局描述符表的寄存器。结构如下：</p>
<table>
<thead>
<tr>
<th>47-15</th>
<th>15-0</th>
</tr>
</thead>
<tbody><tr>
<td>GDT初始地址</td>
<td>GDT界限</td>
</tr>
</tbody></table>
<p>在实模式先使用lgdt加载描述符表，但是由于实模式的限制，此时的GTD只能处于1M地址空间以内，所以到了保护模式可以再次进行lgdt更改GDT的位置。</p>
<p>lgdt [48位内存数据]<br>按小端字节序，前16位用于舒适化GDT界限，后32位，用于指定GDT的初始地址。</p>
<h6 id="选择子"><a href="#选择子" class="headerlink" title="选择子"></a>选择子</h6><p>在实模式下，段寄存器选择的是段基址，在开启内存分段后，段寄存器存储的是对应段描述符表的索引和相关数据。选择子的结构如下：</p>
<table>
<thead>
<tr>
<th>15-4</th>
<th>3</th>
<th>2-0</th>
</tr>
</thead>
<tbody><tr>
<td>描述符索引值</td>
<td>TI</td>
<td>RPL</td>
</tr>
</tbody></table>
<p>描述符索引值正好为12位，刚好和GDTR界限所确定的最大描述符数量相匹配。</p>
<h4 id="获得内存信息"><a href="#获得内存信息" class="headerlink" title="获得内存信息"></a>获得内存信息</h4><p>eg:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;-------  int 15h eax &#x3D; 0000E820h ,edx &#x3D; 534D4150h (&#39;SMAP&#39;) 获取内存布局  -------</span><br><span class="line"></span><br><span class="line">   xor ebx, ebx		      ;第一次调用时，ebx值要为0</span><br><span class="line">   mov edx, 0x534d4150	      ;edx只赋值一次，循环体中不会改变</span><br><span class="line">   mov di, ards_buf	      ;ards结构缓冲区</span><br><span class="line">.e820_mem_get_loop:	      ;循环获取每个ARDS内存范围描述结构</span><br><span class="line">   mov eax, 0x0000e820	      ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span><br><span class="line">   mov ecx, 20		      ;ARDS地址范围描述符结构大小是20字节</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能</span><br><span class="line">   add di, cx		      ;使di增加20字节指向缓冲区中新的ARDS结构位置</span><br><span class="line">   inc word [ards_nr]	      ;记录ARDS数量</span><br><span class="line">   cmp ebx, 0		      ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span><br><span class="line">   jnz .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span><br><span class="line">   mov cx, [ards_nr]	      ;遍历每一个ARDS结构体,循环次数是ARDS的数量</span><br><span class="line">   mov ebx, ards_buf </span><br><span class="line">   xor edx, edx		      ;edx为最大的内存容量,在此先清0</span><br><span class="line">.find_max_mem_area:	      ;无须判断type是否为1,最大的内存块一定是可被使用</span><br><span class="line">   mov eax, [ebx]	      ;base_add_low</span><br><span class="line">   add eax, [ebx+8]	      ;length_low</span><br><span class="line">   add ebx, 20		      ;指向缓冲区中下一个ARDS结构</span><br><span class="line">   cmp edx, eax		      ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span><br><span class="line">   jge .next_ards</span><br><span class="line">   mov edx, eax		      ;edx为总内存大小</span><br><span class="line">.next_ards:</span><br><span class="line">   loop .find_max_mem_area</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;------  int 15h ax &#x3D; E801h 获取内存大小,最大支持4G  ------</span><br><span class="line">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span><br><span class="line">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span><br><span class="line">.e820_failed_so_try_e801:</span><br><span class="line">   mov ax,0xe801</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法</span><br><span class="line"></span><br><span class="line">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span><br><span class="line">   mov cx,0x400	     ;cx和ax值一样,cx用做乘数</span><br><span class="line">   mul cx </span><br><span class="line">   shl edx,16</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">   or edx,eax</span><br><span class="line">   add edx, 0x100000 ;ax只是15MB,故要加1MB</span><br><span class="line">   mov esi,edx	     ;先把低15MB的内存容量存入esi寄存器备份</span><br><span class="line"></span><br><span class="line">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span><br><span class="line">   xor eax,eax</span><br><span class="line">   mov ax,bx		</span><br><span class="line">   mov ecx, 0x10000	;0x10000十进制为64KB</span><br><span class="line">   mul ecx		;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span><br><span class="line">   add esi,eax		;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span><br><span class="line">   mov edx,esi		;edx为总内存大小</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;-----------------  int 15h ah &#x3D; 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88: </span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">      </span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16	     ;把dx移到高16位</span><br><span class="line">   or edx, eax	     ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx	 ;将内存换为byte单位后存入total_mem_bytes处。</span><br></pre></td></tr></table></figure>

<h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p><strong>分段是分页的前提</strong></p>
<h6 id="内存分段模式下的问题"><a href="#内存分段模式下的问题" class="headerlink" title="内存分段模式下的问题"></a>内存分段模式下的问题</h6><ol>
<li>物理内存不足时怎么把？</li>
<li>内存碎片化问题怎么解决。</li>
</ol>
<blockquote>
<p>在保护模式下，段描述符是内存段的身份证，cpu根据一个段描述符来引用一个段。很多时候，段描述符对应的段并不在内存中。如果一个描述符的P位为1，则表示该段在内存中存在。访问过一个段后，cpu将该描述符中的A为置1。如果P位为0，则说明内存中不存在这个段，则cpu抛出np异常，操作系统将对应的段加载到内存中。</p>
</blockquote>
<blockquote>
<p>分页机制的思想是，通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的额线性地址在物理上可以不连续。分页机制将大小不不等的段分解为大小相等的页，再将页映射到物理页。分页机制的作用有：将线性地址转化为物理地址，用大小相等的页代替大小不等的段。有了页表的映射关系，经过段部件的处理输出的则为虚拟地址。在分页机制下，每个进程都认为自己独享整个4GB空间。即程序以为自己身处于段式存储下并拥有4GB空间，但是他的地址经由页部件处理之后才是真正的物理地址。</p>
</blockquote>
<h6 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h6><blockquote>
<p>页表用于存储线性地址与物理地址之间的映射。页表中的每一项为大小为4字节的页表项，用来记录4GB空间的物理地址。当访问一个线性地址的时候，实际上就是在访问页表项中对应的物理地址。</p>
</blockquote>
<blockquote>
<p>每个页大小为4KB，一个页表可以存储1M个页表项，加起来一个页表可以表示整个4GB物理空间。</p>
</blockquote>
<blockquote>
<p>一级页表的地址转换过程为：用线性地址的高20位作为页表项的索引，每个页表项占用4字节的大小，索引值乘上4就可以得到该页表项在页表中的偏移量。用cr3寄存器中的页表物理地址加上此偏移量就可以得到该页表项的物理地址，从该页表项中得到映射的物理地址，再与低12位的线性地址相加就可以得到最终要访问的物理地址。</p>
</blockquote>
<blockquote>
<p>假设咱们是在平坦模型下工作，不管段选择子值是多少，其所指向的段基址都是 0，指令 mov ax，<br>[0x1234]中的 0x1234 称为有效地址，它作为“段基址：段内偏移地址”中的段内偏移地址。这样段基址<br>为 0，段内偏移地址为 0x1234，经过段部件处理后，输出的线性地址是 0x1234。由于咱们是演示分页机制，必须假定系统已经打开了分页机制，所以线性地址 0x1234 被送入了页部件。页部件分析 0x1234 的高20 位，用十六进制表示高 20 位是 0x00001。将此项作为页表项索引，再将该索引乘以 4 后加上 cr3 寄存器中页表的物理地址，这样便得到索引所指代的页表项的物理地址，从该物理地址处（页表项中）读取所映射的物理页地址：0x9000。线性地址的低 12 位是 0x234，它作为物理页的页内偏移地址与物理页地址0x9000 相加，和为 0x9234，这就是线性地址 0x1234 最终转换成的物理地址。     </p>
</blockquote>
<h6 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h6><blockquote>
<p>二级页表将4GB空间按每一个标准页大小4KB分为1M个页，将这1M个页分1K*1K个页，每1K个页表项又正好可以组成一个新的页（1K*4B=4KB），将这个新产生的页记录为一个页表项，则总共会产生1K个新的页表项，再将这1K个页表项组成一个标准页，则最后产生的这个标准页为页目录表，其中每一项为页目录项PDE。</p>
</blockquote>
<blockquote>
<p>二级页表地址转换原理是将 32 位虚拟地址拆分成高 10 位、中间 10 位、低 12 位三部分，它们<br>的作用是：高 10 位作为页表的索引，用于在页目录表中定位一个页目录项 PDE，页目录项中有页表物理地址，也就是定位到了某个页表。中间 10 位作为物理页的索引，用于在页表内定位到某个页表项 PTE，页表项中有分配的物理页地址，也就是定位到了某个物理页。低 12 位作为页内偏移量用于在已经定位到的物理页内寻址。</p>
</blockquote>
<blockquote>
<p>转换过程背后的具体步骤如下。<br>（1）用虚拟地址的高 10 位乘以 4，作为页目录表内的偏移地址，加上页目录表的物理地址，所得的<br>和，便是页目录项的物理地址。读取该页目录项，从中获取到页表的物理地址。<br>（2）用虚拟地址的中间 10 位乘以 4，作为页表内的偏移地址，加上在第 1 步中得到的页表物理地址，<br>所得的和，便是页表项的物理地址。读取该页表项，从中获取到分配的物理页地址。<br>（3）虚拟地址的高 10 位和中间 10 位分别是 PDE 和 PTE 的索引值，所以它们需要乘以 4。但低 12 位就不是索引值啦，其表示的范围是 0～0xfff，作为页内偏移最合适，所以虚拟地址的低 12 位加上第 2 步中得到的物理页地址，所得的和便是最终转换的物理地址。 </p>
</blockquote>
<h6 id="页目录项和页表项的结构"><a href="#页目录项和页表项的结构" class="headerlink" title="页目录项和页表项的结构"></a>页目录项和页表项的结构</h6><p><strong>页目录项</strong>    </p>
<table>
<thead>
<tr>
<th>31-12</th>
<th>11-9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>页表物理页地址31-12位</td>
<td>AVL</td>
<td>G</td>
<td>0</td>
<td>D</td>
<td>A</td>
<td>PCD</td>
<td>PWT</td>
<td>US</td>
<td>RW</td>
<td>P</td>
</tr>
</tbody></table>
<p><strong>页表项</strong>    </p>
<table>
<thead>
<tr>
<th>31-12</th>
<th>11-9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>物理页地址31-12位</td>
<td>AVL</td>
<td>G</td>
<td>PAT</td>
<td>D</td>
<td>A</td>
<td>PCD</td>
<td>PWT</td>
<td>US</td>
<td>RW</td>
<td>P</td>
</tr>
</tbody></table>
<blockquote>
<p>页表目录项和页表项中的都是物理页地址，标准页大小就是4KB，所以地址都是4K的倍数，即低12位全为零，所以只需要记录高20位就可以了。省下来的12位可以用于其他属性。</p>
</blockquote>
<blockquote>
<p>P，Present，意为存在位。若为 1 表示该页存在于物理内存中，若为 0 表示该表不在物理内存中。操<br>作系统的页式虚拟内存管理便是通过 P 位和相应的 pagefault 异常来实现的。</p>
</blockquote>
<blockquote>
<p>RW，Read/Write，意为读写位。若为 1 表示可读可写，若为 0 表示可读不可写。</p>
</blockquote>
<blockquote>
<p>US，User/Supervisor，意为普通用户/超级用户位。若为 1 时，表示处于 User 级，任意级别（0、1、2、 3）特权的程序都可以访问该页。若为 0，表示处于 Supervisor 级，特权级别为 3 的程序不允许访问该页，该页只允许特权级别为 0、1、2 的程序可以访问。</p>
</blockquote>
<blockquote>
<p>PWT，Page-level Write-Through，意为页级通写位，也称页级写透位。若为 1 表示此项采用通写方式，表示该页不仅是普通内存，还是高速缓存。此项和高速缓存有关，“通写”是高速缓存的一种工作方式，本位用来间接决定是否用此方式改善该页的访问效率。这里咱们直接置为 0 就可以啦。</p>
</blockquote>
<blockquote>
<p>PCD，Page-level Cache Disable，意为页级高速缓存禁止位。若为 1 表示该页启用高速缓存，为 0 表示禁止将该页缓存。这里咱们将其置为 0。 A，Accessed，意为访问位。若为 1 表示该页被 CPU 访问过啦，所以该位是由 CPU 设置的。还记得段描述符中的 A 位和 P 位吗？这两位在一起可以实现段式虚拟内存管理。和它们一样，这里页目录项和页表项中的 A 位也可以用来记录某一内存页的使用频率（操作系统定期将该位清 0，统计一段时间内变成 1 的次数），从而当内存不足时，可以将使用频率较低的页面换出到外存（如硬盘），同时将页目录项或页表项的 P位置 0，下次访问该页引起 pagefault 异常时，中断处理程序将硬盘上的页再次换入，同时将 P 位置 1。 D，Dirty，意为脏页位。当 CPU 对一个页面执行写操作时，就会设置对应页表项的 D 位为 1。此项仅针对页表项有效，并不会修改页目录项中的 D 位。</p>
</blockquote>
<blockquote>
<p>PAT，Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。比较复杂，将此位置 0 即可。</p>
</blockquote>
<blockquote>
<p>G,Global，意为全局位。由于内存地址转换也是颇费周折，先得拆分虚拟地址，然后又要查页目录，又要查页表的，所以为了提高获取物理地址的速度，将虚拟地址与物理地址转换结果存储在 TLB（Translation Lookaside Buffer）中，TLB 以后咱们会细说。在此先知道 TLB 是用来缓存地址转换结果的高速缓存就 ok 啦。此 G 位用来指定该页是否为全局页，为 1 表示是全局页，为 0 表示不是全局页。若为全局页，该页将在高速缓存 TLB 中一直保存，给出虚拟地址直接就出物理地址啦，无需那三步骤转换。由于 TLB 容量比较小（一般速度较快的存储设备容量都比较小），所以这里面就存放使用频率较高的页面。顺便说一句，清空 TLB 有两种方式，一是用 invlpg 指令针对单独虚拟地址条目清理，或者是重新加载 cr3 寄存器，这将直接清空 TLB。</p>
</blockquote>
<blockquote>
<p>AVL，意为 Available 位，表示可用，谁可以用？当然是软件，操作系统可用该位，CPU 不理会该位<br>的值，那咱们也不理会吧。</p>
</blockquote>
<h6 id="开启分页"><a href="#开启分页" class="headerlink" title="开启分页"></a>开启分页</h6><p>开启分页需要顺序做以下三件事情。</p>
<ol>
<li>准备好页目录表和页表。</li>
<li>将页表地址写入控制寄存器cr3。</li>
<li>寄存器的PG位置1.</li>
</ol>
<h4 id="elf-executable-and-linkable-format"><a href="#elf-executable-and-linkable-format" class="headerlink" title="elf (executable and linkable format)"></a>elf (executable and linkable format)</h4><h6 id="elf中的数据类型"><a href="#elf中的数据类型" class="headerlink" title="elf中的数据类型"></a>elf中的数据类型</h6><table>
<thead>
<tr>
<th>数据类型名称</th>
<th>字节大小</th>
<th>对齐</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>Elf_Half</td>
<td>2</td>
<td>2</td>
<td>无符号中等大小的整数</td>
</tr>
<tr>
<td>Elf_Word</td>
<td>4</td>
<td>4</td>
<td>无符号大整数</td>
</tr>
<tr>
<td>Elf_Addr</td>
<td>4</td>
<td>4</td>
<td>无符号程序运行地址</td>
</tr>
<tr>
<td>Elf_Off</td>
<td>4</td>
<td>4</td>
<td>无符号文件偏移量</td>
</tr>
</tbody></table>
<h4 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h4><blockquote>
<p>RPL:请求特权级指令请求访问其他资源的能力成为请求特权级，指令存放在代码段中，所所以使用CS中选择子的RPL位表示代码请求别人资源的能力。    </p>
</blockquote>
<blockquote>
<p>CPL：表示处理器当亲的特权级。指令最终是由处理器执行的，执行到不同特权的代码，处理器的特权级就切换到不同的等级。代码段描述符中的DPL便是当前处理器所处的特权级。    </p>
</blockquote>
<blockquote>
<p>对于数据段来讲，只有访问者的权限大于或等于段描述符中的DPL表示的最低权限时才能够访问。</p>
</blockquote>
<blockquote>
<p>对于代码段来讲，只有访问者的权限<strong>等于</strong>段描述符中的DPL才能访问。即只能平级访问。访问一个代码段实质上就是跳转到这个段进行执行。唯一一种处理器从高特权级降到低特权级执行的情况是处理器从中断处理程序中返回到用户态。</p>
</blockquote>
<blockquote>
<p>一致性代码段：一致性代码段也成为依从代码段，用来实现从低特权级的代码向高特权级代码的转移。一致性代码段是指如果自己是转移后的目标段，则自己的特权级一定能要大于等于转移前的CPL，也就是说一致性代码段的DPL是特权的上限。处理器遇到目标端位一致性代码段的时候并不会将CPL用该段的DPL来替换。代码段可以有一致性与不一致性的段，但是数据段只能有非一致性，即数据段不允许比自己特权级低的代码段访问。</p>
</blockquote>
<h4 id="函数调约定"><a href="#函数调约定" class="headerlink" title="函数调约定"></a>函数调约定</h4><h6 id="cdecl-c-declaration-即c声明"><a href="#cdecl-c-declaration-即c声明" class="headerlink" title="cdecl (c declaration 即c声明)"></a>cdecl (c declaration 即c声明)</h6><p>函数参数从右到左顺序入栈，EAX,ECX,EDX,寄存器由<strong>调用者</strong>保存，其余的寄存器由<strong>被调用者</strong>保存。函数的返回值存储在EAX寄存器中。由<strong>调用者</strong>清理栈空间。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int subtract(int a, int b); &#x2F;&#x2F;被调用者</span><br><span class="line">int sub &#x3D; subtract (3,2); &#x2F;&#x2F; 主调用者</span><br><span class="line">主调用者：</span><br><span class="line">; 从右到左将参数入栈</span><br><span class="line">push 2 ;压入参数 b </span><br><span class="line">push 3 ;压入参数 a </span><br><span class="line">call subtract ;调用函数 subtract </span><br><span class="line">add esp, 8 ;回收（清理）栈空间</span><br><span class="line">被调用者：</span><br><span class="line">push ebp ;压入 ebp 备份</span><br><span class="line">mov ebp,esp ;将 esp 赋值给 ebp </span><br><span class="line"> ;用 ebp 作为基址来访问栈中参数</span><br><span class="line">mov eax,[ebp+0x8] ;偏移 8 字节处为第 1 个参数 a </span><br><span class="line">add eax,[ebp+0xc] ;偏移 0xc 字节处是第 2 个参数 b </span><br><span class="line"> ;参数 a 和 b 相加后存入 eax </span><br><span class="line">mov esp,ebp ;为防止中间有入栈操作，用 ebp 恢复 esp </span><br><span class="line"> ;本句在此例子中可有可无,属于通用代码</span><br><span class="line">pop ebp ;将 ebp 恢复</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>


<h4 id="C与汇编混合编程"><a href="#C与汇编混合编程" class="headerlink" title="C与汇编混合编程"></a>C与汇编混合编程</h4><p>c语言和汇编语言混合编程分为两种：</p>
<ol>
<li>单独的汇编代码文件与单独的c语言文件分别编译成目标文件后，再进行连接成可执行程序。</li>
<li>再c语言中嵌入汇编语言，直接编译成生可执行程序。这种也叫做内联汇编。</li>
</ol>
<h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><h6 id="基本内联汇编"><a href="#基本内联汇编" class="headerlink" title="基本内联汇编"></a>基本内联汇编</h6><p>格式：<br>asm [volatile](“asm code”)       </p>
<ol>
<li>指令必须要用双引号括起来</li>
<li>一对双引号不可以跨行，如果跨行需要在结尾使用’\‘转义。</li>
<li>指令之间使用’;’,’\n’,’\t’分隔开。</li>
<li>即使指令分隔在多个双引号中也要使用分隔符。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> char* str&#x3D;&quot;hello,world\n&quot;; </span><br><span class="line"> int count &#x3D; 0; </span><br><span class="line"> void main()&#123; </span><br><span class="line"> asm(&quot;pusha; \ </span><br><span class="line"> movl $4,%eax; \ </span><br><span class="line"> movl $1,%ebx; \ </span><br><span class="line"> movl str,%ecx; \ </span><br><span class="line"> movl $12,%edx; \ </span><br><span class="line"> int $0x80; \ </span><br><span class="line">mov %eax,count;\ </span><br><span class="line">popa \ </span><br><span class="line">&quot;); </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h6 id="扩展内联汇编"><a href="#扩展内联汇编" class="headerlink" title="扩展内联汇编"></a>扩展内联汇编</h6><p>格式：<br>asm [volatile] (“assembly code”:output : input : clobber/modify)</p>
<ol>
<li><p>assembly code：还是用户写入的汇编指令，和基本内联汇编一样。</p>
</li>
<li><p>output:output 用来指定汇编代码的数据如何输出给 C 代码使用。内嵌的汇编指令运行结束后，如果想将运行结果存储到 c 变量中，就用此项指定输出的位置。</p>
</li>
<li><p>input：input 用来指定 C 中数据如何输入给汇编使用。要想让汇编使用 C 中的变量作为参数，就要在此指定。</p>
</li>
<li><p>clobber/modify：汇编代码执行后会破坏一些内存或寄存器资源，通过此项通知编译器，可能造成寄<br>存器或内存数据的破坏，这样 gcc 就知道哪些寄存器或内存需要提前保护起来。</p>
</li>
</ol>
<p><strong>约束</strong></p>
<ol>
<li>寄存器约束  </li>
</ol>
<p>寄存器约束就是要求 gcc 使用哪个寄存器，将 input 或 output 中变量约束在某个寄存器中。常见的寄存器约束有：<br>a：表示寄存器 eax/ax/al<br>b：表示寄存器 ebx/bx/bl<br>c：表示寄存器 ecx/cx/cl<br>d：表示寄存器 edx/dx/dl<br>D：表示寄存器 edi/di<br>S：表示寄存器 esi/si<br>q：表示任意这 4 个通用寄存器之一：eax/ebx/ecx/edx<br>r：表示任意这 6 个通用寄存器之一：eax/ebx/ecx/edx/esi/edi<br>g：表示可以存放到任意地点（寄存器和内存）。相当于除了同 q 一样外，还可以让 gcc 安排在内存中<br>A：把 eax 和 edx 组合成 64 位整数<br>f：表示浮点寄存器<br>t：表示第 1 个浮点寄存器<br>u：表示第 2 个浮点寄存器      </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">void main() &#123; </span><br><span class="line">int in_a &#x3D; 1, in_b &#x3D; 2, out_sum; </span><br><span class="line">asm(&quot;addl %%ebx, %%eax&quot;:&quot;&#x3D;a&quot;(out_sum):&quot;a&quot;(in_a),&quot;b&quot;(in_b)); </span><br><span class="line">printf(&quot;sum is %d\n&quot;,out_sum); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>内存约束</li>
</ol>
<p>内存约束是要求 gcc 直接将位于 input 和 output 中的 C 变量的内存地址作为内联汇编代码的操作数，不需要寄存器做中转，直接进行内存读写，也就是汇编代码的操作数是 C 变量的指针。    </p>
<p>m：表示操作数可以使用任意一种内存形式。<br>o：操作数为内存变量，但访问它是通过偏移量的形式访问，即包含 offset_address 的格式。       </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">void main() &#123; </span><br><span class="line">int in_a &#x3D; 1, in_b &#x3D; 2; </span><br><span class="line">printf(&quot;in_b is %d\n&quot;, in_b); </span><br><span class="line">asm(&quot;movb %b0, %1;&quot;::&quot;a&quot;(in_a),&quot;m&quot;(in_b)); </span><br><span class="line">printf(&quot;in_b now is %d\n&quot;, in_b); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>立即数约束</li>
</ol>
<p>i：表示操作数为整数立即数<br>F：表示操作数为浮点数立即数<br>I：表示操作数为 0～31 之间的立即数<br>J：表示操作数为 0～63 之间的立即数<br>N：表示操作数为 0～255 之间的立即数<br>O：表示操作数为 0～32 之间的立即数<br>X：表示操作数为任何类型立即数    </p>
<ol start="4">
<li>通用约束</li>
</ol>
<p>0～9：此约束只用在 input 部分，但表示可与 output 和 input 中第 n 个操作数用相同的寄存器或内存。</p>
<h4 id="AT-amp-T汇编"><a href="#AT-amp-T汇编" class="headerlink" title="AT&amp;T汇编"></a>AT&amp;T汇编</h4><p>intel 与 AT&amp;T 语法风格对比</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>intel</th>
<th>AT&amp;T</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>寄存器没有钱追你</td>
<td>寄存器有前缀%</td>
<td></td>
</tr>
<tr>
<td>操作数顺序</td>
<td>目的操作数在左边，源操作数在右边</td>
<td>相反</td>
<td></td>
</tr>
<tr>
<td>操作数指定大小</td>
<td>有关内存的操作数要加数据类型指定大小，byte：8位，word:16位，dword:32位</td>
<td>指令的最后一个字母代表指令操作数大小，b:8位，w:16位，l:32位。</td>
<td></td>
</tr>
<tr>
<td>立即数</td>
<td>没有前缀</td>
<td>有前缀$</td>
<td></td>
</tr>
<tr>
<td>远跳转</td>
<td>jmp far segment:offset</td>
<td>ljmp $segment:$offset</td>
<td></td>
</tr>
<tr>
<td>远调用</td>
<td>call far segment:offset</td>
<td>lcall $segment:$offset</td>
<td></td>
</tr>
<tr>
<td>远返回</td>
<td>ret far n</td>
<td>lret $n</td>
<td></td>
</tr>
</tbody></table>
<p>内存寻址格式：<br>segreg(段基址):base_address(offset,index,size)        </p>
<p>segreg:base_address+offset+index*size</p>
<h4 id="打印-printf-的实现"><a href="#打印-printf-的实现" class="headerlink" title="打印 printf 的实现"></a>打印 printf 的实现</h4><h6 id="打印字符"><a href="#打印字符" class="headerlink" title="打印字符"></a>打印字符</h6><p>在printf.h中声明函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void put_char(uint8_t char_asci)</span><br></pre></td></tr></table></figure>

<p>在print.s中完成函数的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global put_char</span><br><span class="line">;外部符号声明 </span><br><span class="line">pushad   ;备份8个32位寄存器</span><br><span class="line">mov ax,SELECTOR_VIDEO</span><br><span class="line">mov gs,ax</span><br><span class="line"></span><br><span class="line">;获取光标位置</span><br><span class="line">;高8位</span><br><span class="line">mov dx,0x03d4  ;索引寄存器</span><br><span class="line">mov al,0x0e    ;光标位置高8位</span><br><span class="line">out dx,al      </span><br><span class="line">mov dx,0x03d5     </span><br><span class="line">in al,dx</span><br><span class="line">mov ah,al</span><br><span class="line">;低8位</span><br><span class="line">mov dx,0x03d4  ;索引寄存器</span><br><span class="line">mov al,0x0f   ;光标位置高8位</span><br><span class="line">out dx,al      </span><br><span class="line">mov dx,0x03d5     </span><br><span class="line">in al,dx</span><br><span class="line"></span><br><span class="line">;光标为值存放在bx中</span><br><span class="line">mov ax,bx</span><br><span class="line">;取得要打印的字符</span><br><span class="line">mov ecx,[esp+36]</span><br><span class="line">cmp cl,0xd</span><br><span class="line">jz .is_carriage_return</span><br><span class="line">cmp cl,0xa</span><br><span class="line">jz .is_line_feed</span><br><span class="line">cmp cl,0x8</span><br><span class="line">jz .is_backspace</span><br><span class="line">jmp .put_other</span><br><span class="line"></span><br><span class="line">.is_backspace:</span><br><span class="line">dec bx   ;光标位置减一</span><br><span class="line">shl bx,1    ;左移一位，bx乘二得到光标处字符所在为内存地址。</span><br><span class="line">mov word [gs:bx],0   ;将这一个字符为位置清零包括颜色属性</span><br><span class="line">shr bx,1    ;bx恢复原状</span><br><span class="line">jmp .set_cursor</span><br><span class="line"></span><br><span class="line">.put_other:</span><br><span class="line">shl bx,1</span><br><span class="line">mov [gs:bx],cl</span><br><span class="line">inc bx</span><br><span class="line">mov byte [gs:bx],0x07</span><br><span class="line">shr bx,1</span><br><span class="line">inc bx</span><br><span class="line">;若光标值小于2000，则表示该页现存没有写完，若超出2000，则回车换行处理</span><br><span class="line">cmp bx,2000</span><br><span class="line">jl .set_cursor</span><br><span class="line"></span><br><span class="line">.is_line_feed:</span><br><span class="line">.is_carriage_return:</span><br><span class="line">xor dx,dx</span><br><span class="line">mov ax,bx</span><br><span class="line">mov si,80</span><br><span class="line">div si</span><br><span class="line">sub bx,dx</span><br><span class="line">;先让光标回到行首再下一行，判断是否超出。</span><br><span class="line">.is_carriage_return_end:</span><br><span class="line">add bx,80</span><br><span class="line">cmp bx,2000</span><br><span class="line">.is_line_feed_end:</span><br><span class="line">jl .set_cursor</span><br><span class="line"></span><br><span class="line">;超出屏幕大小开始滚屏</span><br><span class="line">.roll_screen:</span><br><span class="line">cld</span><br><span class="line">mov ecx,960 ;共搬运 2000-80&#x3D;1920个字符</span><br><span class="line">mov esi,0xb80a0   ;第一行行首</span><br><span class="line">mov edi,0xb8000   ;第零行行首</span><br><span class="line">rep movsd</span><br><span class="line">;将最后一行填充为空白</span><br><span class="line">mov ebx,3840</span><br><span class="line">mov ecx,80</span><br><span class="line">.cls:</span><br><span class="line">mov word [gs:ebx],0</span><br><span class="line">add ebx,2</span><br><span class="line">loop .cls</span><br><span class="line">mov bx,1920</span><br><span class="line"></span><br><span class="line">;设置光标值</span><br><span class="line">.set_cursor:</span><br><span class="line">;将光标设为bx值</span><br><span class="line">   mov dx, 0x03d4			  ;索引寄存器</span><br><span class="line">   mov al, 0x0e				  ;用于提供光标位置的高8位</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5			  ;通过读写数据端口0x3d5来获得或设置光标位置 </span><br><span class="line">   mov al, bh</span><br><span class="line">   out dx, al</span><br><span class="line"></span><br><span class="line">   mov dx, 0x03d4</span><br><span class="line">   mov al, 0x0f</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5 </span><br><span class="line">   mov al, bl</span><br><span class="line">   out dx, al</span><br><span class="line"></span><br><span class="line">.put_char_done:</span><br><span class="line">   popad</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>

<h6 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h6><p>在printf.h中声明函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void put_str(char* message)</span><br></pre></td></tr></table></figure>

<p>在print.s中完成函数的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global put_str</span><br><span class="line">put_str:</span><br><span class="line">;由于本函数中只用到了ebx和ecx,只备份这两个寄存器</span><br><span class="line">   push ebx</span><br><span class="line">   push ecx</span><br><span class="line">   xor ecx, ecx		      ; 准备用ecx存储参数,清空</span><br><span class="line">   mov ebx, [esp + 12]	      ; 从栈中得到待打印的字符串地址 </span><br><span class="line">.goon:</span><br><span class="line">   mov cl, [ebx]</span><br><span class="line">   cmp cl, 0		      ; 如果处理到了字符串尾,跳到结束处返回</span><br><span class="line">   jz .str_over</span><br><span class="line">   push ecx		      ; 为put_char函数传递参数</span><br><span class="line">   call put_char</span><br><span class="line">   add esp, 4		      ; 回收参数所占的栈空间</span><br><span class="line">                        ;由调用者回收栈空间，C语言调用的话编译器会自动完成但是汇编语言不会，需要我们手动回收。</span><br><span class="line">   inc ebx		      ; 使ebx指向下一个字符</span><br><span class="line">   jmp .goon</span><br><span class="line">.str_over:</span><br><span class="line">   pop ecx</span><br><span class="line">   pop ebx</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>

<h6 id="打印整数"><a href="#打印整数" class="headerlink" title="打印整数"></a>打印整数</h6><p>在printf.h中声明函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void put_int(uint32_t num);</span><br></pre></td></tr></table></figure>

<p>在print.s中完成函数的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global put_int</span><br><span class="line">put_int:</span><br><span class="line">pushad</span><br><span class="line">mov ebp,esp</span><br><span class="line">mov eax,[ebp+36]</span><br><span class="line">mov edx,eax</span><br><span class="line">mov edi,7</span><br><span class="line">mov ecx,8   ;32位数字共分为8块</span><br><span class="line">mov ebx,put_int_buffer</span><br><span class="line"></span><br><span class="line">.16based_4bits:</span><br><span class="line">and edx,0x0000000F</span><br><span class="line">cmp,9</span><br><span class="line">jg .isA2F</span><br><span class="line">add edx,&#39;0&#39;</span><br><span class="line">jmp .store</span><br><span class="line">.is_A2F:</span><br><span class="line">sub edx,10</span><br><span class="line">add edx,&#39;A&#39;</span><br><span class="line">;从大往小存储在缓冲区内，最后一个数字放在最高位</span><br><span class="line">.store:</span><br><span class="line">mov [ebx+edi],dl</span><br><span class="line">dec edi</span><br><span class="line">shr eax,4</span><br><span class="line">mov edx,4</span><br><span class="line">loop .16based_4bits</span><br><span class="line"></span><br><span class="line">.ready_to_print:</span><br><span class="line">inc edi</span><br><span class="line">.skip_prefix_0    ;判断是不是8位全零</span><br><span class="line">cmp edi,8</span><br><span class="line">je .full0</span><br><span class="line">.go_on_skip:</span><br><span class="line">mov cl,[put_int_buffer+edi]</span><br><span class="line">inc edi</span><br><span class="line">cmp cl,&#39;0&#39;</span><br><span class="line">je .skip_prefix_0</span><br><span class="line">dec edi</span><br><span class="line">jmp .put_each_num</span><br><span class="line"></span><br><span class="line">.full0:</span><br><span class="line">mov cl,&#39;0&#39;</span><br><span class="line">.put_each_num:</span><br><span class="line">push ecx</span><br><span class="line">call put_char</span><br><span class="line">add esp,4</span><br><span class="line">inc edi</span><br><span class="line">mov cl,[put_int_buffer+edi]</span><br><span class="line">cmp edi,8</span><br><span class="line">jl .put_each_num</span><br><span class="line">popad</span><br><span class="line">ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h4 id="杂项问题"><a href="#杂项问题" class="headerlink" title="杂项问题"></a>杂项问题</h4><ol>
<li>对于push指令，处于对齐的要求，操作数要么是16位要么是32位，所以8位操作数会被扩展为运行模式下的默认操作数宽度。实模式为16位，保护模式为32位。</li>
<li>使用伪指令 [bits 16] [bits 32] 指定编译器进行模式指定。 </li>
<li>操作数反转前缀 0x66 寻址方式反转前缀 0x67</li>
</ol>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>nasm 使用</title>
    <url>/2021/05/20/nasm-%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="nasm-使用"><a href="#nasm-使用" class="headerlink" title="nasm 使用"></a>nasm 使用</h1><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><ol>
<li>汇编一个文件<blockquote>
<p>nasm -f <format> <filename> [-o <output>]<br>nasm -f elf my.asm # 把文件’my.asm’汇编成’ELF’格式 的文件’my.o’.<br>nasm -f bin my.asm -o my.bin # 把文件’my.asm’汇编成纯二进制格式的文件’my.bin’。<br>nasm -I include/ my.asm -o my.bin #添加库目录</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>使用</tag>
        <tag>nasm</tag>
      </tags>
  </entry>
  <entry>
    <title>os 002 os start</title>
    <url>/2021/05/11/os-002-os-start/</url>
    <content><![CDATA[<h1 id="os-002-os-start"><a href="#os-002-os-start" class="headerlink" title="os 002 os start"></a>os 002 os start</h1><h4 id="实模式下的1M内存布局"><a href="#实模式下的1M内存布局" class="headerlink" title="实模式下的1M内存布局"></a>实模式下的1M内存布局</h4><table>
<thead>
<tr>
<th>起始</th>
<th>结束</th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>FFFF0</td>
<td>FFFFF</td>
<td>16B</td>
<td>BIOS入口地址，此16字节的指令是jmp f000:e05b</td>
</tr>
<tr>
<td>F0000</td>
<td>FFFEF</td>
<td>64KB-16B</td>
<td>BIOS的范围是F0000~FFFFF共640KB</td>
</tr>
<tr>
<td>C8000</td>
<td>EFFFF</td>
<td>160KB</td>
<td>映射硬件适配器的ROM或者内存映射式IO</td>
</tr>
<tr>
<td>C0000</td>
<td>C7FFF</td>
<td>32KB</td>
<td>显示适配器BIOS</td>
</tr>
<tr>
<td>B8000</td>
<td>BFFFF</td>
<td>32KB</td>
<td>用于文本模式的显示适配器</td>
</tr>
<tr>
<td>B0000</td>
<td>B7FFF</td>
<td>32KB</td>
<td>用于黑白显示适配器</td>
</tr>
<tr>
<td>A0000</td>
<td>AFFFF</td>
<td>64KB</td>
<td>用于彩色显示适配器</td>
</tr>
<tr>
<td>9FC00</td>
<td>9FFFF</td>
<td>1KB</td>
<td>扩展BIOS数据区</td>
</tr>
<tr>
<td>7E00</td>
<td>9FBFF</td>
<td>608KB</td>
<td>可用区域</td>
</tr>
<tr>
<td>7C00</td>
<td>7DFF</td>
<td>512B</td>
<td>MBR被加载到此处，共512字节</td>
</tr>
<tr>
<td>500</td>
<td>7BFF</td>
<td>30KB</td>
<td>可用区域</td>
</tr>
<tr>
<td>400</td>
<td>4FF</td>
<td>256B</td>
<td>BIOS数据区</td>
</tr>
<tr>
<td>0</td>
<td>3FF</td>
<td>1KB</td>
<td>中断向量表IVT</td>
</tr>
</tbody></table>
<h4 id="计算机的启动过程"><a href="#计算机的启动过程" class="headerlink" title="计算机的启动过程"></a>计算机的启动过程</h4><ol>
<li>按下开机键，cs:ip被初始化为F000:FFF0，指向BIOS入口地址。</li>
<li>BIOS被加载进ROM并被映射到1MB内存的顶部（见上表）。</li>
<li>jmp f000:e05b,执行BIOS的工作。</li>
<li>BIOS的最后一项工作是校验启动盘中位于0盘0道1扇区的内容，若最后两个字节分别为0x55与0xaa，（即最后一个字的内容为0xaa55(小端字节序)）,则认为这是一个MBR程序（主引导记录），则将此512字节加载如内存0x7C00. BIOS跳转，jmp 0:7C00</li>
<li>执行MBR。</li>
<li>MBR，加载boot loader</li>
<li>boot loader加载os 内核。</li>
<li>内核执行</li>
</ol>
<h4 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h4><ol>
<li>BIOS本身是一个程序。BIOS的工作：检测硬件，做各种初始化工作，建立中断向量表，加载MBR。</li>
<li>BIOS中断只能用于实模式，在保护模式下不可以使用。</li>
</ol>
<h4 id="硬盘操作"><a href="#硬盘操作" class="headerlink" title="硬盘操作"></a>硬盘操作</h4><h6 id="硬盘控制器主要端口寄存器"><a href="#硬盘控制器主要端口寄存器" class="headerlink" title="硬盘控制器主要端口寄存器"></a>硬盘控制器主要端口寄存器</h6><table>
<thead>
<tr>
<th>IO端口</th>
<th></th>
<th>端口用途</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>primary通道</td>
<td>secondary通道</td>
<td>读</td>
<td>写</td>
</tr>
<tr>
<td>指令寄存器</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x1F0</td>
<td>0x170</td>
<td>data</td>
<td>data</td>
</tr>
<tr>
<td>0x1F1</td>
<td>0x171</td>
<td>data</td>
<td>features</td>
</tr>
<tr>
<td>0x1F2</td>
<td>0x172</td>
<td>扇区数量</td>
<td>扇区数量</td>
</tr>
<tr>
<td>0x1F3</td>
<td>0x173</td>
<td>LBA LOW</td>
<td>LBA LOW</td>
</tr>
<tr>
<td>0x1F4</td>
<td>0x174</td>
<td>LBA MID</td>
<td>LBA MID</td>
</tr>
<tr>
<td>0x1F5</td>
<td>0x175</td>
<td>LBA HIGH</td>
<td>LBA HIGH</td>
</tr>
<tr>
<td>0x1F6</td>
<td>0x176</td>
<td>device</td>
<td>device</td>
</tr>
<tr>
<td>0x1F7</td>
<td>0x177</td>
<td>status</td>
<td>command</td>
</tr>
<tr>
<td>控制寄存器</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x3F6</td>
<td>0x376</td>
<td>alternate status</td>
<td>device control</td>
</tr>
</tbody></table>
<blockquote>
<p>Sector count 寄存器用来指定待读取或待写入的扇区数。硬盘每完成一个扇区，就会将此寄存器的值<br>减 1，所以如果中间失败了，此寄存器中的值便是尚未完成的扇区。这是 8 位寄存器，最大值为 255，若<br>指定为 0，则表示要操作 256 个扇区。      </p>
</blockquote>
<blockquote>
<p>在读硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 Status，它是 8 位宽度的寄存器，用来给出硬盘的<br>状态信息。第 0 位是 ERR 位，如果此位为 1，表示命令出错了，具体原因可见 error 寄存器。第 3 位是 data<br>request 位，如果此位为 1，表示硬盘已经把数据准备好了，主机现在可以把数据读出来。第 6 位是 DRDY，<br>表示硬盘就绪，此位是在对硬盘诊断时用的，表示硬盘检测正常，可以继续执行一些命令。第 7 位是 BSY<br>位，表示硬盘是否繁忙，如果为 1 表示硬盘正忙着，此寄存器中的其他位都无效。另外的 4 位暂不关注。      </p>
</blockquote>
<blockquote>
<p>在写硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 command，和上面说过的 error 和 feature 寄存器情况<br>一样，只是用途变了，所以换了个名字表示新的用途，它和 status 寄存器是同一个。此寄存器用来存储让硬<br>盘执行的命令，只要把命令写进此寄存器，硬盘就开始工作了。主要使用了三个命令。<br>（1）identify：0xEC，即硬盘识别。<br>（2）read sector：0x20，即读扇区。<br>（3）write sector：0x30，即写扇区。   </p>
</blockquote>
<h6 id="硬盘读取步骤"><a href="#硬盘读取步骤" class="headerlink" title="硬盘读取步骤"></a>硬盘读取步骤</h6><blockquote>
<p>（1）先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数。<br>（2）往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。<br>（3）往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第4位，选择操作的硬盘（master 硬盘或 slave 硬盘）。<br>（4）往该通道上的 command 寄存器写入操作命令。<br>（5）读取该通道上的 status 寄存器，判断硬盘工作是否完成。<br>（6）如果以上步骤是读硬盘，进入下一个步骤。否则，完工。<br>（7）将硬盘数据读出。        </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;功能:读取硬盘n个扇区</span><br><span class="line">rd_disk_m_16:	   </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">; eax&#x3D;LBA扇区号</span><br><span class="line">; ebx&#x3D;将数据写入的内存地址</span><br><span class="line">; ecx&#x3D;读入的扇区数</span><br><span class="line">      mov esi,eax	  ;备份eax</span><br><span class="line">      mov di,cx		  ;备份cx</span><br><span class="line">;读写硬盘:</span><br><span class="line">;第1步：设置要读取的扇区数</span><br><span class="line">      mov dx,0x1f2</span><br><span class="line">      mov al,cl</span><br><span class="line">      out dx,al            ;读取的扇区数</span><br><span class="line"></span><br><span class="line">      mov eax,esi	   ;恢复ax</span><br><span class="line"></span><br><span class="line">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span><br><span class="line"></span><br><span class="line">      ;LBA地址7~0位写入端口0x1f3</span><br><span class="line">      mov dx,0x1f3                       </span><br><span class="line">      out dx,al                          </span><br><span class="line"></span><br><span class="line">      ;LBA地址15~8位写入端口0x1f4</span><br><span class="line">      mov cl,8</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f4</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      ;LBA地址23~16位写入端口0x1f5</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f5</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      shr eax,cl</span><br><span class="line">      and al,0x0f	   ;lba第24~27位</span><br><span class="line">      or al,0xe0	   ; 设置7～4位为1110,表示lba模式</span><br><span class="line">      mov dx,0x1f6</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第3步：向0x1f7端口写入读命令，0x20 </span><br><span class="line">      mov dx,0x1f7</span><br><span class="line">      mov al,0x20                        </span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第4步：检测硬盘状态</span><br><span class="line">  .not_ready:</span><br><span class="line">      ;同一端口，写时表示写入命令字，读时表示读入硬盘状态</span><br><span class="line">      nop</span><br><span class="line">      in al,dx</span><br><span class="line">      and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙</span><br><span class="line">      cmp al,0x08</span><br><span class="line">      jnz .not_ready	   ;若未准备好，继续等。</span><br><span class="line"></span><br><span class="line">;第5步：从0x1f0端口读数据</span><br><span class="line">      mov ax, di</span><br><span class="line">      mov dx, 256</span><br><span class="line">      mul dx</span><br><span class="line">      mov cx, ax	   ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，</span><br><span class="line">			   ; 共需di*512&#x2F;2次，所以di*256</span><br><span class="line">      mov dx, 0x1f0</span><br><span class="line">  .go_on_read:</span><br><span class="line">      in ax,dx</span><br><span class="line">      mov [bx],ax</span><br><span class="line">      add bx,2		  </span><br><span class="line">      loop .go_on_read</span><br><span class="line">      ret</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>os 004 中断</title>
    <url>/2021/05/25/os-004-%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h1 id="os-004-中断"><a href="#os-004-中断" class="headerlink" title="os 004 中断"></a>os 004 中断</h1><h4 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h4><h6 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h6><p>外部中断是来自CPU外部的中断，外部中断源又必须是硬件，所以外部中断又称为硬件中断。       </p>
<ol>
<li><p><strong>可屏蔽中断</strong><br>通过intr引脚进入CPU，可屏蔽中断可以通过EFLAGS的IF位屏蔽掉。</p>
</li>
<li><p><strong>不可屏蔽中断</strong><br>通过NMI引脚进入CPU，不可屏蔽中断不可以通过EFLAGS的IF位屏蔽掉。</p>
</li>
</ol>
<h6 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h6><p>内部中断可分为软中断和异常。        </p>
<ol>
<li><p><strong>软中断</strong><br>由软件主动发起的中断。不受IF位影响。        </p>
</li>
<li><p><strong>异常</strong><br>异常分为以下三种：      </p>
<ol>
<li>FAULT 故障，比如缺页异常。       </li>
<li>TRAP 陷阱       </li>
<li>ABORT 终止</li>
</ol>
</li>
</ol>
<p>IF位只能屏蔽外部设备的中断。    </p>
<table>
<thead>
<tr>
<th>指令</th>
<th>IF</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cli</td>
<td>IF=0</td>
<td>关中断</td>
</tr>
<tr>
<td>sti</td>
<td>IF=1</td>
<td>开中断</td>
</tr>
</tbody></table>
<h4 id="中断描述符表-IDT"><a href="#中断描述符表-IDT" class="headerlink" title="中断描述符表 IDT"></a>中断描述符表 IDT</h4><p>中断描述符表是保护模式下用于存储中断处理程序入口的表，当CPU接受一个中断时，使用中断向量在这个表中检索相应的中断描述符，继而找到中断处理程序的入口地址，执行中断处理程序。       </p>
<p>中断描述符表中可以存储中断描述符、任务们描述符、陷阱们描述符。所以中断描述符又称为<strong>门</strong>。  </p>
<p>门都属于系统段，所以其描述符中的S字段全为0.     </p>
<p><strong>四种门描述符中type字段(D=0代表16位，D=32代表32位)</strong>       </p>
<table>
<thead>
<tr>
<th>任务门</th>
<th>终端门</th>
<th>陷阱门</th>
<th>调用门</th>
</tr>
</thead>
<tbody><tr>
<td>0101</td>
<td>D110</td>
<td>D111</td>
<td>D100</td>
</tr>
</tbody></table>
<p><strong>当代操作系统很少使用任务门和调用门</strong>      </p>
<h6 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h6><p>任务门和任务状态段（TSS）时Intel处理器在硬件一级上提供的任务切换机制。当代大多数操作系统都没有使用TSS实现任务的切换。</p>
<h6 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h6><p><strong>中断门描述符</strong></p>
<table>
<thead>
<tr>
<th>位</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>高32位</td>
<td></td>
</tr>
<tr>
<td>31-16</td>
<td>中断处理程序在目标段内的偏移量的31-16位</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
</tr>
<tr>
<td>14-13</td>
<td>DPL</td>
</tr>
<tr>
<td>12</td>
<td>S=0</td>
</tr>
<tr>
<td>11-8</td>
<td>TYPE=D110</td>
</tr>
<tr>
<td>7-5</td>
<td>0</td>
</tr>
<tr>
<td>4-0</td>
<td>未使用</td>
</tr>
<tr>
<td>低32位</td>
<td></td>
</tr>
<tr>
<td>31-16</td>
<td>中断处理程序目标代码段描述符选择子</td>
</tr>
<tr>
<td>15-0</td>
<td>中断处理程序在目标段内的偏移量的15-0位</td>
</tr>
</tbody></table>
<p>通过中断门进入中断，IF位自动置零，关中断，避免中断嵌套。中断门只存在于IDT中。       </p>
<h6 id="陷阱门"><a href="#陷阱门" class="headerlink" title="陷阱门"></a>陷阱门</h6><p><strong>陷阱门描述符</strong></p>
<table>
<thead>
<tr>
<th>位</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>高32位</td>
<td></td>
</tr>
<tr>
<td>31-16</td>
<td>中断处理程序在目标段内的偏移量的31-16位</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
</tr>
<tr>
<td>14-13</td>
<td>DPL</td>
</tr>
<tr>
<td>12</td>
<td>S=0</td>
</tr>
<tr>
<td>11-8</td>
<td>TYPE=D111</td>
</tr>
<tr>
<td>7-5</td>
<td>0</td>
</tr>
<tr>
<td>4-0</td>
<td>未使用</td>
</tr>
<tr>
<td>低32位</td>
<td></td>
</tr>
<tr>
<td>31-16</td>
<td>中断处理程序目标代码段描述符选择子</td>
</tr>
<tr>
<td>15-0</td>
<td>中断处理程序在目标段内的偏移量的15-0位</td>
</tr>
</tbody></table>
<p>陷阱门与中断门不同的是IF位不会自动置0.</p>
<h6 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h6><p>调用门给用户进程提供进入特权即0的方式，其DPL为3。他不能用于int指令调用，只能用call和jmp指令。调用门可以安装在GDT和LDT中。           </p>
<h6 id="中断描述符表寄存器-IDTR"><a href="#中断描述符表寄存器-IDTR" class="headerlink" title="中断描述符表寄存器 IDTR"></a>中断描述符表寄存器 IDTR</h6><table>
<thead>
<tr>
<th>47-16</th>
<th>15-0</th>
</tr>
</thead>
<tbody><tr>
<td>32位的表基址</td>
<td>16位的表界限</td>
</tr>
</tbody></table>
<p>GDT第零个描述符是不可用的，但是IDT的第零个描述符是可用的。          </p>
<p>lidt[48位内存地址]</p>
<h4 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h4><h6 id="中断的特权级检查"><a href="#中断的特权级检查" class="headerlink" title="中断的特权级检查"></a>中断的特权级检查</h6><p>对于软件主动引发的中断，从特权级上来讲，必须符合下面的条件:<br><strong>门描述符DPL&lt;=CPL&lt;目标代码段的DPL</strong></p>
<p>对于外部设备引发的中断，只需要满足:<br><strong>CPL&lt;目标代码段的DPL</strong></p>
<p>处理器根据中断向量号找到对应的中断描述符后，若CPL比目标代码段DPL低，则需要向高特权转移，需要切换到高特权级的栈。</p>
<p><strong>中断发生，特权级发生变化时的新栈中的内容</strong></p>
<table>
<thead>
<tr>
<th>31-16</th>
<th>15-0</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ss_old</td>
</tr>
<tr>
<td>esp_old</td>
<td>esp_old</td>
</tr>
<tr>
<td>eflags</td>
<td>eflags</td>
</tr>
<tr>
<td>0</td>
<td>cs_old</td>
</tr>
<tr>
<td>eip_old</td>
<td>eip_old</td>
</tr>
<tr>
<td>error_code</td>
<td>error_code</td>
</tr>
</tbody></table>
<p>执行完中断程序之后，使用<strong>iret</strong>进行返回。依次弹出EIP,CS,EFLAGS。所以中断返回前栈顶指针必须指向EIP_old。处理器根据弹出的CS指向的代码段描述符判断出该次中断是否进行了特权级改变，如果进行了特权级改变的话，继续将esp和ss弹出。</p>
<p>如果返回时改变了特权级则将会检查数据段寄存器DS,ES,FS,GS的内容，如果DPL比返回后的CPL高，则处理器会故意将该数据段寄存器的内容改为0，即指向第零个段描述符，从而使得处理器抛出异常。</p>
<h6 id="中断错误码"><a href="#中断错误码" class="headerlink" title="中断错误码"></a>中断错误码</h6><table>
<thead>
<tr>
<th>31-16</th>
<th>15-3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>保留0</td>
<td>选择子高13位索引</td>
<td>TI</td>
<td>IDT</td>
<td>EXT</td>
</tr>
</tbody></table>
<p>TI=0,表示来自GDT,TI=1表示来自LDT。</p>
<p>IDT=1，表示选择子指向IDT。否则表示指向GDT或者LDT。</p>
<p>EXT=1，表示中断源时不可屏蔽中断设备，否则为0.</p>
<h4 id="8259A"><a href="#8259A" class="headerlink" title="8259A"></a>8259A</h4><h6 id="8259A的一些信号的寄存器"><a href="#8259A的一些信号的寄存器" class="headerlink" title="8259A的一些信号的寄存器"></a>8259A的一些信号的寄存器</h6><ol>
<li><p>INT：8259A选出优先级最高的中断请求之后，发送信号给CPU。</p>
</li>
<li><p>INTA：INT acknowledge, 中断响应信号。接收来自CPU的INTA接口的中断响应信号。</p>
</li>
<li><p>IMR：中断屏蔽寄存器，8位，屏蔽某个外设的中断。</p>
</li>
<li><p>IRR：中断请求寄存器，8位，接受IMR过滤后的中断信号并锁存，相当于维护未处理的中断信号请求队列。</p>
</li>
<li><p>PR: 优先级仲裁器。多个中断同时发生的时候找出优先级更高的中断。</p>
</li>
<li><p>ISR： 中断服务寄存器，8位，保存正在被处理的中断服务。</p>
</li>
</ol>
<p>一个8259A由8个IRQ接口，使用8位寄存器中的每一位代表一个IRQ接口。</p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>nonetag</tag>
      </tags>
  </entry>
</search>
