<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>I HAVE A PLAN</title>
    <url>/2021/07/01/I-HAVE-A-PLAN/</url>
    <content><![CDATA[<h1 id="MY-PLANS"><a href="#MY-PLANS" class="headerlink" title="MY PLANS"></a>MY PLANS</h1><p><strong>这篇博客的说明</strong></p>
<p>这篇博客是记录我的所有计划以及idea的地方，以下为比克的章节解释：</p>
<ol>
<li>PLAN num<ol>
<li>digest<br> 计划的描述，计划或者说为一个project，项目。简要说明一下这个project。</li>
<li>timeline<ol>
<li>时间线，用来记录计划的完成情况，每次计划有所进展或者想写有关的事情就可以在对应的timeline区域顺序增加。记得加上时间戳(年月日时分, eg:202107011449)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="PLAN-1-cos"><a href="#PLAN-1-cos" class="headerlink" title="PLAN 1 cos"></a>PLAN 1 cos</h2><h3 id="digest"><a href="#digest" class="headerlink" title="digest"></a>digest</h3><p>写一个操作系统，计划是按照郑刚的那本操作系统真相还原照猫画虎的写出一个操作系统，之后学习更多有关操作系统开发的知识，做出一个有自己特色的操作系统，特色我还没有想好，毕竟现在知识面太窄了，啥都不会。</p>
<h3 id="timeline"><a href="#timeline" class="headerlink" title="timeline"></a>timeline</h3><blockquote>
<p><strong>time: 202107011449</strong> </p>
</blockquote>
<ol>
<li>写一个操作系统，现在写了到了中断部分，不过因为期末考试以及考研的额事情已经耽搁了好长时间，我预计在考研之前可以照猫画虎的写出一个操作系统。</li>
</ol>
<blockquote>
<p><strong>time: 202107011449</strong> (测试用，记得删掉)</p>
</blockquote>
<ol>
<li>写一个操作系统，现在写了到了中断部分，不过因为期末考试以及考研的额事情已经耽搁了好长时间，我预计在考研之前可以照猫画虎的写出一个操作系统。</li>
</ol>
<h2 id="PLAN-2-stackoverflow-cn"><a href="#PLAN-2-stackoverflow-cn" class="headerlink" title="PLAN 2 stackoverflow cn"></a>PLAN 2 stackoverflow cn</h2><h3 id="digest-1"><a href="#digest-1" class="headerlink" title="digest"></a>digest</h3><p>由于国内的计算机环境实在是烂到家了，所以我想做一个像stackoverflow那样的平台来为中国计算机界的进步增添一份力量。话说StackOverflow也被收购了，看来屠龙少年终成恶龙呀。做一个StackOverflow cn</p>
<h3 id="timeline-1"><a href="#timeline-1" class="headerlink" title="timeline"></a>timeline</h3><h2 id="PLAN-3-tiny-http"><a href="#PLAN-3-tiny-http" class="headerlink" title="PLAN 3 tiny http"></a>PLAN 3 tiny http</h2><h3 id="digest-2"><a href="#digest-2" class="headerlink" title="digest"></a>digest</h3><p>学习计算机网络及相关知识，首先学着写一个小的 http 服务器。</p>
<h3 id="timeline-2"><a href="#timeline-2" class="headerlink" title="timeline"></a>timeline</h3><h2 id="PLAN-4-database"><a href="#PLAN-4-database" class="headerlink" title="PLAN 4 database"></a>PLAN 4 database</h2><h3 id="digest-3"><a href="#digest-3" class="headerlink" title="digest"></a>digest</h3><p>学着写一个小的数据库</p>
<h3 id="timeline-3"><a href="#timeline-3" class="headerlink" title="timeline"></a>timeline</h3><blockquote>
<p><strong>time: 202107241520</strong> </p>
</blockquote>
<ol>
<li>目前已经可以实现简单的插入操作了。数据库的这个整体架构已经写好.</li>
<li>下一步的事情就是实现使用B-Tree作为数据库底层的索引。以及使用编译原理解析命令，而不是简单地使用strcmp.</li>
</ol>
<h2 id="PLAN-5-datastructure"><a href="#PLAN-5-datastructure" class="headerlink" title="PLAN 5 datastructure"></a>PLAN 5 datastructure</h2><h3 id="digest-4"><a href="#digest-4" class="headerlink" title="digest"></a>digest</h3><p>考研要学习数据结构，我发现自己的数据结构基本功真不怎么样，所以需要从头开始学习一边，同时也是为将来的考研做准备。<br>参考数据结构严蔚敏c语言版、c primer plus、STL进行底层数据结构的实现。</p>
<h3 id="timeline-4"><a href="#timeline-4" class="headerlink" title="timeline"></a>timeline</h3><blockquote>
<p><strong>time: 202107011507</strong></p>
</blockquote>
<ol>
<li>在这之前已经将链表进行了实现。</li>
</ol>
<blockquote>
<p><strong>time: 202107031418</strong></p>
</blockquote>
<ol>
<li>重新实现了两种线性表。</li>
<li>实现了基于两种线性表的栈。</li>
</ol>
<blockquote>
<p><strong>time：202107241529</strong></p>
</blockquote>
<ol>
<li>实现了BSTree</li>
</ol>
<blockquote>
<p><strong>time：202108222022</strong></p>
</blockquote>
<ol>
<li>实现了图,红黑树,B树,AVL树</li>
</ol>
<h2 id="PLAN-6-game-engine"><a href="#PLAN-6-game-engine" class="headerlink" title="PLAN 6 game engine"></a>PLAN 6 game engine</h2><h3 id="digest-5"><a href="#digest-5" class="headerlink" title="digest"></a>digest</h3><p>虽然在双创中的项目就是一个游戏引擎，但是我觉得这个项目实现的不是很优雅，我想像<strong>eaxy x</strong>一样做出一个3D游戏引擎，再进一步的目标就是一边像命令行一样进行输入代码，一边可以实时的显示出来结果。</p>
<h3 id="timeline-5"><a href="#timeline-5" class="headerlink" title="timeline"></a>timeline</h3><blockquote>
<p><strong>time: 202107241530</strong></p>
</blockquote>
<ol>
<li>项目已经完成验收，不过我认为这个项目实现的并不是很好，但是现在没有时间去完善了，现在要准备考研，等考完研之后，学习一下dx、vulkan做出一个简单地2D游戏引擎。</li>
<li>目前已完成的<a href="https://docs.xyyengine.com/">情况</a></li>
</ol>
<h2 id="PLAN-7-project-manager"><a href="#PLAN-7-project-manager" class="headerlink" title="PLAN 7 project manager"></a>PLAN 7 project manager</h2><h3 id="digest-6"><a href="#digest-6" class="headerlink" title="digest"></a>digest</h3><p>像这样再博客上进行项目记录和管理甚是麻烦，做一个可以方便进行这项工作的project，不过现在没有一点思路。</p>
<h3 id="timeline-6"><a href="#timeline-6" class="headerlink" title="timeline"></a>timeline</h3><blockquote>
<p><strong>time: 202107011513</strong></p>
</blockquote>
<ol>
<li>产生设想，没有一点思路。</li>
</ol>
<blockquote>
<p><strong>time: 202107241534</strong></p>
</blockquote>
<ol>
<li>在网页上使用vue制作一个任务规划器。</li>
</ol>
]]></content>
      <categories>
        <category>project</category>
        <category>plan</category>
      </categories>
      <tags>
        <tag>plan</tag>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>Initial Server Setup with Ubuntu</title>
    <url>/2021/04/21/Initial-Server-Setup-with-Ubuntu/</url>
    <content><![CDATA[<h1 id="Initial-Server-Setup-with-Ubuntu"><a href="#Initial-Server-Setup-with-Ubuntu" class="headerlink" title="Initial Server Setup with Ubuntu"></a>Initial Server Setup with Ubuntu</h1><ul>
<li>When you first create a new ubuntu 18.04 server, there are a new configuration steps that you should take early on as part of the basic setup. This will increase the security and usability of your server and will give you a solid foundation for subsequent actions.</li>
<li>This guide below demonstrates how to manually complete the steps recommended for new ubuntu 18.04 servers. Following this procedure manually can be useful to learn some basic system administration skills and as an exercise to fully understand the actions being taking on my server. As an alternative, if you wish to get up and running more quickly, you can run my initial server setup script which automates these steps.<h4 id="step-1-logging-in-as-root"><a href="#step-1-logging-in-as-root" class="headerlink" title="step 1 logging in as root"></a>step 1 logging in as root</h4></li>
<li>If you are not already connected to your server, go ahead and log in as root user using the following command, substitute server’s ip with your server’s public ip address.<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">ssh root<span class="meta">@server</span><span class="symbol">&#x27;s</span> ip</span><br></pre></td></tr></table></figure></li>
<li>Accept the warning about host authenticity if it appears. If you are using password authentication, provide your root password to login in. If you are using an SSH key that is passphrase protected, you may be prompted to enter the passphrase the first time you use the key each session. If this is your first time logging into the server with a password, you may also be prompted to change the root password.</li>
<li><strong>about root</strong><blockquote>
<p>The root user is the administrative user in a Linux environment that has very broad privileges. Because of the heightened privileges of the root account, you are discouraged form using it on a regular basis. This is because part of the power inherent with the root account is the ability to make very destructive changes, even by accident.</p>
<p>The next step is to set up an alternative user account with a reduced scope of influence for day-to-day work. I will teach you how to gain increased privileges during the times when you need them.</p>
</blockquote>
</li>
</ul>
<h4 id="step2-creating-a-new-user"><a href="#step2-creating-a-new-user" class="headerlink" title="step2 creating a new user"></a>step2 creating a new user</h4><ul>
<li>Once you are logged in as root, we are prepared to add the new user account that we will use to log in from now on.</li>
<li>This example create a new user named wenyao<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adduser wenyao</span></span><br></pre></td></tr></table></figure></li>
<li>You will be asked a few questions, starting with the account password.</li>
<li>Enter a strong password and, optionally, fill in any of the additional information if you would like. This is not required and you can just hit enter to skip.</li>
</ul>
<h4 id="step3-granting-administrative-privileges"><a href="#step3-granting-administrative-privileges" class="headerlink" title="step3 granting administrative privileges"></a>step3 granting administrative privileges</h4><ul>
<li>Now, we have a new user account with regular account privileges. However, we may sometimes need to do administrative tasks.</li>
<li>To avoid having to log out of our normal user and log back in as the root account, we can set up what is known as superuser or root privileges for our normal account. This allow our normal user to run commands with administrative privileges by putting the word “sudo” before each command.</li>
<li>To add these privileges to our new user, we need add the new user to the “sudo” group. By default, on ubuntu 18.04, users who belong to the “sudo” group are allow to use the “sudo” command.</li>
<li>As root, run this command to add new user to the sudo group.<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">usermod -aG sudo wenyao</span></span><br></pre></td></tr></table></figure></li>
<li>Now, when logged in as your regular user, you can type “sudo” before commands to perform actions with superuser privileges.</li>
</ul>
<h4 id="step4-setting-up-a-basic-firewall"><a href="#step4-setting-up-a-basic-firewall" class="headerlink" title="step4 setting up a basic firewall"></a>step4 setting up a basic firewall</h4><ul>
<li><p>ubuntu 18.04 servers can use the UFW firewall to make sure only connections to certain services are allowed. We can set up a basic firewall very easily using this application.</p>
</li>
<li><p>Different applications can register their profiles with UFW upon installation. These profiles allow UFW to manager these applications by name. OpenSSH, the service allowing us to connect to our server now, has a profile registered with UFW. You can see this by typing:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ufw app list</span></span><br></pre></td></tr></table></figure></li>
<li><p>the output will looks like this:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Available</span> applications:</span><br><span class="line">  OpenSSH</span><br></pre></td></tr></table></figure></li>
<li><p>We need make sure that the firewall allows SSH connections so that we can log back in next time. We can allow these connections by typing:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ufw</span> <span class="literal">allow</span> OpenSSH</span><br></pre></td></tr></table></figure></li>
<li><p>Afterwards, we can enable the firewall by typing:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure></li>
<li><p>You can see that SSH connections are allowed by typing:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ufw status</span></span><br></pre></td></tr></table></figure></li>
<li><p>the output will looks like this:</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">Status:</span> <span class="comment">active</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">To</span>                         <span class="comment">Action</span>      <span class="comment">From</span></span><br><span class="line"><span class="comment"></span>--                         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>      --<span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="comment">OpenSSH</span>                    <span class="comment">ALLOW</span>       <span class="comment">Anywhere</span></span><br><span class="line"><span class="comment">OpenSSH</span> <span class="comment">(v6)</span>               <span class="comment">ALLOW</span>       <span class="comment">Anywhere</span> <span class="comment">(v6)</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure></li>
<li><p>As the firewall is currently blocking all connections except for SSH. If you install and configure additional services, you will need to adjust the firewall setting to allow acceptable traffic in. </p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>XYY Game Engine 封装和使用</title>
    <url>/2021/07/10/XYY-Game-Engine-%E5%B0%81%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="XYY-Game-Engine-封装和使用"><a href="#XYY-Game-Engine-封装和使用" class="headerlink" title="XYY Game Engine 封装和使用"></a>XYY Game Engine 封装和使用</h1><h2 id="c-封装"><a href="#c-封装" class="headerlink" title="c++封装"></a>c++封装</h2><p>将c++项目封装为一个动态链接库，向外只提供接口，这样不仅仅方便发行，更可以加快成程序运行的速度。将XYY项目封装的步骤如下：            </p>
<ol>
<li>将所有的声明定义为导出，以类作为示范。</li>
</ol>
<p>即将        </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XYY_GlobalDriver</span> :</span> <span class="keyword">public</span> XYY_Driver</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> tag;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;						<span class="comment">// 初始化</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(XYY_SceneContent * sc)</span></span>;	<span class="comment">// 运行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更改为  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">declspec</span>(<span class="title">dllexport</span>) <span class="title">XYY_GlobalDriver</span> :</span> <span class="keyword">public</span> XYY_Driver</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> tag;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;						<span class="comment">// 初始化</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(XYY_SceneContent * sc)</span></span>;	<span class="comment">// 运行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>删除main函数，并写以下两个文件</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//XYY_Game_Engine.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> XYY_Game_Engine_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XYY_Game_Engine_H</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//XYY_Game_Engine.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;XYY_Game_Engine.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport)<span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>更改解决方案类型为dll</li>
</ol>
<p><img src="/file/XYY-Game-Engine-%E5%B0%81%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/1.png" alt="dll"></p>
<ol start="4">
<li>将此处改为自己想要的</li>
</ol>
<p><img src="/file/XYY-Game-Engine-%E5%B0%81%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/2.png" alt="dll"></p>
<ol start="5">
<li><p>生成解决方案</p>
</li>
<li><p>在解决方案目录中即可找到</p>
</li>
</ol>
<p><img src="/file/XYY-Game-Engine-%E5%B0%81%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/3.png" alt="dll"></p>
<ol start="7">
<li><p>将项目的cpp文件删除，即将所有的实现删除只留下声明的接口,将刚刚插入的所有 __declspec(dllexport) 删除</p>
</li>
<li><p>打包发布。</p>
</li>
</ol>
<h2 id="动态链接库的使用"><a href="#动态链接库的使用" class="headerlink" title="动态链接库的使用"></a>动态链接库的使用</h2><ol>
<li>添加库目录和头文件目录以及添加对lib文件的依赖。</li>
</ol>
<p><img src="/file/XYY-Game-Engine-%E5%B0%81%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/4.png" alt="dll"><br><img src="/file/XYY-Game-Engine-%E5%B0%81%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/5.png" alt="dll"><br>添加对lib文件的依赖也可以使用这样的预处理指令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;XYY_Game_Engine.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>将dll文件放在项目的根目录下，或者放在和项目的解决方案exe的同目录。</p>
</li>
<li><p>示例,发现加载速度极快，因为所有的文件都是编译过的，但我不明白为什么加载也会加快。</p>
</li>
</ol>
<p><img src="/file/XYY-Game-Engine-%E5%B0%81%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/6.png" alt="dll"></p>
<h2 id="构建DLL项目规范"><a href="#构建DLL项目规范" class="headerlink" title="构建DLL项目规范"></a>构建DLL项目规范</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ol>
<li><p>首先必须将声明和实现相分离。</p>
</li>
<li><p>项目在实现的时候就将code目录加入到<strong>包含目录</strong>中，即可以使用 #include &lt;file.h&gt; 自包</p>
</li>
<li><p>将所有使用到的代码全部放在code目录下，包括GLSL等，这样项目构建和项目使用就没有差别了。用户只需要将提供的code文件夹加入<strong>包含目录</strong>即可，当然，code文件夹是随意的，即为项目根目录也可。</p>
</li>
<li><p>提供项目本身代码 include 文件夹以及项目依赖dependence文件夹，用户需要把这两个文件夹放入包含目录中.</p>
</li>
<li><p>使用以下两种方法避免重复包含。推荐使用后一种。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once </span></span><br></pre></td></tr></table></figure>
<p>或者 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//XYY_Game_Engine.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> XYY_Game_Engine_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XYY_Game_Engine_H</span></span><br><span class="line"><span class="comment">//code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>写好注释</strong></li>
</ol>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>XYY</tag>
        <tag>项目构建</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>build a mail server for myself</title>
    <url>/2021/04/16/build-a-mail-server-for-myself/</url>
    <content><![CDATA[<h1 id="build-a-mail-server-for-myself"><a href="#build-a-mail-server-for-myself" class="headerlink" title="build a mail server for myself"></a>build a mail server for myself</h1><h2 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h2><ul>
<li>centos7.6<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4></li>
<li>解析域名添加两条记录<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="keyword">A</span> 记录</span><br><span class="line">记录类型：<span class="keyword">A</span></span><br><span class="line">主机记录：@</span><br><span class="line">记录值：ip address</span><br><span class="line"></span><br><span class="line"><span class="keyword">MX</span> 记录</span><br><span class="line">记录类型：<span class="keyword">MX</span></span><br><span class="line">主机记录：@</span><br><span class="line">记录值：我的域名</span><br></pre></td></tr></table></figure></li>
<li>生效检查</li>
</ul>
<ol>
<li>ping mydomain, 如果返回了刚刚解析的ip地址，则成功。</li>
<li>检查MX记录, nslookup -q=mx mydomain,如果返回的信息中有域名，则成功。</li>
</ol>
<h4 id="postfix"><a href="#postfix" class="headerlink" title="postfix"></a>postfix</h4><ol>
<li>安装<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> postfix</span><br></pre></td></tr></table></figure></li>
<li>配置，参考如下<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">postconf -e <span class="symbol">&#x27;myhostname</span> = server.cuimouren.cn&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;mydestination</span> = localhost, localhost.localdomain&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;myorigin</span> = $mydomain&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;mynetworks</span> = <span class="number">127.0</span>.<span class="number">0.0</span>/<span class="number">8</span>&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;inet_interfaces</span> = <span class="keyword">all</span>&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;inet_protocols</span> = <span class="keyword">all</span>&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;mydestination</span> = $myhostname, localhost.$mydomain, localhost, $mydomain&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;home_mailbox</span> = Maildir/&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;smtpd_sasl_type</span> = dovecot&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;smtpd_sasl_path</span> = <span class="keyword">private</span>/auth&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;smtpd_sasl_auth_enable</span> = yes&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;broken_sasl_auth_clients</span> = yes&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;smtpd_sasl_authenticated_header</span> = yes&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;smtpd_recipient_restrictions</span> = permit_mynetworks, permit_sasl_authenticated, reject_unauth_destination&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;smtpd_use_tls</span> = yes&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;smtpd_tls_cert_file</span> = /etc/pki/dovecot/certs/dovecot.pem&#x27;</span><br><span class="line">postconf -e <span class="symbol">&#x27;smtpd_tls_key_file</span> = /etc/pki/dovecot/<span class="keyword">private</span>/dovecot.pem&#x27;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>配置中 Postfix 使用 sasl 和 tls 来完成身份认证和传输信息加密。<br>试验中使用了 Dovecot 默认的 ssl 证书和私钥，如果你需要修改为自己的，请替换最后两行配置的路径。</li>
</ul>
<ol start="3">
<li>配置 smtps</li>
</ol>
<ul>
<li>部分邮件客户端依赖于使用 465 端口提供加密连接，所以我们修改配置，允许 Postfix 使用 465 端口发送邮件。打开 /etc/postfix/master.cf 文件，将如下两行前的 # 去除：<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">smtps inet <span class="built_in">n</span> - <span class="built_in">n</span> - - smtpd</span><br><span class="line">-o smtpd_tls_wrappermode=yes</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>启动</li>
</ol>
<ul>
<li>使用以下命令，将 Postfix 设为自动启动并首次启动该服务：<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">systemctl enable <span class="built_in">postfix</span>.service</span><br><span class="line">systemctl start  <span class="built_in">postfix</span>.service</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li>log</li>
</ol>
<ul>
<li>Postfix 系统的日志文件在系统的这个目录下的 /var/log/maillog 文件，此文件记录了 Postfix 服务器的运行状态信息。<h4 id="dovecot"><a href="#dovecot" class="headerlink" title="dovecot"></a>dovecot</h4></li>
</ul>
<ol>
<li>安装<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> dovecot</span><br></pre></td></tr></table></figure></li>
<li>配置</li>
</ol>
<ul>
<li>打开 /etc/dovecot/dovecot.conf 文件，在最下方加入以下配置：<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">ssl_cert</span> = &lt;/etc/pki/dovecot/certs/dovecot.pem</span><br><span class="line"><span class="attr">ssl_key</span> = &lt;/etc/pki/dovecot/private/dovecot.pem</span><br><span class="line"></span><br><span class="line"><span class="attr">protocols</span> = imap pop3 lmtp</span><br><span class="line"><span class="attr">listen</span> = *</span><br><span class="line"><span class="attr">mail_location</span> = Maildir:~/Maildir</span><br><span class="line"><span class="attr">disable_plaintext_auth</span> = <span class="literal">no</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>如果前面你修改为了自己的 ssl 证书和私钥，请替换开始两行配置的路径。</li>
<li>打开 /etc/dovecot/conf.d/10-master.conf 文件，找到 service auth 部分，将以下行前面的 # 去除：<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">unix_listener <span class="regexp">/var/</span>spool<span class="regexp">/postfix/</span><span class="keyword">private</span>/auth &#123;  </span><br><span class="line">       mode = <span class="number">0666</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>启动<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">systemctl <span class="keyword">enable</span> dovecot.service</span><br><span class="line">systemctl <span class="keyword">start</span>  dovecot.service</span><br></pre></td></tr></table></figure></li>
<li>log</li>
</ol>
<ul>
<li>查看 /var/log/maillog 是否启动成功，如下所示为成功。<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Jun</span> <span class="number">26</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">28</span> localhost postfix/postfix-script[<span class="number">28338</span>]: starting the Postfix mail system</span><br><span class="line"><span class="attribute">Jun</span> <span class="number">26</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">29</span> localhost postfix/master[<span class="number">28340</span>]: daemon started -- version <span class="number">2</span>.<span class="number">10</span>.<span class="number">1</span>, configuration /etc/postfix</span><br><span class="line"><span class="attribute">Jun</span> <span class="number">26</span> <span class="number">12</span>:<span class="number">28</span>:<span class="number">40</span> localhost dovecot: master: Dovecot v<span class="number">2</span>.<span class="number">2</span>.<span class="number">10</span> starting up for imap, pop<span class="number">3</span>, lmtp (core dumps disabled)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4></li>
<li>添加用户<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">uaeradd username</span></span><br></pre></td></tr></table></figure></li>
<li>设置密码<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">passwd username</span></span><br></pre></td></tr></table></figure>
<h4 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h4></li>
<li>su mailuser 切换用户</li>
<li>发送邮件<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;邮件内容&quot;</span> <span class="string">| mail -s &quot;</span>邮件主题<span class="string">&quot;  目标邮箱</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>使用</category>
        <category>mail</category>
      </categories>
      <tags>
        <tag>vps</tag>
        <tag>mail</tag>
        <tag>myself</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake 使用</title>
    <url>/2021/07/13/cmake-%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="CMmake"><a href="#CMmake" class="headerlink" title="CMmake"></a>CMmake</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单来讲，cmake是一个跨平台的makefile生成器。大型项目的额makefile实在是太繁琐了。学习cmake就是在学习其语法。一般来讲，只有在使用c/c++做一个大项目的时候才用得到cmake</p>
<h2 id="基本命令简介"><a href="#基本命令简介" class="headerlink" title="基本命令简介"></a>基本命令简介</h2><h3 id="project"><a href="#project" class="headerlink" title="project"></a>project</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">PROJECT(&lt;projectname&gt; <span class="selector-attr">[CXX]</span> <span class="selector-attr">[C]</span> <span class="selector-attr">[Java]</span>)</span><br></pre></td></tr></table></figure>

<p>指定生成项目的名字，可选项目语言（默认位全选）<br>同时 cmake 系统也帮助我们预定义了<br>PROJECT_BINARY_DIR 指向生成的项目的路径（build） 和<br>PROJECT_SOURCE_DIR  指向项目源文件的路径(source)</p>
<h3 id="MESSAGE"><a href="#MESSAGE" class="headerlink" title="MESSAGE"></a>MESSAGE</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">([SEND_ERROR | STATUS | FATAL_ERROR] <span class="string">&quot;message to display&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>这个指令用于向终端输出用户定义的信息，包含了三种类型:</p>
<ol>
<li>SEND_ERROR，产生错误，生成过程被跳过。</li>
<li>SATUS，输出前缀为—的信息。</li>
<li>FATAL_ERROR，立即终止所有 cmake 过程. </li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;build &quot;</span> <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span> <span class="string">&quot; source &quot;</span> <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><p>显式地定义变量</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">SET(SRC_LIST <span class="params">main</span>.<span class="params">c</span> <span class="params">t1</span>.<span class="params">c</span> <span class="params">t2</span>.<span class="params">c</span>)</span></span><br></pre></td></tr></table></figure>

<p>将 main.c t1.c t2.c 定义为源文件列表</p>
<h3 id="ADD-EXECUTABLE"><a href="#ADD-EXECUTABLE" class="headerlink" title="ADD_EXECUTABLE"></a>ADD_EXECUTABLE</h3><p>生成可执行文件</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ADD_EXECUTABLE</span><span class="params">(hello $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="ADD-SUBDIRECTORY"><a href="#ADD-SUBDIRECTORY" class="headerlink" title="ADD_SUBDIRECTORY"></a>ADD_SUBDIRECTORY</h3><p>位当前目录添加一个子目录 </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">ADD_SUBDIRECTORY(<span class="params">source_dir</span> [<span class="params">binary_dir</span>] [EXCLUDE_FROM_ALL])</span></span><br></pre></td></tr></table></figure>

<h3 id="INSTALL"><a href="#INSTALL" class="headerlink" title="INSTALL"></a>INSTALL</h3><p>CMAKE_INSTALL_PREFIX</p>
<p>DESTINATION 定义了安装的路径，如果路径以/开头，那么指的是绝对路径，这时候<br>CMAKE_INSTALL_PREFIX 其实就无效了。如果你希望使用 CMAKE_INSTALL_PREFIX 来定义安装路径，就要写成相对路径，即不要以/开头，那么安装后的路径就是<br>${CMAKE_INSTALL_PREFIX}/&lt;DESTINATION 定义的路径&gt;</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSTALL</span>(TARGETS myrun mylib mystaticlib</span><br><span class="line">RUNTIME DESTINATION bin</span><br><span class="line">LIBRARY DESTINATION lib</span><br><span class="line">ARCHIVE DESTINATION libstatic )</span><br><span class="line"></span><br><span class="line">上面的例子会将： </span><br><span class="line">可执行二进制 myrun 安装到<span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/bin 目录 </span><br><span class="line">动态库 libmylib 安装到<span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/lib 目录 </span><br><span class="line">静态库 libmystaticlib 安装到<span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/libstatic 目录</span><br></pre></td></tr></table></figure>

<p>普通文件的安装</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">INSTALL(FILES files... DESTINATION &lt;dir&gt;</span><br><span class="line"> <span class="comment">[PERMISSIONS permissions...]</span></span><br><span class="line"> <span class="comment">[CONFIGURATIONS <span class="comment">[Debug|Release|...]</span>]</span></span><br><span class="line"> <span class="comment">[COMPONENT &lt;component&gt;]</span></span><br><span class="line"> <span class="comment">[RENAME &lt;name&gt;]</span> <span class="comment">[OPTIONAL]</span>)</span><br></pre></td></tr></table></figure>


<h3 id="ADD-LIBRARY"><a href="#ADD-LIBRARY" class="headerlink" title="ADD_LIBRARY"></a>ADD_LIBRARY</h3><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">ADD_LIBRARY(libname [<span class="keyword">SHARED</span>|<span class="keyword">STATIC</span>|<span class="keyword">MODULE</span>]</span><br><span class="line"> [EXCLUDE_FROM_ALL]</span><br><span class="line"> source1 source2 ... sourceN)</span><br></pre></td></tr></table></figure>


<h3 id="SET-TARGET-PROPERTIES"><a href="#SET-TARGET-PROPERTIES" class="headerlink" title="SET_TARGET_PROPERTIES"></a>SET_TARGET_PROPERTIES</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">SET_TARGET_PROPERTIES</span>(target<span class="number">1</span> target<span class="number">2</span> ...</span><br><span class="line"> <span class="attribute">PROPERTIES</span> prop<span class="number">1</span> value<span class="number">1</span></span><br><span class="line"> <span class="attribute">prop2</span> value<span class="number">2</span> ...)</span><br></pre></td></tr></table></figure>

<h3 id="GET-TARGET-PROPERTY"><a href="#GET-TARGET-PROPERTY" class="headerlink" title="GET_TARGET_PROPERTY"></a>GET_TARGET_PROPERTY</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">与他对应的指令是：</span><br><span class="line"><span class="function"><span class="title">GET_TARGET_PROPERTY</span><span class="params">(VAR target property)</span></span></span><br><span class="line">具体用法如下例，我们向 lib/CMakeListst<span class="selector-class">.txt</span> 中添加：</span><br><span class="line"><span class="function"><span class="title">GET_TARGET_PROPERTY</span><span class="params">(OUTPUT_VALUE hello_static OUTPUT_NAME)</span></span></span><br><span class="line">MESSAGE(STATUS “This is the hello_static</span><br><span class="line">OUTPUT_NAME:”$&#123;OUTPUT_VALUE&#125;)</span><br><span class="line">如果没有这个属性定义，则返回 NOTFOUND.</span><br></pre></td></tr></table></figure>

<h3 id="INCLUDE-DIRECTORIES"><a href="#INCLUDE-DIRECTORIES" class="headerlink" title="INCLUDE_DIRECTORIES"></a>INCLUDE_DIRECTORIES</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">现在我们在 src/<span class="module-access"><span class="module"><span class="identifier">CMakeLists</span>.</span></span>txt 中添加一个头文件搜索路径，方式很简单，加入：</span><br><span class="line"><span class="constructor">INCLUDE_DIRECTORIES(<span class="operator">/</span><span class="params">usr</span><span class="operator">/</span><span class="params">include</span><span class="operator">/</span><span class="params">hello</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="LINK-DIRECTORIES"><a href="#LINK-DIRECTORIES" class="headerlink" title="LINK_DIRECTORIES"></a>LINK_DIRECTORIES</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">LINK_DIRECTORIES</span>(<span class="params">directory1 directory2 ...</span>)</span></span><br></pre></td></tr></table></figure>

<p>这个指令非常简单，添加非标准的共享库搜索路径，比如，在工程内部同时存在共享库和可 执行二进制，在编译时就需要指定一下这些共享库的路径。这个例子中我们没有用到这个指 令。</p>
<h3 id="TARGET-LINK-LIBRARIES"><a href="#TARGET-LINK-LIBRARIES" class="headerlink" title="TARGET_LINK_LIBRARIES"></a>TARGET_LINK_LIBRARIES</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(<span class="keyword">target</span> library1</span><br><span class="line"> &lt;debug | optimized&gt; library2</span><br><span class="line"> ...)</span><br><span class="line">这个指令可以用来为 <span class="keyword">target</span> 添加需要链接的共享库，本例中是一个可执行文件，但是同样</span><br><span class="line">可以用于为自己编写的共享库添加共享库链接。</span><br></pre></td></tr></table></figure>






<h2 id="cmake-学习-assimp的经验"><a href="#cmake-学习-assimp的经验" class="headerlink" title="cmake 学习 assimp的经验"></a>cmake 学习 assimp的经验</h2><h3 id="项目文件目录"><a href="#项目文件目录" class="headerlink" title="项目文件目录"></a>项目文件目录</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">code</span><br><span class="line">    <span class="comment">--项目的各种代码文件夹</span></span><br><span class="line">    <span class="comment">--CMakeLists.txt</span></span><br><span class="line">contrib</span><br><span class="line">    <span class="comment">--各种依赖的文件夹</span></span><br><span class="line">doc</span><br><span class="line"><span class="built_in">include</span></span><br><span class="line">    <span class="comment">--项目的头文件，对外的接口</span></span><br><span class="line">samples</span><br><span class="line">tests</span><br><span class="line">tools</span><br><span class="line">readme.md</span><br><span class="line">CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>对别的项目的依赖不使用自己编译好的lib或者dll，而是直接使用源文件。估计编译assimp的时候把这些源文件都编译了一遍</li>
<li>code文件夹就放自己的代码。</li>
<li>include文件夹就负责对外提供接口。</li>
<li>只使用两个CMakeLists.txt,根目录下的负责项目的整体信息描述，code目录下的负责对文件的编译。</li>
</ol>
<h3 id="cmake-编写"><a href="#cmake-编写" class="headerlink" title="cmake 编写"></a>cmake 编写</h3><p>太复杂了，我现在并看不懂。但并不像我这样每一个模块编写一个CMakeLists.txt进行cmake，而是根目录下的负责项目的整体信息描述，code目录下的负责对文件的编译。</p>
<h3 id="项目编译"><a href="#项目编译" class="headerlink" title="项目编译"></a>项目编译</h3><ol>
<li>首先按照上面的文件目录进行编排。</li>
<li>编写CMakeLists.txt 文件<ol>
<li>最好编译成动态链接库，不然没有办法将项目的静态依赖库lib文件包含在内。</li>
<li>若项目的依赖中存在动态库，比如assimp 时，就没办法将其包含在内了，只能让用户显式地使用assimp.</li>
</ol>
</li>
<li>将项目的头文件列举出来保存到include文件夹中，这里面的就是提供给用户的接口，将不想提供给用户的接口删除即可。</li>
<li>记得cmake中进行install，将所有需要提供给用户的文件全部放在最显眼的地方。</li>
</ol>
<h3 id="CMakeLists-txt-编写"><a href="#CMakeLists-txt-编写" class="headerlink" title="CMakeLists.txt 编写"></a>CMakeLists.txt 编写</h3><p>我现在对编译有关的知识了解甚少，所以现在只能使用一些最基础的东西，日后会对编译有更深得了解。</p>
<ol>
<li><p>cmake的最下版本要求</p>
</li>
<li><p>确定项目的名称</p>
</li>
<li><p>确定项目的目录安排</p>
</li>
<li><p>确定项目的包含目录和库目录</p>
</li>
<li><p>确定项目生成目标位置</p>
</li>
<li><p>确定项目的额依赖</p>
</li>
<li><p>确定目标使用的文件并安排成组</p>
</li>
<li><p>确定目标工程的筛选器</p>
</li>
<li><p>编译项目</p>
</li>
<li><p>安装项目</p>
</li>
</ol>
<h3 id="Demo-list"><a href="#Demo-list" class="headerlink" title="Demo list"></a>Demo list</h3><h2 id="XYY-Game-Engine-的构建示例"><a href="#XYY-Game-Engine-的构建示例" class="headerlink" title="XYY_Game_Engine 的构建示例"></a>XYY_Game_Engine 的构建示例</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line">cmake_minimum_required (VERSION <span class="number">3.20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line">project(XYY_Game_Engine)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#变量设置   主要是目录变量</span></span><br><span class="line"><span class="comment">#CMAKE_INSTALL_PREFIX</span></span><br><span class="line">set(CMAKE_INSTALL_PREFIX <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>)</span><br><span class="line"><span class="comment">#code目录</span></span><br><span class="line">set(CODE_ROOT_PATH <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/code/</span>)</span><br><span class="line"><span class="comment">#build目录</span></span><br><span class="line">set(BUILD_PATH <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/build/</span>)</span><br><span class="line"><span class="comment">#存放生成的lib的目录</span></span><br><span class="line">set(LIB_PATH <span class="variable">$&#123;BUILD_PATH&#125;</span><span class="regexp">/../</span>lib/)</span><br><span class="line"><span class="comment">#存放生成的dll的目录</span></span><br><span class="line">set(DLL_PATH <span class="variable">$&#123;BUILD_PATH&#125;</span><span class="regexp">/../</span>dll/)</span><br><span class="line"><span class="comment">#编译所需包含目录</span></span><br><span class="line">set(INCLUDE_PATH_CODE <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/include/</span>)</span><br><span class="line">set(INCLUDE_PATH_CONTRIB <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/contrib/i</span>nclude/)</span><br><span class="line"><span class="comment">#编译所需库目录</span></span><br><span class="line">set(LIBRARY_PATH_CONTRIB <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/contrib/</span>lib/)</span><br><span class="line"><span class="comment">#设置test路径</span></span><br><span class="line">set(TEST_PATH <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/build/</span>test/)</span><br><span class="line"><span class="comment">#指定程序的包含目录 库目录</span></span><br><span class="line"><span class="comment">#引用目录</span></span><br><span class="line"><span class="comment">#INCLUDE_DIRECTORIES($&#123;INCLUDE_PATH_CODE&#125;)</span></span><br><span class="line">INCLUDE_DIRECTORIES(<span class="variable">$&#123;INCLUDE_PATH_CONTRIB&#125;</span>)</span><br><span class="line">INCLUDE_DIRECTORIES(<span class="variable">$&#123;TEST_PATH&#125;</span>/include)</span><br><span class="line"><span class="comment">#库目录 将生成的lib 目录也包含在内，为了给test使用</span></span><br><span class="line">LINK_DIRECTORIES(<span class="variable">$&#123;LIBRARY_PATH_CONTRIB&#125;</span>)</span><br><span class="line">LINK_DIRECTORIES(<span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置目标的属性 </span></span><br><span class="line"><span class="keyword">function</span>(SetDefaultTargetProperties target)</span><br><span class="line">	<span class="comment">#程序生成文件的目录   </span></span><br><span class="line">	set_target_properties(<span class="variable">$&#123;target&#125;</span> PROPERTIES</span><br><span class="line">		ARCHIVE_OUTPUT_DIRECTORY <span class="variable">$&#123;LIB_PATH&#125;</span></span><br><span class="line">		LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;LIB_PATH&#125;</span></span><br><span class="line">		RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;DLL_PATH&#125;</span></span><br><span class="line">	)</span><br><span class="line">endfunction()</span><br><span class="line"></span><br><span class="line"><span class="comment">#MESSAGE(STATUS $&#123;LIB_PATH&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#code的编译  得到 XYY_Game_Engine.lib XYY_Game_Engine.dll </span></span><br><span class="line">add_subdirectory(<span class="variable">$&#123;CODE_ROOT_PATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#放入 lib 文件夹</span></span><br><span class="line">INSTALL(TARGETS</span><br><span class="line">    XYY_Game_Engine</span><br><span class="line">    LIBRARY DESTINATION</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/lib/</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#放入 bin 中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(EXISTS   <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/dll/</span>Debug/XYY_Game_Engine.dll)</span><br><span class="line">INSTALL(FILES</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/dll/</span>Debug/XYY_Game_Engine.dll</span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/bin/</span></span><br><span class="line">)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(EXISTS    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/dll/</span>assimp-vc142-mt.dll)</span><br><span class="line">INSTALL(FILES</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/dll/</span>assimp-vc142-mt.dll</span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/bin</span><br><span class="line">)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#对 test 增加支持   dll  release  test 所有的引用都来原来自include中的</span></span><br><span class="line">INSTALL(FILES</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/bin/</span>assimp-vc142-mt.dll</span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/build/</span>test/Release</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">INSTALL(FILES</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/bin/</span>XYY_Game_Engine.dll</span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/build/</span>test/Release</span><br><span class="line">)</span><br><span class="line">INSTALL(FILES</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/bin/</span>assimp-vc142-mt.dll</span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/build/</span>test/Debug</span><br><span class="line">)</span><br><span class="line">INSTALL(FILES</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/bin/</span>XYY_Game_Engine.dll</span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/build/</span>test/Debug</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">FILE(</span><br><span class="line">    GLOB_RECURSE Header_Driver</span><br><span class="line">    <span class="variable">$&#123;CODE_ROOT_PATH&#125;</span><span class="regexp">/Driver/</span>*.hpp</span><br><span class="line">)</span><br><span class="line">FILE(</span><br><span class="line">    GLOB_RECURSE Header_Driver_LocalDriver</span><br><span class="line">    <span class="variable">$&#123;CODE_ROOT_PATH&#125;</span><span class="regexp">/Driver/</span>LocalDriver/*.h</span><br><span class="line">)</span><br><span class="line">FILE(</span><br><span class="line">    GLOB_RECURSE Header_Driver_Global</span><br><span class="line">    <span class="variable">$&#123;CODE_ROOT_PATH&#125;</span><span class="regexp">/Driver/</span>GlobalDriver/*.h</span><br><span class="line">)</span><br><span class="line"><span class="comment">#SRC_Element</span></span><br><span class="line">FILE(</span><br><span class="line">    GLOB_RECURSE Header_Element</span><br><span class="line">    <span class="variable">$&#123;CODE_ROOT_PATH&#125;</span><span class="regexp">/Element/</span>*.h</span><br><span class="line">)</span><br><span class="line"><span class="comment">#SRC_Resource</span></span><br><span class="line">FILE(</span><br><span class="line">    GLOB_RECURSE Header_Resource</span><br><span class="line">    <span class="variable">$&#123;CODE_ROOT_PATH&#125;</span><span class="regexp">/Resource/</span>*.h</span><br><span class="line">)</span><br><span class="line"><span class="comment">#SRC_Resource</span></span><br><span class="line">FILE(</span><br><span class="line">    GLOB_RECURSE Header_Scene</span><br><span class="line">    <span class="variable">$&#123;CODE_ROOT_PATH&#125;</span><span class="regexp">/Scene/</span>*.h</span><br><span class="line">)</span><br><span class="line"><span class="comment">#SRC_Sync</span></span><br><span class="line">FILE(</span><br><span class="line">    GLOB_RECURSE Header_Sync</span><br><span class="line">    <span class="variable">$&#123;CODE_ROOT_PATH&#125;</span><span class="regexp">/Sync/</span>*.h</span><br><span class="line">)</span><br><span class="line">INSTALL(</span><br><span class="line">    FILES</span><br><span class="line">    <span class="variable">$&#123;Header_Driver&#125;</span></span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;INCLUDE_PATH_CODE&#125;</span><span class="regexp">/Driver/</span></span><br><span class="line">)</span><br><span class="line">INSTALL(</span><br><span class="line">    FILES</span><br><span class="line">    <span class="variable">$&#123;Header_Driver_LocalDriver&#125;</span></span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;INCLUDE_PATH_CODE&#125;</span><span class="regexp">/Driver/</span>LocalDriver/</span><br><span class="line">)</span><br><span class="line">INSTALL(</span><br><span class="line">    FILES</span><br><span class="line">    <span class="variable">$&#123;Header_Driver_Global&#125;</span></span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;INCLUDE_PATH_CODE&#125;</span><span class="regexp">/Driver/</span>GlobalDriver/</span><br><span class="line">)</span><br><span class="line">INSTALL(</span><br><span class="line">    FILES</span><br><span class="line">    <span class="variable">$&#123;Header_Element&#125;</span></span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;INCLUDE_PATH_CODE&#125;</span><span class="regexp">/Element/</span></span><br><span class="line">)</span><br><span class="line">INSTALL(</span><br><span class="line">    FILES</span><br><span class="line">    <span class="variable">$&#123;Header_Resource&#125;</span></span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;INCLUDE_PATH_CODE&#125;</span><span class="regexp">/Resource/</span></span><br><span class="line">)</span><br><span class="line">INSTALL(</span><br><span class="line">    FILES</span><br><span class="line">    <span class="variable">$&#123;Header_Scene&#125;</span></span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;INCLUDE_PATH_CODE&#125;</span><span class="regexp">/Scene/</span></span><br><span class="line">)</span><br><span class="line">INSTALL(</span><br><span class="line">    FILES</span><br><span class="line">    <span class="variable">$&#123;Header_Sync&#125;</span></span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;INCLUDE_PATH_CODE&#125;</span><span class="regexp">/Sync/</span></span><br><span class="line">)</span><br><span class="line">INSTALL(</span><br><span class="line">    DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/code/</span>Scxmlexample</span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/include/</span></span><br><span class="line">)</span><br><span class="line">INSTALL(</span><br><span class="line">    DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/code/</span>resources</span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/include/</span></span><br><span class="line">)</span><br><span class="line">INSTALL(</span><br><span class="line">    DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/code/</span>GLSL</span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/include/</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># example </span></span><br><span class="line">INSTALL(</span><br><span class="line">    DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/include/</span>Scxmlexample</span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;TEST_PATH&#125;</span>/</span><br><span class="line">)</span><br><span class="line"><span class="comment"># resources</span></span><br><span class="line">INSTALL(</span><br><span class="line">    DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><span class="regexp">/include/</span>resources</span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;TEST_PATH&#125;</span>/</span><br><span class="line">)</span><br><span class="line"><span class="comment"># header</span></span><br><span class="line">INSTALL(</span><br><span class="line">    DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/include</span><br><span class="line">    DESTINATION</span><br><span class="line">    <span class="variable">$&#123;TEST_PATH&#125;</span>/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#target 测试</span></span><br><span class="line">add_subdirectory(test)</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#code </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#code 中的所有文件</span></span><br><span class="line"><span class="keyword">FILE</span>(GLOB_RECURSE SOURCE_CODE       </span><br><span class="line">    Driver/*</span><br><span class="line">    Driver/LocalDriver/*</span><br><span class="line">    Driver/GlobalDriver/*</span><br><span class="line">    Element/*</span><br><span class="line">    Resource/*</span><br><span class="line">    Scene/*</span><br><span class="line">    Sync/*</span><br><span class="line">    <span class="variable">$&#123;INCLUDE_PATH_CONTRIB&#125;</span>/*.c</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#组织 file </span></span><br><span class="line"><span class="comment">#Driver</span></span><br><span class="line"><span class="keyword">FILE</span>(</span><br><span class="line">    GLOB_RECURSE SRC_Driver</span><br><span class="line">    Driver/*.hpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">source_group</span>(Driver FILES <span class="variable">$&#123;SRC_Driver&#125;</span>)</span><br><span class="line"><span class="keyword">FILE</span>(</span><br><span class="line">    GLOB_RECURSE SRC_Driver_LocalDriver</span><br><span class="line">    Driver/LocalDriver/*</span><br><span class="line">)</span><br><span class="line"><span class="keyword">source_group</span>(Driver//LocalDriver FILES <span class="variable">$&#123;SRC_Driver_LocalDriver&#125;</span>)</span><br><span class="line"><span class="keyword">FILE</span>(</span><br><span class="line">    GLOB_RECURSE SRC_Driver_Global</span><br><span class="line">    Driver/GlobalDriver/*</span><br><span class="line">)</span><br><span class="line"><span class="keyword">source_group</span>(Driver//GlobalDriver FILES <span class="variable">$&#123;SRC_Driver_Global&#125;</span>)</span><br><span class="line"><span class="comment">#SRC_Element</span></span><br><span class="line"><span class="keyword">FILE</span>(</span><br><span class="line">    GLOB_RECURSE SRC_Element</span><br><span class="line">    Element/*</span><br><span class="line">)</span><br><span class="line"><span class="keyword">source_group</span>(Element FILES <span class="variable">$&#123;SRC_Element&#125;</span>)</span><br><span class="line"><span class="comment">#SRC_Resource</span></span><br><span class="line"><span class="keyword">FILE</span>(</span><br><span class="line">    GLOB_RECURSE SRC_Resource</span><br><span class="line">    Resource/*</span><br><span class="line">)</span><br><span class="line"><span class="keyword">source_group</span>(Resource FILES <span class="variable">$&#123;SRC_Resource&#125;</span>)</span><br><span class="line"><span class="comment">#SRC_Resource</span></span><br><span class="line"><span class="keyword">FILE</span>(</span><br><span class="line">    GLOB_RECURSE SRC_Scene</span><br><span class="line">    Scene/*</span><br><span class="line">)</span><br><span class="line"><span class="keyword">source_group</span>(Scene FILES <span class="variable">$&#123;SRC_Scene&#125;</span>)</span><br><span class="line"><span class="comment">#SRC_Sync</span></span><br><span class="line"><span class="keyword">FILE</span>(</span><br><span class="line">    GLOB_RECURSE SRC_Sync</span><br><span class="line">    Sync/*</span><br><span class="line">)</span><br><span class="line"><span class="keyword">source_group</span>(Sync FILES <span class="variable">$&#123;SRC_Sync&#125;</span>)</span><br><span class="line"><span class="comment">#xml</span></span><br><span class="line"><span class="keyword">FILE</span>(</span><br><span class="line">    GLOB_RECURSE SRC_Scxmlexample</span><br><span class="line">    <span class="variable">$&#123;CODE_ROOT_PATH&#125;</span>/Scxmlexample/*.xml</span><br><span class="line">)</span><br><span class="line"><span class="keyword">source_group</span>(Scxmlexample FILES <span class="variable">$&#123;SRC_Scxmlexample&#125;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FILE</span>(</span><br><span class="line">    GLOB DEPENDENCE_LIB</span><br><span class="line">    <span class="variable">$&#123;LIBRARY_PATH_CONTRIB&#125;</span>/*.lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成链接库</span></span><br><span class="line"><span class="keyword">add_library</span>(XYY_Game_Engine SHARED <span class="variable">$&#123;SOURCE_CODE&#125;</span> <span class="variable">$&#123;SRC_Scxmlexample&#125;</span>)</span><br><span class="line">SetDefaultTargetProperties(XYY_Game_Engine)</span><br><span class="line"><span class="comment">#  应该还要加上 opengl32.lib</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(XYY_Game_Engine   </span><br><span class="line">opengl32  </span><br><span class="line">glfw3.lib </span><br><span class="line">assimp-vc142-mt.lib  </span><br><span class="line">tinyxml.lib  </span><br><span class="line">kernel32.lib</span><br><span class="line">user32.lib</span><br><span class="line">gdi32.lib</span><br><span class="line">winspool.lib</span><br><span class="line">comdlg32.lib</span><br><span class="line">advapi32.lib</span><br><span class="line">shell32.lib</span><br><span class="line">ole32.lib</span><br><span class="line">oleaut32.lib</span><br><span class="line">uuid.lib</span><br><span class="line">odbc32.lib</span><br><span class="line">odbccp32.lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对于每一个项目，其相对路径的起始位置是 vs 那一对文件的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#xml</span></span><br><span class="line"><span class="keyword">FILE</span>(</span><br><span class="line">    GLOB_RECURSE SRC_Scxmlexample_test</span><br><span class="line">    <span class="variable">$&#123;CODE_ROOT_PATH&#125;</span>/Scxmlexample/*.xml</span><br><span class="line">)</span><br><span class="line"><span class="keyword">source_group</span>(Scxmlexample FILES <span class="variable">$&#123;SRC_Scxmlexample_test&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#test1</span></span><br><span class="line"><span class="keyword">add_executable</span>(test1 test1.cpp <span class="variable">$&#123;SRC_Scxmlexample_test&#125;</span>)</span><br><span class="line"><span class="keyword">ADD_DEPENDENCIES</span>(test1 XYY_Game_Engine)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(test1 XYY_Game_Engine)</span><br><span class="line"></span><br><span class="line"><span class="comment">#test1</span></span><br><span class="line"><span class="keyword">add_executable</span>(test2 test2.cpp <span class="variable">$&#123;SRC_Scxmlexample_test&#125;</span>)</span><br><span class="line"><span class="keyword">ADD_DEPENDENCIES</span>(test1 XYY_Game_Engine)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(test2 XYY_Game_Engine)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>tools</category>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>项目构建</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>code-server</title>
    <url>/2021/04/21/code-server/</url>
    <content><![CDATA[<h1 id="code-server"><a href="#code-server" class="headerlink" title="code-server"></a>code-server</h1><ul>
<li>code-server is a cloud ide platform, which can enable us to code through browser anywhere. But how to set up the code-server on ubuntu 18.04</li>
<li>Eeee, to practice my English, I prefer to using English in my blog, unless there is something I can’t express by using my poor English.<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4></li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkdir ~/code-server</span><br><span class="line">cd ~/code-server</span><br><span class="line">proxychains wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/cdr/</span>code-server<span class="regexp">/releases/</span>download<span class="regexp">/v3.10.1/</span>code-server-<span class="number">3.10</span>.<span class="number">1</span>-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xzvf code-server-<span class="number">3.10</span>.<span class="number">1</span>-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">mv code-server-<span class="number">3.10</span>.<span class="number">1</span>-linux-amd64 code-server</span><br><span class="line"></span><br><span class="line">rm -rf <span class="regexp">/usr/</span>lib/code-server</span><br><span class="line"></span><br><span class="line">cp -r code-server <span class="regexp">/usr/</span>lib/code-server</span><br><span class="line"></span><br><span class="line">ln -s <span class="regexp">/usr/</span>lib<span class="regexp">/code-server/</span>code-server <span class="regexp">/usr/</span>bin/code-server</span><br><span class="line"></span><br><span class="line">mkdir <span class="regexp">/var/</span>lib/code-server</span><br><span class="line"></span><br><span class="line">vi <span class="regexp">/lib/</span>systemd<span class="regexp">/system/</span>code-server.service</span><br></pre></td></tr></table></figure>
<p><strong>填入以下内容</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=code-server</span><br><span class="line"><span class="attr">After</span>=nginx.service</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">Environment</span>=PASSWORD=your_password</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/code-server --bind-addr <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span> --user-data-dir /var/lib/code-server --auth password</span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p><strong>启动</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">systemctl <span class="keyword">start</span> code-<span class="keyword">server</span></span><br><span class="line">systemctl <span class="keyword">enable</span> code-<span class="keyword">server</span></span><br><span class="line">systemctl status code-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>

<p><strong>export</strong><br>使用nginx使得外网可以访问</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span>code-server</span><br></pre></td></tr></table></figure>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> code-server.your-domain;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://localhost:8080/;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade $http_upgrade;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Connection upgrade;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Accept-Encoding gzip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ln -s <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span>code-server <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-enabled/</span>code-server</span><br><span class="line"></span><br><span class="line">nginx -t</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>

<p><strong>Securing Your Domain</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add</span>-apt-repository ppa:certbot/certbot</span><br><span class="line">apt install python-certbot-nginx</span><br><span class="line">ufw allow <span class="keyword">https</span></span><br><span class="line">ufw reload</span><br><span class="line">certbot <span class="comment">--nginx -d code-server.your-domain</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>code-server 3.9.3之后的版本在markdown preview 时滚轮不同步。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>linux</tag>
        <tag>code-server</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc 使用入门</title>
    <url>/2021/05/13/gcc-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="gcc-使用入门"><a href="#gcc-使用入门" class="headerlink" title="gcc 使用入门"></a>gcc 使用入门</h1><p>GCC是GUN Compiler Collection 的简称，除了编译程序之外，还包含其他的相关工具。</p>
<h4 id="程序的编译过程"><a href="#程序的编译过程" class="headerlink" title="程序的编译过程"></a>程序的编译过程</h4><p>对于GUN编译器来说，程序的编译要经过预处理、编译、汇编、连接四个阶段。</p>
<h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>输入c语言源文件 <strong>*.c</strong> ,输出中间文件 <strong>*.i</strong> ,该阶段主要处理源文件中的预处理指令</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gcc -E <span class="keyword">test</span>.c -o <span class="keyword">test</span>.i</span><br></pre></td></tr></table></figure>

<h6 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h6><p>输入中间文件 <strong>*.i</strong> ,输出汇编语言文件 <strong>*.s</strong> 。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gcc -S <span class="keyword">test</span>.i -o <span class="keyword">test</span>.s</span><br></pre></td></tr></table></figure>

<h6 id="汇编阶段"><a href="#汇编阶段" class="headerlink" title="汇编阶段"></a>汇编阶段</h6><p>输入汇编语言源 <strong>*.s</strong> ,输出机器语言文件 <strong>*.o</strong> 。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gcc -c <span class="keyword">test</span>.s -o <span class="keyword">test</span>.o</span><br></pre></td></tr></table></figure>

<h6 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h6><p>讲输入的机器代码文件 <strong>*.o</strong> 与其他的机器代码文件和库文件汇集成一个可执行的二进制代码文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gcc <span class="keyword">test</span>.o -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure>

<h4 id="常用命令编译选项"><a href="#常用命令编译选项" class="headerlink" title="常用命令编译选项"></a>常用命令编译选项</h4><h6 id="无选项编译链接"><a href="#无选项编译链接" class="headerlink" title="无选项编译链接"></a>无选项编译链接</h6><p>用法：gcc test.c<br>作用：将 test.c 预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认<br>输出为 a.out。</p>
<h6 id="选项-o"><a href="#选项-o" class="headerlink" title="选项 -o"></a>选项 -o</h6><p>用法：gcc test.c -o test<br>作用：将 test.c 预处理、汇编、编译并链接形成可执行文件 test。-o 选项用来指定输出文<br>件的文件名。</p>
<h6 id="选项-E"><a href="#选项-E" class="headerlink" title="选项 -E"></a>选项 -E</h6><p>用法：gcc -E test.c -o test.i<br>作用：将 test.c 预处理输出 test.i 文件。</p>
<h6 id="选项-S"><a href="#选项-S" class="headerlink" title="选项 -S"></a>选项 -S</h6><p>用法：gcc -S test.i<br>作用：将预处理输出文件 test.i 汇编成 test.s 文件。</p>
<h6 id="选项-c"><a href="#选项-c" class="headerlink" title="选项 -c"></a>选项 -c</h6><p>用法：gcc -c test.s<br>作用：将汇编输出文件 test.s 编译输出 test.o 文件。</p>
<h6 id="无选项链接"><a href="#无选项链接" class="headerlink" title="无选项链接"></a>无选项链接</h6><p>用法：gcc test.o -o test<br>作用：将编译输出文件 test.o 链接成最终可执行文件 test。</p>
<h6 id="选项-O"><a href="#选项-O" class="headerlink" title="选项-O"></a>选项-O</h6><p>用法：gcc -O1 test.c -o test<br>作用：使用编译优化级别 1 编译程序。级别为 1~3，级别越大优化效果越好，但编译时间越<br>长。</p>
<h4 id="多源文件的编译方法"><a href="#多源文件的编译方法" class="headerlink" title="多源文件的编译方法"></a>多源文件的编译方法</h4><p>如果有多个源文件，基本上有两种编译方法：<br>[假设有两个源文件为 test.c 和 testfun.c]</p>
<ol>
<li>多个文件一起编译<br>用法：<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gcc testfun.c <span class="keyword">test</span>.c -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure>
作用：将 testfun.c 和 test.c 分别编译后链接成 test 可执行文件。     </li>
<li>分别编译各个源文件，之后对编译后输出的目标文件链接。<br>用法：<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gcc -c testfun.c //将 testfun.c 编译成 testfun.o</span><br><span class="line">gcc -c <span class="keyword">test</span>.c //将 <span class="keyword">test</span>.c 编译成 <span class="keyword">test</span>.o</span><br><span class="line">gcc -o testfun.o <span class="keyword">test</span>.o -o <span class="keyword">test</span> //将 testfun.o 和 <span class="keyword">test</span>.o 链接成 <span class="keyword">test</span></span><br></pre></td></tr></table></figure>
以上两种方法相比较，第一中方法编译时需要所有文件重新编译，而第二种方法可以只<br>重新编译修改的文件，未修改的文件不用重新编译。</li>
</ol>
]]></content>
      <categories>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>git的使用</title>
    <url>/2021/03/23/git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h1><p><a href="https://www.runoob.com/w3cnote/git-guide.html">菜鸟教程</a></p>
<h2 id="创建git库"><a href="#创建git库" class="headerlink" title="创建git库"></a>创建git库</h2><h4 id="初始化git"><a href="#初始化git" class="headerlink" title="初始化git"></a>初始化git</h4><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> gittest</span><br><span class="line"><span class="built_in">cd</span> gittest</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<h4 id="将要添加的文件加入git管理"><a href="#将要添加的文件加入git管理" class="headerlink" title="将要添加的文件加入git管理"></a>将要添加的文件加入git管理</h4><p>  <strong>add 从工作区到暂存区</strong> </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git <span class="builtin-name">add</span> [filename]</span><br></pre></td></tr></table></figure>
<p>或者将目录下所有文件都加入</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git <span class="builtin-name">add</span> .</span><br></pre></td></tr></table></figure>
<h4 id="自定义所要添加的文件"><a href="#自定义所要添加的文件" class="headerlink" title="自定义所要添加的文件"></a>自定义所要添加的文件</h4><p>总是手动add每一个太麻烦了，但总有些不希望添加进去的，可以这样。</p>
<ul>
<li>创建一个文件名为的文件<blockquote>
<p>.gitignore</p>
</blockquote>
</li>
<li>文件内容为<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">file</span><br><span class="line">.*</span><br><span class="line"><span class="addition">!.gitignore</span></span><br><span class="line"><span class="addition">!file1</span></span><br></pre></td></tr></table></figure></li>
<li>这表示名为file的文件要加进去</li>
<li>所有文件都要加进去</li>
<li>忽略 .gitignore</li>
<li>忽略 file1</li>
</ul>
<h4 id="提交到仓库"><a href="#提交到仓库" class="headerlink" title="提交到仓库"></a>提交到仓库</h4><p><strong>commit 将暂存区提交到仓库</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m<span class="meta"> [提交描述]</span></span><br></pre></td></tr></table></figure>
<p> <strong>每次commit之前都要add所要进行管理的文件</strong> </p>
<h4 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h4><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">status</span></span><br><span class="line">简略版</span><br><span class="line">git <span class="keyword">status</span> -s</span><br></pre></td></tr></table></figure>
<h4 id="查看文件更改情况"><a href="#查看文件更改情况" class="headerlink" title="查看文件更改情况"></a>查看文件更改情况</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> diff<span class="meta"> [filename]</span></span><br></pre></td></tr></table></figure>

<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p><strong>在commit之后后悔了</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> </span><br><span class="line">git <span class="built_in">log</span> --oneline <span class="comment">//简略版</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用git log 查看之前提交的记录，记下回退的版本号commit id 输入</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard [commit id]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>注意只有在head指向的版本之前的,</strong> 切换版本到当前版本之后的 输入</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">ref</span>log</span><br></pre></td></tr></table></figure>
<h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4></li>
<li><p>丢弃对工作区的修改 add之前</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout <span class="comment">-- [filename]</span></span><br></pre></td></tr></table></figure></li>
<li><p><em>checkout就是用版本库里的版本替换工作区的版本</em>*</p>
</li>
<li><p>丢弃对暂存区的修改 add之后 commit之前</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">git <span class="meta">reset</span> HEAD [<span class="meta">filename</span>]</span><br></pre></td></tr></table></figure>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h4 id="创建ssh-key"><a href="#创建ssh-key" class="headerlink" title="创建ssh key"></a>创建ssh key</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">&quot;myemail@163.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>在用户目录里找到id_rsa.pub,将里面的数据复制到GitHub中,这样就可以从本地电脑推送到GitHub中了.</p>
<h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">add</span> repo<span class="number">1</span> git<span class="title">@github.com</span>:yishuilingbo/gittest.git</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="查看本地所有仓库"><a href="#查看本地所有仓库" class="headerlink" title="查看本地所有仓库"></a>查看本地所有仓库</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git remote -v</span></span><br></pre></td></tr></table></figure>
<h4 id="推送到远程库"><a href="#推送到远程库" class="headerlink" title="推送到远程库"></a>推送到远程库</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">git push -u <span class="selector-attr">[库名]</span> <span class="selector-attr">[分支名]</span></span><br></pre></td></tr></table></figure></li>
<li><p>加上了-u参数，Git不但会把本地的分支内容推送的远程新的分支，还会把本地的分支和远程的分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<h4 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库"></a>删除远程库</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> remote rm<span class="meta"> [库名]</span></span><br></pre></td></tr></table></figure>
<h4 id="克隆库"><a href="#克隆库" class="headerlink" title="克隆库"></a>克隆库</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@github.com:yishuilingbo/gittest.git</span><br><span class="line">cd [库名]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h4 id="建立新的分支"><a href="#建立新的分支" class="headerlink" title="建立新的分支"></a>建立新的分支</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">branch </span>[<span class="keyword">branchname]</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure>
<h4 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git branch</span></span><br></pre></td></tr></table></figure>
<h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">switch </span><span class="keyword">branch </span>[<span class="keyword">branchname]</span></span><br></pre></td></tr></table></figure>
<h4 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h4><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">switch</span> -<span class="keyword">c</span> [branchname]</span><br></pre></td></tr></table></figure>
<h4 id="合并分支到当前分支"><a href="#合并分支到当前分支" class="headerlink" title="合并分支到当前分支"></a>合并分支到当前分支</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> merge<span class="meta"> [来源分支名]</span></span><br></pre></td></tr></table></figure>
<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> branch -d<span class="meta"> [branchname]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>若该分支没有被合并过，以下强制删除<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> branch -D<span class="meta"> [branchname]</span></span><br></pre></td></tr></table></figure>
<h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4></li>
<li>当两个不同的分支对同一对象进行修改并提交之后会发生 merge conflict<br>此时需要查看冲突文件手动解决冲突。<h4 id="查看分支合并图"><a href="#查看分支合并图" class="headerlink" title="查看分支合并图"></a>查看分支合并图</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--graph</span></span><br></pre></td></tr></table></figure>
简洁版<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--graph --pretty=oneline --abbrev-commit</span></span><br></pre></td></tr></table></figure>
<h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4>通常合并分支的时候，git会采用<strong>fast forward</strong>模式。这种模式下，git只是把分支指针向前移动，此时，删除掉分支之后将会丢失分支信息。若要强制禁止<strong>fast forward</strong>,git就会在merge的时候生成一个新的commit,这样即使删除该分支，也可以从log上查看历史信息。</li>
<li>强制禁止<strong>fast forward</strong> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">git merge --no-ff -m <span class="selector-attr">[commit 描述]</span> <span class="selector-attr">[来源分支名]</span></span><br></pre></td></tr></table></figure>
<h4 id="修复main分支上的bug流程"><a href="#修复main分支上的bug流程" class="headerlink" title="修复main分支上的bug流程"></a>修复main分支上的bug流程</h4></li>
</ul>
<ol>
<li>当前在dev分支，先保存工作现场<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git stash</span></span><br></pre></td></tr></table></figure></li>
<li>切换到main分支，并建立新的分支bugfix</li>
<li>在新的分支上修改bug,然后提交后合并到main   产生一个commit id fixbug</li>
<li>回到dev分支，回复现场<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git stash pop  <span class="regexp">//</span>这将删除这条stash</span><br><span class="line">或者</span><br><span class="line">git stash list <span class="regexp">//</span>查看stash list</span><br><span class="line">git stash apply stash@&#123;<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>将修复的信息复制到当前dev分支<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> cherry-pick<span class="meta"> [commit id]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="多人合作冲突"><a href="#多人合作冲突" class="headerlink" title="多人合作冲突"></a>多人合作冲突</h4><ol>
<li>pull 下来之后手动解决冲突在再合并push</li>
</ol>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ol>
<li>切换到要创建标签的分支上<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">[标签名]</span></span><br></pre></td></tr></table></figure>
默认标签打在最新的commit上面</li>
<li>对历史commit打标签<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=oneline --abbrev-commit  //列出历史commit</span></span><br><span class="line">git tag [tag] [commit <span class="built_in">id</span>]</span><br></pre></td></tr></table></figure></li>
<li>指定标签信息<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-a</span> [<span class="keyword">tag</span>] -m [<span class="literal">inf</span>o] [commit id]</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>标签总是和对应的commit挂钩</strong></p>
<h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git tag -d [tag]</span><br></pre></td></tr></table></figure>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>标签只存储到本地，不会自动推送到远程，可以这样推送到远程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git push [库名] [tag]</span><br><span class="line">git push [库名] --tags  <span class="comment">//一次性推送所有标签</span></span><br></pre></td></tr></table></figure>
<h4 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git push [库名] :ref/tags/[tag]</span><br></pre></td></tr></table></figure>
<h2 id="git报错"><a href="#git报错" class="headerlink" title="git报错"></a>git报错</h2><h4 id="refusing-to-merge-unrelated-histories"><a href="#refusing-to-merge-unrelated-histories" class="headerlink" title="refusing to merge unrelated histories"></a>refusing to merge unrelated histories</h4><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><ul>
<li>首先再github上创建一个仓库</li>
<li>在本地初始化一个仓库。</li>
<li>添加远程仓库</li>
<li>git push -u ge main</li>
<li>报错为<blockquote>
<p>$ git push -u ge main<br>To github.com:yishuilingbo/XYY-Game-Engine.git<br>! [rejected]        main -&gt; main (non-fast-forward)<br>error: failed to push some refs to ‘github.com:yishuilingbo/XYY-Game-Engine.git’<br>hint: Updates were rejected because the tip of your current branch is behind<br>hint: its remote counterpart. Integrate the remote changes (e.g.<br>hint: ‘git pull …’) before pushing again.</p>
</blockquote>
</li>
</ul>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li>本地仓库和远程仓库实际上是独立的两个仓库。假如之前是直接clone的方式在本地建立起远程github仓库的克隆本地仓库就不会有这问题了。<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> pull <span class="selector-attr">[库名]</span> <span class="selector-attr">[分支名]</span> --allow-unrelated-histories</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="接着解决冲突然后-push即可"><a href="#接着解决冲突然后-push即可" class="headerlink" title="接着解决冲突然后 push即可"></a>接着解决冲突然后 push即可</h4></li>
</ul>
<h2 id="多仓库-multiple-ssh-keys-on-one-computer"><a href="#多仓库-multiple-ssh-keys-on-one-computer" class="headerlink" title="多仓库 multiple ssh keys on one computer"></a>多仓库 multiple ssh keys on one computer</h2><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>生成ssh key ,并给生成的文件使用绝对路径特定地命名。</li>
<li>在 .ssh 目录下新建config文件，内容为<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#gittest</span></span><br><span class="line">Host gittest.github.com</span><br><span class="line">	HostName github.com</span><br><span class="line">	<span class="keyword">User</span> <span class="title">git</span></span><br><span class="line">	IdentityFile ~/.ssh/id_rsa_gittest</span><br><span class="line">	IdentitiesOnly yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#coebase</span></span><br><span class="line">Host codebase.github.com</span><br><span class="line">	HostName github.com</span><br><span class="line">	<span class="keyword">User</span> <span class="title">git</span></span><br><span class="line">	IdentityFile ~/.ssh/id_rsa_codebase</span><br><span class="line">	IdentitiesOnly yes</span><br><span class="line"></span><br><span class="line"><span class="comment">#coebases</span></span><br><span class="line">Host blog.github.com</span><br><span class="line">	HostName github.com</span><br><span class="line">	<span class="keyword">User</span> <span class="title">git</span></span><br><span class="line">	IdentityFile ~/.ssh/id_rsa_codebase</span><br><span class="line">	IdentitiesOnly yes</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>修改本地仓库地config中的url<br>eg:<br>gittest地config本来为<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">	url = git<span class="variable">@github</span>.<span class="symbol">com:</span>yishuilingbo/gittest.git</span><br><span class="line">	fetch = +refs/heads/*<span class="symbol">:refs/remotes/origin/*</span></span><br></pre></td></tr></table></figure>
修改为：<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">	url = git<span class="variable">@gittest</span>.<span class="symbol">github.com:</span>yishuilingbo/gittest.git</span><br><span class="line">	fetch = +refs/heads/*<span class="symbol">:refs/remotes/origin/*</span></span><br></pre></td></tr></table></figure>
即添加上gittest.</li>
<li>在GitHub上的仓库中添加刚刚生成的deploy key</li>
</ol>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>即对于不同的仓库使用不同的key,并且使用别名来区分不同的仓库。<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4></li>
<li><a href="https://gist.github.com/jexchan/2351996">https://gist.github.com/jexchan/2351996</a></li>
</ul>
<h2 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">exec ssh-agent bash</span><br><span class="line">ssh-add ~<span class="regexp">/.ssh/i</span>d_rsa_cuiwenyao</span><br><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure>
<h4 id="多账户"><a href="#多账户" class="headerlink" title="多账户"></a>多账户</h4><p>自己只需要本地保存自己账户的ssh key即可，按照<a href="https://www.jianshu.com/p/ea7f5def28f2">这里</a>的进行多账户配置。</p>
<p>注意，在windows下，这个认证配置好像是暂时的，关闭git之后就失效了，所以需要每次重新配置，即重新使用：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">exec ssh-agent bash</span><br><span class="line">ssh-add ~<span class="regexp">/.ssh/i</span>d_rsa_cuiwenyao</span><br><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure>




<h1 id="github-使用"><a href="#github-使用" class="headerlink" title="github 使用"></a>github 使用</h1><h2 id="初始化git信息"><a href="#初始化git信息" class="headerlink" title="初始化git信息"></a>初始化git信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name cuiwenyao</span><br><span class="line">$ git config --global user.email yao1970099540@163.com</span><br></pre></td></tr></table></figure>

<h2 id="连接到自己的账户"><a href="#连接到自己的账户" class="headerlink" title="连接到自己的账户"></a>连接到自己的账户</h2><h3 id="ssh-key"><a href="#ssh-key" class="headerlink" title="ssh key"></a>ssh key</h3><p>使用以下命令生成ssh key 并命名为 id_rsa_cuiwenyao_github</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;yao1970099540@163.com&quot;</span> -f ~/.ssh/id_rsa_cuiwenyao_github</span><br></pre></td></tr></table></figure>

<p>不想为这个ssh key生成密码的话就一直回车</p>
<p>这会在 ~/.ssh/目录下生成ssh key</p>
<pre><code>id_rsa_cuiwenyao
id_rsa_cuiwenyao.pub
</code></pre>
<p>将id_rsa_cuiwenyao.pub添加到github中的用户setting 中的ssh key 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span> ssh-agent bash</span><br><span class="line">ssh-add ~/.ssh/id_rsa_cuiwenyao</span><br></pre></td></tr></table></figure>

<p>将使用id_rsa_cuiwenyao进行验证，只有这样才可以进行 push 等操作</p>
<p>自己只需要本地保存自己账户的ssh key即可，按照<a href="https://www.jianshu.com/p/ea7f5def28f2">这里</a>的进行多账户配置。</p>
<p>windows中这个权限确认状态好像只是临时的，需要每一次打开git时重新使用以上命令进行配置。</p>
<p>验证配置是否成功：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh -T <span class="symbol">git@</span>github.com</span><br></pre></td></tr></table></figure>

<h3 id="multy-account-and-multy-ssh-keys"><a href="#multy-account-and-multy-ssh-keys" class="headerlink" title="multy account and multy ssh keys"></a>multy account and multy ssh keys</h3><p>除了上述的额命令外，还需要在 ./ssh 下写一个 config 文件</p>
<p>内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cuwenyao</span></span><br><span class="line">Host github</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_cuiwenyao</span><br><span class="line">    user git</span><br><span class="line">Host gitee</span><br><span class="line">    HostName gitee.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_cuiwenyao_gitee</span><br><span class="line">    user git</span><br></pre></td></tr></table></figure>

<h2 id="协同开发"><a href="#协同开发" class="headerlink" title="协同开发"></a>协同开发</h2><h4 id="fork-别人的项目"><a href="#fork-别人的项目" class="headerlink" title="fork 别人的项目"></a>fork 别人的项目</h4><p>别人的仓库： Repo_A<br>fork之后到自己的仓库中    Repo_fork<br>修改后push到自己的仓库 Repo_fork 中<br>发起一个 pull request<br>仓库拥有者接受 pull request</p>
]]></content>
      <categories>
        <category>使用</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h1 id="hexo-quick-start"><a href="#hexo-quick-start" class="headerlink" title="hexo quick start"></a>hexo quick start</h1><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>hello_world</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的使用</title>
    <url>/2021/03/22/hexo%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="hello-hexo"><a href="#hello-hexo" class="headerlink" title="hello hexo"></a>hello hexo</h1><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><ul>
<li>安装git</li>
<li>安装Node.js<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2></li>
<li>window cmd 下输入 npm install -g hexo-cli<h2 id="使用hexo"><a href="#使用hexo" class="headerlink" title="使用hexo"></a>使用hexo</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hexo init &lt;foldername&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="安装server与deployer"><a href="#安装server与deployer" class="headerlink" title="安装server与deployer"></a>安装server与deployer</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">npm install hexo-<span class="keyword">server</span> <span class="comment">--save</span></span><br><span class="line">npm install hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">hexo new <span class="regexp">//</span>生成文章</span><br><span class="line">hexo c  <span class="regexp">//</span>清理</span><br><span class="line">hexo g  <span class="regexp">//</span>生成</span><br><span class="line">hexo s  <span class="regexp">//</span>启动本地服务</span><br><span class="line">hexo d  <span class="regexp">//</span>部署</span><br><span class="line">简单地使用为 hexo g -d</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="以上就是hexo的基础使用了。"><a href="#以上就是hexo的基础使用了。" class="headerlink" title="以上就是hexo的基础使用了。"></a>以上就是hexo的基础使用了。</h4><hr>
<h2 id="配置github-page"><a href="#配置github-page" class="headerlink" title="配置github page"></a>配置github page</h2><ul>
<li>建立一个GitHub仓库</li>
<li>将仓库配置为GitHub page</li>
<li>输入自己的域名 cuimouren.cn</li>
</ul>
<h2 id="解析自己的域名到GitHub-page"><a href="#解析自己的域名到GitHub-page" class="headerlink" title="解析自己的域名到GitHub page"></a>解析自己的域名到GitHub page</h2><h4 id="添加如下的域名解析记录"><a href="#添加如下的域名解析记录" class="headerlink" title="添加如下的域名解析记录"></a>添加如下的域名解析记录</h4><ul>
<li>主机记录： @</li>
<li>记录类型： CNAME</li>
<li>线路类型： 默认</li>
<li>记录值：     yishuilingbo.github.io  即GitHub page分配的网址</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr>
<h4 id="到此就完成了框架性的工作"><a href="#到此就完成了框架性的工作" class="headerlink" title="到此就完成了框架性的工作"></a>到此就完成了框架性的工作</h4><hr>
<h2 id="‘菜’的坑"><a href="#‘菜’的坑" class="headerlink" title="‘菜’的坑"></a>‘<strong>菜’的坑</strong></h2><h3 id="注意得在cmd环境下进行操作，powershell不行。"><a href="#注意得在cmd环境下进行操作，powershell不行。" class="headerlink" title="注意得在cmd环境下进行操作，powershell不行。"></a>注意得在cmd环境下进行操作，powershell不行。</h3><h3 id="Hexo在部署到Github后CNAME文件会消失或改变的解决方法"><a href="#Hexo在部署到Github后CNAME文件会消失或改变的解决方法" class="headerlink" title="Hexo在部署到Github后CNAME文件会消失或改变的解决方法"></a>Hexo在部署到Github后CNAME文件会消失或改变的解决方法</h3><h4 id="问题经过"><a href="#问题经过" class="headerlink" title="问题经过:"></a>问题经过:</h4><ul>
<li><p>在转移网站后,在 Github网页上修改CNAME文件中指向的域名后,重新部署Hexo时发现CNAME指向的域名是之前的网站,而没有编程修改后的域名.排查后发现:</p>
</li>
<li><p>Hexo在Github上部署后,如果配置了一个自定义域名时,会自动在项目仓库根目录想新建一个CNAME文件,但是重新部署后CNAME会消失或者变成修改之前的状态,导致需要再次手动修改.</p>
</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h4><ul>
<li>直接修改 hexo目录 下 source 文件夹内的CNAME文件的内容,用编辑器打开,第一行输入需要配置的域名.这样在部署的时候CNAME 文件会自动部署到Github.不用再次手动修改.</li>
</ul>
<h3 id="注意配置git的username-与-email"><a href="#注意配置git的username-与-email" class="headerlink" title="注意配置git的username 与 email"></a>注意配置git的username 与 email</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">&quot;name&quot;</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">&quot;email@gmail.com&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="git网络问题"><a href="#git网络问题" class="headerlink" title="git网络问题"></a>git网络问题</h3><h4 id="设置git的代理"><a href="#设置git的代理" class="headerlink" title="设置git的代理"></a>设置git的代理</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">config</span> <span class="comment">--global http.proxy 127.0.0.1:7890</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="deployer-not-found"><a href="#deployer-not-found" class="headerlink" title="deployer not found"></a>deployer not found</h3><ul>
<li>npm install hexo-deployer-git –save</li>
</ul>
<h3 id="permission-denied"><a href="#permission-denied" class="headerlink" title="permission denied"></a>permission denied</h3><ul>
<li>hexo 只支持单用户凭证，所以需要去控制面板中更改git:<a href="https://github.com/">https://github.com</a> 的用户凭证即可。使用哪一个github用户时就更新成哪一个。</li>
</ul>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>leedcode 初级算法 链表</title>
    <url>/2021/06/18/leedcode-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="leedcode-初级算法-链表"><a href="#leedcode-初级算法-链表" class="headerlink" title="leedcode 初级算法 链表"></a>leedcode 初级算法 链表</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2t7vj/">链接</a></p>
<h4 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h4><h6 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h6><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。</p>
<h6 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h6><p>懒得解析了</p>
<h4 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h4><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>进阶：你能尝试使用一趟扫描实现吗？</p>
<h6 id="题目解析-方法一"><a href="#题目解析-方法一" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>为头节点head建立一个前驱结点heeaad,这样就不怕只有head一个结点的情况了。先遍历一遍链表得到链表的长度，再从heeaad遍历链表，r-&gt;next，指向的是当前应该删除的结点。记住不要让r指向当前应该删除的结点，不然含需要一个r的前驱节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head)</span><br><span class="line">        &#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">getLength</span>(head);</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        n = length + <span class="number">1</span> - n;                       <span class="comment">//正数</span></span><br><span class="line">        ListNode *heeaad = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head); <span class="comment">//声明一个指向head结点的结点，值为零</span></span><br><span class="line">        ListNode *r = <span class="keyword">new</span> ListNode;</span><br><span class="line">        r = heeaad;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到当前要删除的为 r-&gt;next</span></span><br><span class="line">        r-&gt;next = r-&gt;next-&gt;next;</span><br><span class="line">        ListNode *ans = heeaad-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> heeaad;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二"><a href="#题目解析-方法二" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>使用栈，向将链表中的所有数据先存起来，然后依次从前面插入。</p>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><h6 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h6><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<h6 id="题目解析-方法一-1"><a href="#题目解析-方法一-1" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>遍历一遍，从左到右依次设置三个指针t1 t2 t3。<br>每一个循环中的装填都是 t2已经设置好指向，t2需要改变指向到t1，t3指向下一轮循环需要改变的结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *t1 = <span class="literal">NULL</span>, *t2 = <span class="literal">NULL</span>, *t3 = <span class="literal">NULL</span>;</span><br><span class="line">    t1 = head;</span><br><span class="line">    t2 = head-&gt;next;</span><br><span class="line">    t1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        t3 = t2-&gt;next;</span><br><span class="line">        t2-&gt;next = t1;</span><br><span class="line">        <span class="keyword">if</span> (t3 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        t1 = t2;</span><br><span class="line">        t2 = t3;</span><br><span class="line">        t3 = t3-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二-1"><a href="#题目解析-方法二-1" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">res</span> =</span> <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h4><h6 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h6><p>合并两个递增链表</p>
<h6 id="题目解析-方法一-2"><a href="#题目解析-方法一-2" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>迭代，先设立一个伪头节点，比较l1 l2的大小，将游标指向小的，并后移对应链表l1或l2，直到一个为空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">mergeTwoLists</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">res</span> =</span> (struct ListNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct ListNode));</span><br><span class="line">    res-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">t</span> =</span> res;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t-&gt;next = l2;</span><br><span class="line">            <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t-&gt;next = l1;</span><br><span class="line">            <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            t-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            t-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二-2"><a href="#题目解析-方法二-2" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">mergeTwoLists</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l2-&gt;next, l1);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h4><h6 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h6><p>判断一个链表是否是回文链表</p>
<h6 id="题目解析-方法一-3"><a href="#题目解析-方法一-3" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>将链表从中间分为两部分，将其中一部分进行反转，顺序比较是否相等。</p>
<p>这个解法和力扣官方解法的快慢指针相同。</p>
<p>在并发环境中这个解法需要进行链表访问的锁定，因为在访问中会进行更改链表。</p>
<p>在程序的最后还需要将链表复原。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">res</span> =</span> <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">h</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (h)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    count /= <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l1</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l2</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count--;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    l2 = <span class="built_in">reverseList</span>(l2);</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val != l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二-3"><a href="#题目解析-方法二-3" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>复制到数组里面，这个方法太幼稚了。略。</p>
<h6 id="题目解析-方法三"><a href="#题目解析-方法三" class="headerlink" title="题目解析 方法三"></a>题目解析 方法三</h6><p>递归，使用后序遍历的递归。由于递归天然具有从后向前的特性，所以用来从后向前遍历是再好不过的。在函数外设置一个变量用来指示从前向后遍历进行并比较的结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">now</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(head-&gt;next))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val != now-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now = now-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    now = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><h6 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h6><p>判断一个链表是否有环，即遍历永远不会结束。</p>
<h6 id="题目解析-方法一-4"><a href="#题目解析-方法一-4" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>这是一个投机的方法。根据是系统分配内存是从小开始分配。不可以在真实环境中使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next &lt;= head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二-4"><a href="#题目解析-方法二-4" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>使用哈希表记录每一次遍历到的结点地址。遍历时判断是否已经遍历过。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_set&lt;struct ListNode *&gt; set;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(set.<span class="built_in">count</span>(head))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        set.<span class="built_in">insert</span>(head);</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法三-1"><a href="#题目解析-方法三-1" class="headerlink" title="题目解析 方法三"></a>题目解析 方法三</h6><p>快慢指针</p>
<p>使用两个指针 兔子和乌龟 兔子一次走两步，乌龟一次走一步，直到结尾。若相遇说明有环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tu</span>, *<span class="title">gui</span>;</span></span><br><span class="line">    gui = head;</span><br><span class="line">    tu = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (tu &amp;&amp; gui)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tu == gui)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        gui = gui-&gt;next;</span><br><span class="line">        tu = tu-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (tu == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tu = tu-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>算法</category>
        <category>leedcode</category>
      </categories>
      <tags>
        <tag>leedcode</tag>
        <tag>初级算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>linux base</title>
    <url>/2021/04/19/linux-base/</url>
    <content><![CDATA[<h1 id="linux-base"><a href="#linux-base" class="headerlink" title="linux base"></a>linux base</h1><h4 id="centos6-定时重启"><a href="#centos6-定时重启" class="headerlink" title="centos6 定时重启"></a>centos6 定时重启</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>crontab</span><br><span class="line">按照提示添加 </span><br><span class="line"><span class="number">00</span> <span class="number">06</span> * * * root reboot</span><br><span class="line">载入内存</span><br><span class="line">crontab <span class="regexp">/etc/</span>crontab</span><br><span class="line">启动服务并设置开机自启动</span><br><span class="line">systemctl enable crond.service</span><br><span class="line">systemctl restart crond.service</span><br><span class="line">查看定时配置</span><br><span class="line">crontab -l</span><br><span class="line">查看系统启动记录</span><br><span class="line">last reboot</span><br><span class="line">who -b</span><br></pre></td></tr></table></figure>
<h4 id="ubuntu-设置root-ssh-登录"><a href="#ubuntu-设置root-ssh-登录" class="headerlink" title="ubuntu 设置root ssh 登录"></a>ubuntu 设置root ssh 登录</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">重置 root 的密码</span><br><span class="line">sudo passwd root</span><br><span class="line">su</span><br><span class="line">vi /etc/ssh/sshd_config </span><br><span class="line">将 PermitRootLogin 参数修改为 <span class="literal">yes</span>。</span><br><span class="line">将 PasswordAuthentication 参数修改为 <span class="literal">yes</span>。</span><br><span class="line">若 sshd_config 配置文件中无此配置项，则添加 PasswordAuthentication <span class="literal">yes</span> 项即可。</span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>
<h4 id="远程复制"><a href="#远程复制" class="headerlink" title="远程复制"></a>远程复制</h4><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul>
<li>问题描述：<br>安装postgresql开发环境的时候，配置环境变量，写入export PGHOME到 /etc/profile中，由于需要重启机器才能使修改全面生效；<br>在不重启电脑的情况下，每次打开终端都得source一下才能生效。如何才能立刻生效呢？</li>
</ul>
<p>解决方法：由于每次启动终端的时候，都会执行 /etc/bashrc ，所以可以把source /etc/profile 命令<br>写入到 /etc/bashrc 文件中，实现环境变量立刻全面生效的效果。</p>
<h4 id="忘记root密码"><a href="#忘记root密码" class="headerlink" title="忘记root密码"></a>忘记root密码</h4><p>按住shift键reboot进入grub,选择advanced option，进入recovery mode, 选择root drop to root shell prompt</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux command</title>
    <url>/2021/04/21/linux-journey/</url>
    <content><![CDATA[<h1 id="linux-command"><a href="#linux-command" class="headerlink" title="linux command"></a>linux command</h1><h2 id="command-line"><a href="#command-line" class="headerlink" title="command line"></a>command line</h2><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><ul>
<li>let’s start with a siple command, echo. The command just prints out the arguments to the display.<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello,world!</span><br></pre></td></tr></table></figure>
<h4 id="pwd-print-working-directory"><a href="#pwd-print-working-directory" class="headerlink" title="pwd (print working directory)"></a>pwd (print working directory)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>
<h4 id="cd-change-directory"><a href="#cd-change-directory" class="headerlink" title="cd (change directory)"></a>cd (change directory)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/<span class="built_in">test</span></span><br><span class="line"><span class="built_in">cd</span> test2</span><br></pre></td></tr></table></figure></li>
<li>. ( current directory)</li>
<li>.. (parent directory)</li>
<li>~ (home directory)</li>
<li>- (previous directory)</li>
</ul>
<h4 id="ls-list-directories"><a href="#ls-list-directories" class="headerlink" title="ls (list directories)"></a>ls (list directories)</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> </span><br><span class="line"><span class="keyword">ls</span> /home</span><br><span class="line"><span class="keyword">ls</span> -<span class="keyword">a</span>   show <span class="keyword">all</span> of the <span class="keyword">files</span> include the <span class="keyword">files</span> which are hidden.</span><br><span class="line"><span class="keyword">ls</span> -<span class="keyword">l</span>   <span class="keyword">l</span> means long, this <span class="keyword">command</span> will show the <span class="keyword">files</span> with their detile.</span><br><span class="line"><span class="keyword">ls</span> -<span class="keyword">la</span>  show <span class="keyword">all</span> the <span class="keyword">files</span> with their detile.</span><br><span class="line"><span class="keyword">ls</span> -R   recursively <span class="keyword">list</span> directory contents.</span><br><span class="line"><span class="keyword">ls</span> -r   <span class="built_in">reverse</span> order <span class="keyword">while</span> sorting.</span><br><span class="line"><span class="keyword">ls</span> -t   <span class="keyword">sort</span> by modification time, newest <span class="keyword">first</span>.</span><br></pre></td></tr></table></figure>

<h4 id="touch-create-a-filw"><a href="#touch-create-a-filw" class="headerlink" title="touch (create a filw)"></a>touch (create a filw)</h4><ul>
<li>touch allows you to create new empty files.<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">touch myfile</span></span><br></pre></td></tr></table></figure></li>
<li>touch is also used to change timestamps on existing files and directories. <figure class="highlight irpf90"><table><tr><td class="code"><pre><span class="line"><span class="keyword">touch</span> myfile</span><br><span class="line"><span class="keyword">touch</span> mydirectory</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="file-show-the-type-of-the-file’s-contents"><a href="#file-show-the-type-of-the-file’s-contents" class="headerlink" title="file (show the type of the file’s contents)"></a>file (show the type of the file’s contents)</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">file</span> myfile</span><br></pre></td></tr></table></figure>

<h4 id="cat-show-the-content-of-files"><a href="#cat-show-the-content-of-files" class="headerlink" title="cat (show the content of files)"></a>cat (show the content of files)</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cat</span> file<span class="number">1</span> file<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="less-show-less-of-a-file"><a href="#less-show-less-of-a-file" class="headerlink" title="less (show less of a file)"></a>less (show less of a file)</h4><ul>
<li>if you are viewing text files larger than a simple output.(which means it is too big to view on your screen.) you can use less to open it, that can make it easy to view the file.<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">wget</span> linuxqq_<span class="number">2</span>.<span class="number">0</span>.<span class="number">0</span>-b<span class="number">2</span>-<span class="number">1089</span>_x<span class="number">86</span>_<span class="number">64</span>.sh</span><br><span class="line"><span class="attribute">mv</span> linuxqq_<span class="number">2</span>.<span class="number">0</span>.<span class="number">0</span>-b<span class="number">2</span>-<span class="number">1089</span>_x<span class="number">86</span>_<span class="number">64</span>.sh qq</span><br><span class="line"><span class="attribute">less</span> qq</span><br></pre></td></tr></table></figure></li>
<li>the text is displayed in a paged manner, so you can navigate through a text file page by page.<blockquote>
<p>q  quit out of less and back to your shell<br>Page up, Page down, up and down Navigate.<br>g move to the beginning of the text file<br>G move to the end of the file<br>h help<br>/search search the content behind /</p>
</blockquote>
</li>
</ul>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">less <span class="keyword">qq</span></span><br><span class="line">/<span class="keyword">qq</span></span><br></pre></td></tr></table></figure>

<h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">history   <span class="keyword">show</span> commands you have typed</span><br><span class="line">ctrl-R 	  </span><br><span class="line"><span class="keyword">clear</span> 	  <span class="keyword">clear</span> the <span class="keyword">screen</span></span><br></pre></td></tr></table></figure>
<h4 id="cp-copy"><a href="#cp-copy" class="headerlink" title="cp (copy)"></a>cp (copy)</h4><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">cp myfile <span class="regexp">/home/</span>files</span><br><span class="line">cp *.jpg <span class="regexp">/home/</span>jpgs</span><br><span class="line">cp -r directoryone<span class="regexp">/ /</span>home/document   <span class="keyword">copy</span> the directory</span><br><span class="line">cp -i my <span class="keyword">file</span> <span class="regexp">/home/</span>files   prompt you before overwriting a same-name-<span class="keyword">file</span>.</span><br></pre></td></tr></table></figure>
<h4 id="mv-move"><a href="#mv-move" class="headerlink" title="mv (move)"></a>mv (move)</h4><ul>
<li>rename file or directory<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mv</span> a b</span><br><span class="line"><span class="attribute">mv</span> directory<span class="number">1</span> directory<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li>move files and directories  to somewhere<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mv</span> a b directory<span class="number">1</span> directory<span class="number">2</span> /home</span><br></pre></td></tr></table></figure></li>
<li>wanna a prompt<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mv</span> -i directory<span class="number">1</span> directory<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li>make a backup of the file which is going to be overwritten.<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">mv b <span class="keyword">a</span></span><br><span class="line"><span class="keyword">the</span> previous <span class="built_in">file</span> <span class="keyword">a</span> will be back up <span class="keyword">and</span> renamed <span class="keyword">as</span> ~<span class="keyword">a</span></span><br></pre></td></tr></table></figure>
<h4 id="mkdir-make-a-directory"><a href="#mkdir-make-a-directory" class="headerlink" title="mkdir (make a directory)"></a>mkdir (make a directory)</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> <span class="keyword">one</span> <span class="keyword">two</span></span><br></pre></td></tr></table></figure></li>
<li>wanna to create subdirectories?<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> -p <span class="keyword">one</span>/<span class="keyword">one</span> <span class="keyword">two</span>/tow</span><br></pre></td></tr></table></figure>
<h4 id="rm-remove"><a href="#rm-remove" class="headerlink" title="rm (remove)"></a>rm (remove)</h4></li>
<li>delete a file. the file being deleted will not been pushing into a trash can, so be careful about rm. <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rm filea</span></span><br></pre></td></tr></table></figure></li>
<li>force to delete <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> <span class="operator">-f</span> filea</span><br></pre></td></tr></table></figure></li>
<li>wanna a prompt<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">rm -<span class="selector-tag">i</span> filea</span><br></pre></td></tr></table></figure></li>
<li>delete directories<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">rm -r <span class="built_in">directory</span> </span><br><span class="line"><span class="keyword">or</span> </span><br><span class="line"><span class="built_in">rmdir</span> <span class="built_in">directory</span></span><br></pre></td></tr></table></figure>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">find /home -name qq</span><br></pre></td></tr></table></figure></li>
<li>find a directory<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> /home -<span class="built_in">type</span> d -<span class="built_in">name</span> mydirectory</span><br></pre></td></tr></table></figure>
<h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> <span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">man</span> <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<h4 id="whatis-briefly-describe-a-file"><a href="#whatis-briefly-describe-a-file" class="headerlink" title="whatis (briefly describe a file)"></a>whatis (briefly describe a file)</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">whatis cat</span></span><br></pre></td></tr></table></figure>
<h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4></li>
<li>set a alias for a command. the alias are saved in ~/.bashrc<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> foobar=<span class="string">&#x27;ls la&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>unlias<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unalias</span> foobar</span><br></pre></td></tr></table></figure>
<h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4></li>
<li>exit the shell<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br><span class="line">or </span><br><span class="line">logout</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>以下信息来源于</strong> <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html">linux tools quick tutorial</a></p>
<h4 id="命令帮助"><a href="#命令帮助" class="headerlink" title="命令帮助"></a>命令帮助</h4><ul>
<li>简要说明命令的作用<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">whatis</span><span class="meta"> [command]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>正则匹配<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">whatis</span> -w <span class="string">&quot;m*&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>详细说明<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">info <span class="comment">[command]</span></span><br><span class="line"><span class="keyword">man</span> <span class="comment">[command]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>查看路径<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure></li>
<li>查看程序的搜索路径,当系统中安装了一个软件的多个版本的话，这个命令可以帮助确定版本。<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">whereis</span><span class="meta"> [command]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h4><h4 id="创建和删除"><a href="#创建和删除" class="headerlink" title="创建和删除"></a>创建和删除</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mkdir</span><br><span class="line">touch </span><br><span class="line"><span class="built_in">rm</span></span><br><span class="line"><span class="built_in">mv</span> </span><br><span class="line"><span class="built_in">cp</span></span><br></pre></td></tr></table></figure>
<h4 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h4><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pwd</span></span><br><span class="line"><span class="keyword">cd</span> -  <span class="comment">#切换到上一个工作目录</span></span><br><span class="line"><span class="keyword">cd</span> ~  <span class="comment">#回到home目录</span></span><br><span class="line"><span class="keyword">cd</span> <span class="string">../</span></span><br></pre></td></tr></table></figure>
<h4 id="查找目录与文件"><a href="#查找目录与文件" class="headerlink" title="查找目录与文件"></a>查找目录与文件</h4><h4 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h4><p>dd</p>
<blockquote>
<p>if=file #read from file instead of stdin<br>of-file write to file instead of stdout<br>by=bytes #read and write bytes bytes at a time (指定块大小)<br>count=blocks #copy only blocks input blocks 指定块数量<br>seek=blocks #把块输出到文件时指定要跳过的几块<br>conv=convs #指定追加数据时的操作 notrunc 是不打断文件。<br>dd if=mbr.bin of=hd60M.hd bs=512 count=1 seek=0 conv=notrunc</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nonetag</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown的使用方法</title>
    <url>/2021/03/22/markdown%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="markdown-的使用方法"><a href="#markdown-的使用方法" class="headerlink" title="markdown 的使用方法"></a>markdown 的使用方法</h1><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><ul>
<li>星号数量为标题等级<h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4></li>
<li>markdown换行直接在后面加上两个以上的空格就好。<h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><blockquote>
<p>*斜体文本*<br>_斜体文本_<br>**粗体文本**<br>__粗体文本__<br>***粗斜体文本***<br>___粗斜体文本___    </p>
</blockquote>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4></li>
<li>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：<blockquote>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="strong">***</span></span><br><span class="line">---</span><br><span class="line"><span class="emphasis">___</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<hr>
<hr>
<hr>
<h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><ul>
<li>在文字的两端加上两个波浪线 <del>即可</del><blockquote>
<p><del>删除</del></p>
</blockquote>
<h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4></li>
<li>下划线可以通过 HTML 的 <u> 标签来实现：</u><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>带下划线文本<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4></li>
</ul>
<p>创建脚注格式类似这样 [^RUNOOB]。</p>
<p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul>
<li>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容。</li>
<li>有序列表使用数字并加上 . 号来表示。<h6 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h6></li>
<li>列表嵌套只需在子列表中的选项前面添加四个空格即可。</li>
</ul>
<ol>
<li>一</li>
<li>二<ol>
<li>一</li>
<li>二</li>
<li>三</li>
</ol>
</li>
<li>三</li>
</ol>
<ul>
<li><p>一</p>
</li>
<li><p>二</p>
</li>
<li><p>the <code>asd</code>.</p>
</li>
</ul>
<h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><ul>
<li>在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</li>
</ul>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ul>
<li>用 ``` 包裹一段代码，并指定一种语言<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><blockquote>
<p>[百度](baidu.com)<br>&lt;baidu.com&gt;</p>
</blockquote>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><blockquote>
<p>![picture](/img/love.png)</p>
</blockquote>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><ul>
<li>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</li>
</ul>
<blockquote>
<p>|  表头   | 表头  |<br>|  —  | —  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |    </p>
</blockquote>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<blockquote>
<p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。   </p>
</blockquote>
<blockquote>
<p>| 左对齐 | 右对齐 | 居中对齐 |<br>| :—–| —-: | :—-: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |   </p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<h4 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h4><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>nasm 使用</title>
    <url>/2021/05/20/nasm-%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="nasm-使用"><a href="#nasm-使用" class="headerlink" title="nasm 使用"></a>nasm 使用</h1><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><ol>
<li>汇编一个文件<blockquote>
<p>nasm -f <format> <filename> [-o <output>]<br>nasm -f elf my.asm # 把文件’my.asm’汇编成’ELF’格式 的文件’my.o’.<br>nasm -f bin my.asm -o my.bin # 把文件’my.asm’汇编成纯二进制格式的文件’my.bin’。<br>nasm -I include/ my.asm -o my.bin #添加库目录</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>使用</tag>
        <tag>nasm</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv 1 配置环境与图像的基本操作</title>
    <url>/2021/07/11/opencv-1-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="opencv-1-配置环境与图像的基本操作"><a href="#opencv-1-配置环境与图像的基本操作" class="headerlink" title="opencv 1 配置环境与图像的基本操作"></a>opencv 1 配置环境与图像的基本操作</h1><p>最近习惯使用vscode作为主力编辑器，所以这次学习opencv也是用vscode，顺便学习以下python。      </p>
<p>我的环境是：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">python</span> <span class="number">3</span>.<span class="number">9</span>.<span class="number">6</span></span><br><span class="line"><span class="attribute">opencv</span></span><br></pre></td></tr></table></figure>

<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ol>
<li><p>python.org安装python</p>
</li>
<li><p>配置环境变量，maybe已自动配置</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>vscode安装python的扩展</p>
</li>
<li><p>运行代码。右键选择在python终端中执行代码。</p>
</li>
<li><p>注意vscode的路径问题。当前路径是pwd所展示的，和文件的具体位置无关。这个问题在昨天在vs上面写XYY_Game_Engine时也遇到了，注意路径问题，关键时找到pwd到底是什么。对于vs来说是main在的路径，对于命令行来讲是pwd。</p>
</li>
</ol>
<p><strong>shift -f vscode, 还是直接使用pycharm吧，就是jetbrains家的ide太难看了。</strong></p>
<h2 id="opencv-图像基本操作"><a href="#opencv-图像基本操作" class="headerlink" title="opencv 图像基本操作"></a>opencv 图像基本操作</h2>]]></content>
      <categories>
        <category>opencv</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>python</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>os 001 bochs</title>
    <url>/2021/05/11/os-001-bochs/</url>
    <content><![CDATA[<h1 id="make-an-os-001"><a href="#make-an-os-001" class="headerlink" title="make an os -001"></a>make an os -001</h1><ul>
<li>积攒了这么久，终于要开始写一个操作系统了，加油。</li>
</ul>
<h4 id="bochs"><a href="#bochs" class="headerlink" title="bochs"></a>bochs</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">wget</span> https://cfhcable.dl.sourceforge.net/project/bochs/bochs/<span class="number">2</span>.<span class="number">6</span>.<span class="number">2</span>/bochs-<span class="number">2</span>.<span class="number">6</span>.<span class="number">2</span>.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>解压进入目录中</li>
<li>configure</li>
</ul>
<blockquote>
<p>./configure –prefix=/lib/bochs –enable-debugger –enable-disasm  –enable-iodebug  –enable-x86-debugger  –with-x –with-x11</p>
</blockquote>
<ul>
<li><p>make<br>make会出现lpthread未链接的信息，则添加以下内容。<br>修改Makefile 在93行加入以下信息</p>
<blockquote>
<p>./configure –prefix=/lib/bochs –enable-debugger –enable-disasm  –enable-iodebug  –enable-x86-debugger  –with-x –with-x11<br>191行与192行改为</p>
<p>$(LIBS) \    </p>
<pre><code>   -lpthread
</code></pre>
</blockquote>
</li>
<li><p>make install</p>
</li>
<li><p>Makefile的示例如下<br><a href="/file/bochs/Makefile">makefile</a></p>
</li>
<li><p>配置bochs的启动选项<br><a href="/file/bochs/conf">conf</a></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bochs配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 机器内存: 32MB</span></span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对应真实机器的bios</span></span><br><span class="line">romimage: <span class="attribute">file</span>=/lib/bochs/share/bochs/BIOS-bochs-latest</span><br><span class="line"><span class="comment"># 对应真实机器的VGA bios</span></span><br><span class="line">vgaromimage: <span class="attribute">file</span>=/lib/bochs/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动方式</span></span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line">log: bochs.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭鼠标</span></span><br><span class="line">mouse: <span class="attribute">enabled</span>=0</span><br><span class="line">keyboard:<span class="attribute">keymap</span>=/lib/bochs/share/bochs/keymaps/x11-pc-us.map</span><br><span class="line"><span class="comment"># 硬盘设置</span></span><br><span class="line"></span><br><span class="line">ata0: <span class="attribute">enabled</span>=1, <span class="attribute">ioaddr1</span>=0x1f0, <span class="attribute">ioaddr2</span>=0x3f0, <span class="attribute">irq</span>=14</span><br><span class="line">ata0-master: <span class="attribute">type</span>=disk, <span class="attribute">path</span>=<span class="string">&quot;hd60M.img&quot;</span>, <span class="attribute">mode</span>=flat, <span class="attribute">cylinders</span>=121, <span class="attribute">heads</span>=16, <span class="attribute">spt</span>=63</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>添加环境变量<br>在 <strong>/etc/profile</strong> 的最后一行添加</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=/lib/bochs/bin:$PATH</span><br></pre></td></tr></table></figure>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure></li>
<li><p>启动bochs</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">boshs</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>os 002 os start</title>
    <url>/2021/05/11/os-002-os-start/</url>
    <content><![CDATA[<h1 id="os-002-os-start"><a href="#os-002-os-start" class="headerlink" title="os 002 os start"></a>os 002 os start</h1><h4 id="实模式下的1M内存布局"><a href="#实模式下的1M内存布局" class="headerlink" title="实模式下的1M内存布局"></a>实模式下的1M内存布局</h4><table>
<thead>
<tr>
<th>起始</th>
<th>结束</th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>FFFF0</td>
<td>FFFFF</td>
<td>16B</td>
<td>BIOS入口地址，此16字节的指令是jmp f000:e05b</td>
</tr>
<tr>
<td>F0000</td>
<td>FFFEF</td>
<td>64KB-16B</td>
<td>BIOS的范围是F0000~FFFFF共640KB</td>
</tr>
<tr>
<td>C8000</td>
<td>EFFFF</td>
<td>160KB</td>
<td>映射硬件适配器的ROM或者内存映射式IO</td>
</tr>
<tr>
<td>C0000</td>
<td>C7FFF</td>
<td>32KB</td>
<td>显示适配器BIOS</td>
</tr>
<tr>
<td>B8000</td>
<td>BFFFF</td>
<td>32KB</td>
<td>用于文本模式的显示适配器</td>
</tr>
<tr>
<td>B0000</td>
<td>B7FFF</td>
<td>32KB</td>
<td>用于黑白显示适配器</td>
</tr>
<tr>
<td>A0000</td>
<td>AFFFF</td>
<td>64KB</td>
<td>用于彩色显示适配器</td>
</tr>
<tr>
<td>9FC00</td>
<td>9FFFF</td>
<td>1KB</td>
<td>扩展BIOS数据区</td>
</tr>
<tr>
<td>7E00</td>
<td>9FBFF</td>
<td>608KB</td>
<td>可用区域</td>
</tr>
<tr>
<td>7C00</td>
<td>7DFF</td>
<td>512B</td>
<td>MBR被加载到此处，共512字节</td>
</tr>
<tr>
<td>500</td>
<td>7BFF</td>
<td>30KB</td>
<td>可用区域</td>
</tr>
<tr>
<td>400</td>
<td>4FF</td>
<td>256B</td>
<td>BIOS数据区</td>
</tr>
<tr>
<td>0</td>
<td>3FF</td>
<td>1KB</td>
<td>中断向量表IVT</td>
</tr>
</tbody></table>
<h4 id="计算机的启动过程"><a href="#计算机的启动过程" class="headerlink" title="计算机的启动过程"></a>计算机的启动过程</h4><ol>
<li>按下开机键，cs:ip被初始化为F000:FFF0，指向BIOS入口地址。</li>
<li>BIOS被加载进ROM并被映射到1MB内存的顶部（见上表）。</li>
<li>jmp f000:e05b,执行BIOS的工作。</li>
<li>BIOS的最后一项工作是校验启动盘中位于0盘0道1扇区的内容，若最后两个字节分别为0x55与0xaa，（即最后一个字的内容为0xaa55(小端字节序)）,则认为这是一个MBR程序（主引导记录），则将此512字节加载如内存0x7C00. BIOS跳转，jmp 0:7C00</li>
<li>执行MBR。</li>
<li>MBR，加载boot loader</li>
<li>boot loader加载os 内核。</li>
<li>内核执行</li>
</ol>
<h4 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h4><ol>
<li>BIOS本身是一个程序。BIOS的工作：检测硬件，做各种初始化工作，建立中断向量表，加载MBR。</li>
<li>BIOS中断只能用于实模式，在保护模式下不可以使用。</li>
</ol>
<h4 id="硬盘操作"><a href="#硬盘操作" class="headerlink" title="硬盘操作"></a>硬盘操作</h4><h6 id="硬盘控制器主要端口寄存器"><a href="#硬盘控制器主要端口寄存器" class="headerlink" title="硬盘控制器主要端口寄存器"></a>硬盘控制器主要端口寄存器</h6><table>
<thead>
<tr>
<th>IO端口</th>
<th></th>
<th>端口用途</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>primary通道</td>
<td>secondary通道</td>
<td>读</td>
<td>写</td>
</tr>
<tr>
<td>指令寄存器</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x1F0</td>
<td>0x170</td>
<td>data</td>
<td>data</td>
</tr>
<tr>
<td>0x1F1</td>
<td>0x171</td>
<td>data</td>
<td>features</td>
</tr>
<tr>
<td>0x1F2</td>
<td>0x172</td>
<td>扇区数量</td>
<td>扇区数量</td>
</tr>
<tr>
<td>0x1F3</td>
<td>0x173</td>
<td>LBA LOW</td>
<td>LBA LOW</td>
</tr>
<tr>
<td>0x1F4</td>
<td>0x174</td>
<td>LBA MID</td>
<td>LBA MID</td>
</tr>
<tr>
<td>0x1F5</td>
<td>0x175</td>
<td>LBA HIGH</td>
<td>LBA HIGH</td>
</tr>
<tr>
<td>0x1F6</td>
<td>0x176</td>
<td>device</td>
<td>device</td>
</tr>
<tr>
<td>0x1F7</td>
<td>0x177</td>
<td>status</td>
<td>command</td>
</tr>
<tr>
<td>控制寄存器</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x3F6</td>
<td>0x376</td>
<td>alternate status</td>
<td>device control</td>
</tr>
</tbody></table>
<blockquote>
<p>Sector count 寄存器用来指定待读取或待写入的扇区数。硬盘每完成一个扇区，就会将此寄存器的值<br>减 1，所以如果中间失败了，此寄存器中的值便是尚未完成的扇区。这是 8 位寄存器，最大值为 255，若<br>指定为 0，则表示要操作 256 个扇区。      </p>
</blockquote>
<blockquote>
<p>在读硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 Status，它是 8 位宽度的寄存器，用来给出硬盘的<br>状态信息。第 0 位是 ERR 位，如果此位为 1，表示命令出错了，具体原因可见 error 寄存器。第 3 位是 data<br>request 位，如果此位为 1，表示硬盘已经把数据准备好了，主机现在可以把数据读出来。第 6 位是 DRDY，<br>表示硬盘就绪，此位是在对硬盘诊断时用的，表示硬盘检测正常，可以继续执行一些命令。第 7 位是 BSY<br>位，表示硬盘是否繁忙，如果为 1 表示硬盘正忙着，此寄存器中的其他位都无效。另外的 4 位暂不关注。      </p>
</blockquote>
<blockquote>
<p>在写硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 command，和上面说过的 error 和 feature 寄存器情况<br>一样，只是用途变了，所以换了个名字表示新的用途，它和 status 寄存器是同一个。此寄存器用来存储让硬<br>盘执行的命令，只要把命令写进此寄存器，硬盘就开始工作了。主要使用了三个命令。<br>（1）identify：0xEC，即硬盘识别。<br>（2）read sector：0x20，即读扇区。<br>（3）write sector：0x30，即写扇区。   </p>
</blockquote>
<h6 id="硬盘读取步骤"><a href="#硬盘读取步骤" class="headerlink" title="硬盘读取步骤"></a>硬盘读取步骤</h6><blockquote>
<p>（1）先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数。<br>（2）往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。<br>（3）往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第4位，选择操作的硬盘（master 硬盘或 slave 硬盘）。<br>（4）往该通道上的 command 寄存器写入操作命令。<br>（5）读取该通道上的 status 寄存器，判断硬盘工作是否完成。<br>（6）如果以上步骤是读硬盘，进入下一个步骤。否则，完工。<br>（7）将硬盘数据读出。        </p>
</blockquote>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">;功能:读取硬盘n个扇区</span></span><br><span class="line"><span class="symbol">rd_disk_m_16:</span>	   </span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; eax=LBA扇区号</span></span><br><span class="line"><span class="comment">; ebx=将数据写入的内存地址</span></span><br><span class="line"><span class="comment">; ecx=读入的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>	  <span class="comment">;备份eax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">cx</span>		  <span class="comment">;备份cx</span></span><br><span class="line"><span class="comment">;读写硬盘:</span></span><br><span class="line"><span class="comment">;第1步：设置要读取的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f2</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>            <span class="comment">;读取的扇区数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">esi</span>	   <span class="comment">;恢复ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址7~0位写入端口0x1f3</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f3</span>                       </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>                          </span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址15~8位写入端口0x1f4</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">8</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f4</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址23~16位写入端口0x1f5</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f5</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x0f</span>	   <span class="comment">;lba第24~27位</span></span><br><span class="line">      <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xe0</span>	   <span class="comment">; 设置7～4位为1110,表示lba模式</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f6</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第3步：向0x1f7端口写入读命令，0x20 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f7</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0x20</span>                        </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第4步：检测硬盘状态</span></span><br><span class="line"><span class="symbol">  .not_ready:</span></span><br><span class="line">      <span class="comment">;同一端口，写时表示写入命令字，读时表示读入硬盘状态</span></span><br><span class="line">      <span class="keyword">nop</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x88</span>	   <span class="comment">;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙</span></span><br><span class="line">      <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0x08</span></span><br><span class="line">      <span class="keyword">jnz</span> .not_ready	   <span class="comment">;若未准备好，继续等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第5步：从0x1f0端口读数据</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">di</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">256</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="built_in">ax</span>	   <span class="comment">; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，</span></span><br><span class="line">			   <span class="comment">; 共需di*512/2次，所以di*256</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f0</span></span><br><span class="line"><span class="symbol">  .go_on_read:</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">ax</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span>		  </span><br><span class="line">      <span class="keyword">loop</span> .go_on_read</span><br><span class="line">      <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>os 004 中断</title>
    <url>/2021/05/25/os-004-%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h1 id="os-004-中断"><a href="#os-004-中断" class="headerlink" title="os 004 中断"></a>os 004 中断</h1><h4 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h4><h6 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h6><p>外部中断是来自CPU外部的中断，外部中断源又必须是硬件，所以外部中断又称为硬件中断。       </p>
<ol>
<li><p><strong>可屏蔽中断</strong><br>通过intr引脚进入CPU，可屏蔽中断可以通过EFLAGS的IF位屏蔽掉。</p>
</li>
<li><p><strong>不可屏蔽中断</strong><br>通过NMI引脚进入CPU，不可屏蔽中断不可以通过EFLAGS的IF位屏蔽掉。</p>
</li>
</ol>
<h6 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h6><p>内部中断可分为软中断和异常。        </p>
<ol>
<li><p><strong>软中断</strong><br>由软件主动发起的中断。不受IF位影响。        </p>
</li>
<li><p><strong>异常</strong><br>异常分为以下三种：      </p>
<ol>
<li>FAULT 故障，比如缺页异常。       </li>
<li>TRAP 陷阱       </li>
<li>ABORT 终止</li>
</ol>
</li>
</ol>
<p>IF位只能屏蔽外部设备的中断。    </p>
<table>
<thead>
<tr>
<th>指令</th>
<th>IF</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cli</td>
<td>IF=0</td>
<td>关中断</td>
</tr>
<tr>
<td>sti</td>
<td>IF=1</td>
<td>开中断</td>
</tr>
</tbody></table>
<h4 id="中断描述符表-IDT"><a href="#中断描述符表-IDT" class="headerlink" title="中断描述符表 IDT"></a>中断描述符表 IDT</h4><p>中断描述符表是保护模式下用于存储中断处理程序入口的表，当CPU接受一个中断时，使用中断向量在这个表中检索相应的中断描述符，继而找到中断处理程序的入口地址，执行中断处理程序。       </p>
<p>中断描述符表中可以存储中断描述符、任务们描述符、陷阱们描述符。所以中断描述符又称为<strong>门</strong>。  </p>
<p>门都属于系统段，所以其描述符中的S字段全为0.     </p>
<p><strong>四种门描述符中type字段(D=0代表16位，D=32代表32位)</strong>       </p>
<table>
<thead>
<tr>
<th>任务门</th>
<th>终端门</th>
<th>陷阱门</th>
<th>调用门</th>
</tr>
</thead>
<tbody><tr>
<td>0101</td>
<td>D110</td>
<td>D111</td>
<td>D100</td>
</tr>
</tbody></table>
<p><strong>当代操作系统很少使用任务门和调用门</strong>      </p>
<h6 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h6><p>任务门和任务状态段（TSS）时Intel处理器在硬件一级上提供的任务切换机制。当代大多数操作系统都没有使用TSS实现任务的切换。</p>
<h6 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h6><p><strong>中断门描述符</strong></p>
<table>
<thead>
<tr>
<th>位</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>高32位</td>
<td></td>
</tr>
<tr>
<td>31-16</td>
<td>中断处理程序在目标段内的偏移量的31-16位</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
</tr>
<tr>
<td>14-13</td>
<td>DPL</td>
</tr>
<tr>
<td>12</td>
<td>S=0</td>
</tr>
<tr>
<td>11-8</td>
<td>TYPE=D110</td>
</tr>
<tr>
<td>7-5</td>
<td>0</td>
</tr>
<tr>
<td>4-0</td>
<td>未使用</td>
</tr>
<tr>
<td>低32位</td>
<td></td>
</tr>
<tr>
<td>31-16</td>
<td>中断处理程序目标代码段描述符选择子</td>
</tr>
<tr>
<td>15-0</td>
<td>中断处理程序在目标段内的偏移量的15-0位</td>
</tr>
</tbody></table>
<p>通过中断门进入中断，IF位自动置零，关中断，避免中断嵌套。中断门只存在于IDT中。       </p>
<h6 id="陷阱门"><a href="#陷阱门" class="headerlink" title="陷阱门"></a>陷阱门</h6><p><strong>陷阱门描述符</strong></p>
<table>
<thead>
<tr>
<th>位</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>高32位</td>
<td></td>
</tr>
<tr>
<td>31-16</td>
<td>中断处理程序在目标段内的偏移量的31-16位</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
</tr>
<tr>
<td>14-13</td>
<td>DPL</td>
</tr>
<tr>
<td>12</td>
<td>S=0</td>
</tr>
<tr>
<td>11-8</td>
<td>TYPE=D111</td>
</tr>
<tr>
<td>7-5</td>
<td>0</td>
</tr>
<tr>
<td>4-0</td>
<td>未使用</td>
</tr>
<tr>
<td>低32位</td>
<td></td>
</tr>
<tr>
<td>31-16</td>
<td>中断处理程序目标代码段描述符选择子</td>
</tr>
<tr>
<td>15-0</td>
<td>中断处理程序在目标段内的偏移量的15-0位</td>
</tr>
</tbody></table>
<p>陷阱门与中断门不同的是IF位不会自动置0.</p>
<h6 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h6><p>调用门给用户进程提供进入特权即0的方式，其DPL为3。他不能用于int指令调用，只能用call和jmp指令。调用门可以安装在GDT和LDT中。           </p>
<h6 id="中断描述符表寄存器-IDTR"><a href="#中断描述符表寄存器-IDTR" class="headerlink" title="中断描述符表寄存器 IDTR"></a>中断描述符表寄存器 IDTR</h6><table>
<thead>
<tr>
<th>47-16</th>
<th>15-0</th>
</tr>
</thead>
<tbody><tr>
<td>32位的表基址</td>
<td>16位的表界限</td>
</tr>
</tbody></table>
<p>GDT第零个描述符是不可用的，但是IDT的第零个描述符是可用的。          </p>
<p>lidt[48位内存地址]</p>
<h4 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h4><h6 id="中断的特权级检查"><a href="#中断的特权级检查" class="headerlink" title="中断的特权级检查"></a>中断的特权级检查</h6><p>对于软件主动引发的中断，从特权级上来讲，必须符合下面的条件:<br><strong>门描述符DPL&lt;=CPL&lt;目标代码段的DPL</strong></p>
<p>对于外部设备引发的中断，只需要满足:<br><strong>CPL&lt;目标代码段的DPL</strong></p>
<p>处理器根据中断向量号找到对应的中断描述符后，若CPL比目标代码段DPL低，则需要向高特权转移，需要切换到高特权级的栈。</p>
<p><strong>中断发生，特权级发生变化时的新栈中的内容</strong></p>
<table>
<thead>
<tr>
<th>31-16</th>
<th>15-0</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ss_old</td>
</tr>
<tr>
<td>esp_old</td>
<td>esp_old</td>
</tr>
<tr>
<td>eflags</td>
<td>eflags</td>
</tr>
<tr>
<td>0</td>
<td>cs_old</td>
</tr>
<tr>
<td>eip_old</td>
<td>eip_old</td>
</tr>
<tr>
<td>error_code</td>
<td>error_code</td>
</tr>
</tbody></table>
<p>执行完中断程序之后，使用<strong>iret</strong>进行返回。依次弹出EIP,CS,EFLAGS。所以中断返回前栈顶指针必须指向EIP_old。处理器根据弹出的CS指向的代码段描述符判断出该次中断是否进行了特权级改变，如果进行了特权级改变的话，继续将esp和ss弹出。</p>
<p>如果返回时改变了特权级则将会检查数据段寄存器DS,ES,FS,GS的内容，如果DPL比返回后的CPL高，则处理器会故意将该数据段寄存器的内容改为0，即指向第零个段描述符，从而使得处理器抛出异常。</p>
<h6 id="中断错误码"><a href="#中断错误码" class="headerlink" title="中断错误码"></a>中断错误码</h6><table>
<thead>
<tr>
<th>31-16</th>
<th>15-3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>保留0</td>
<td>选择子高13位索引</td>
<td>TI</td>
<td>IDT</td>
<td>EXT</td>
</tr>
</tbody></table>
<p>TI=0,表示来自GDT,TI=1表示来自LDT。</p>
<p>IDT=1，表示选择子指向IDT。否则表示指向GDT或者LDT。</p>
<p>EXT=1，表示中断源时不可屏蔽中断或者外部设备，否则为0.</p>
<h4 id="8259A"><a href="#8259A" class="headerlink" title="8259A"></a>8259A</h4><h6 id="8259A的一些信号的寄存器"><a href="#8259A的一些信号的寄存器" class="headerlink" title="8259A的一些信号的寄存器"></a>8259A的一些信号的寄存器</h6><ol>
<li><p>INT：8259A选出优先级最高的中断请求之后，发送信号给CPU。</p>
</li>
<li><p>INTA：INT acknowledge, 中断响应信号。接收来自CPU的INTA接口的中断响应信号。</p>
</li>
<li><p>IMR：中断屏蔽寄存器，8位，屏蔽某个外设的中断。</p>
</li>
<li><p>IRR：中断请求寄存器，8位，接受IMR过滤后的中断信号并锁存，相当于维护未处理的中断信号请求队列。</p>
</li>
<li><p>PR: 优先级仲裁器。多个中断同时发生的时候找出优先级更高的中断。</p>
</li>
<li><p>ISR： 中断服务寄存器，8位，保存正在被处理的中断服务。</p>
</li>
</ol>
<p>一个8259A由8个IRQ接口，使用8位寄存器中的每一位代表一个IRQ接口。</p>
<h6 id="8259A的中断处理流程"><a href="#8259A的中断处理流程" class="headerlink" title="8259A的中断处理流程"></a>8259A的中断处理流程</h6><ol>
<li><p>当某个外设发出一个中断信号后，由于主板已经把信号通路指向了8259A芯片的某个IRQ接口，所以该中断信号会被送入8259A。8259A先检查IMR寄存器是否屏蔽了来自该IRQ接口的中断信号，该为为1表示被屏蔽了。</p>
</li>
<li><p>将中断信号送入IRR寄存器，将该IRQ接口所在的IRR寄存器对应的位置1.</p>
</li>
<li><p>PR从IRR寄存器中挑选一个优先级最大的一个中断（IRQ接口号最低的）。</p>
</li>
<li><p>通过INT接口向CPU发送INTR信号。</p>
</li>
<li><p>CPU完成一条指令后，通过自己的INTA接口向8259A的INTA接口发送中断响应信号。</p>
</li>
<li><p>8259A收到CPU的中断响应信号后，将刚刚挑选出的优先级最大的中断在ISR寄存器中对应的位置1，表示正在处理当前中断，同时在IRR中该中断位置0。</p>
</li>
<li><p>CPU再次发送INTA信号，要求获取中断向量号。<strong>如果EIO被设置为自动的话，则8259A自动将ISR对应位置0，表示中断结束，否则需要手动发送EOI信号</strong></p>
</li>
<li><p>8259A向CPU发送中断向量号。<strong>此时如果来了一个优先级更高的中断，则将该中断替换上去，将被替换下来的中断重新装入IRR中</strong></p>
</li>
<li><p>CPU从数据总线上拿到中断向量号止之后，用作中断向量表或者中断描述符表的索引，转到对应的中断处理程序执行。</p>
</li>
</ol>
<p><strong>以上为中断处理流程的上半场</strong></p>
<h4 id="8259A的编程"><a href="#8259A的编程" class="headerlink" title="8259A的编程"></a>8259A的编程</h4>]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>proxy trojan</title>
    <url>/2021/04/21/proxy-trojan/</url>
    <content><![CDATA[<h1 id="proxy-trojan"><a href="#proxy-trojan" class="headerlink" title="proxy trojan"></a>proxy trojan</h1><h4 id="trojan-server-服务端"><a href="#trojan-server-服务端" class="headerlink" title="trojan server 服务端"></a>trojan server 服务端</h4><ul>
<li>傻瓜式一键部署，（等我Linux学有所成了再自己一步一步地配置）<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -O https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/atrandys/</span>trojan<span class="regexp">/master/</span>trojan_mult.sh &amp;&amp; chmod +x trojan_mult.sh &amp;&amp; ./trojan_mult.sh</span><br></pre></td></tr></table></figure></li>
<li>按照提示进行部署。需要手动输入域名和密码。</li>
<li>结果会输出一个如下的配置，config。保存这个配置(config.json)，待会要用。<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;run_type&quot;</span>: <span class="string">&quot;client&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;local_addr&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">&quot;remote_addr&quot;</span>: <span class="string">&quot;domain&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;remote_port&quot;</span>: <span class="number">443</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;password&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;log_level&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;ssl&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;verify&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;verify_hostname&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;cert&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cipher_tls13&quot;</span>:<span class="string">&quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;sni&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;alpn&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;h2&quot;</span>,</span><br><span class="line">            <span class="string">&quot;http/1.1&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;reuse_session&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;session_ticket&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;curves&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;tcp&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;no_delay&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;keep_alive&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;fast_open&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;fast_open_qlen&quot;</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="trojan-client-客户端"><a href="#trojan-client-客户端" class="headerlink" title="trojan client 客户端"></a>trojan client 客户端</h4><h6 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h6></li>
<li>windows 下推荐使用clash。</li>
<li>github 上下载 clash for windows,安装。</li>
<li>clash 配置示例如下。<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="attr">redir-port:</span> <span class="number">7892</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">rule</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9090</span></span><br><span class="line"><span class="attr">proxies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">trojan</span></span><br><span class="line">    <span class="attr">name:</span> <span class="number">0.</span><span class="string">trojan</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">server&#x27;ip</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">密码</span></span><br><span class="line">    <span class="attr">sni:</span> <span class="string">download.windowsupdate.com</span></span><br><span class="line">    <span class="attr">skip-cert-verify:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure>
<h6 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h6></li>
<li>以Ubuntu为例</li>
<li>下载Trojan<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>src</span><br><span class="line">wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/trojan-gfw/</span>trojan<span class="regexp">/releases/</span>download<span class="regexp">/v1.16.0/</span>trojan-<span class="number">1.16</span>.<span class="number">0</span>-linux-amd64.tar.xz</span><br><span class="line">tar xvf trojan-<span class="number">1.16</span>.<span class="number">0</span>-linux-amd64.tar.xz</span><br><span class="line">cd <span class="regexp">/usr/</span>src/trojan</span><br><span class="line">vi config.json</span><br></pre></td></tr></table></figure></li>
<li>将上面server生成的config复制到这里。即可。</li>
<li>为Trojan注册服务。<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cat &gt; <span class="regexp">/etc/</span>systemd<span class="regexp">/system/</span>trojan.service &lt;&lt;-EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=trojan</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">PIDFile=<span class="regexp">/usr/</span>src<span class="regexp">/trojan/</span>trojan.pid</span><br><span class="line">ExecStart=<span class="regexp">/usr/</span>src<span class="regexp">/trojan/</span>trojan -c <span class="regexp">/usr/</span>src<span class="regexp">/trojan/</span>config.json -l <span class="regexp">/usr/</span>src<span class="regexp">/trojan/</span>trojan.log</span><br><span class="line">ExecReload=<span class="regexp">/bin/</span>kill -HUP \<span class="variable">$MAINPID</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=<span class="number">1</span>s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li>
<li>启动Trojan<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> trojan</span><br></pre></td></tr></table></figure></li>
<li>检查是否启动成功<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ps</span> aux | <span class="keyword">grep</span> trojan | <span class="keyword">grep</span> -v <span class="keyword">grep</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>看到有类似 /usr/src/trojan/trojan 的内容展示，即表示trojan正在运行<br>如果未启动成功，通过这个命令查看日志： cat /usr/src/trojan/trojan.log<br>还可以执行 curl ip.sb –socks5 127.0.0.1:1080, 查看结果是否为Trojan代理的IP</p>
</blockquote>
</li>
<li>设置开机启动<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">systemctl <span class="builtin-name">enable</span> trojan</span><br></pre></td></tr></table></figure></li>
<li>命令行使用Trojan代理，免去使用镜像却又找不到之苦。<blockquote>
<p>安装配置proxychains，全局翻墙通过proxychains实现，即将任何程序和Trojan的proxy建立链接，原理和浏览器的代理相似。</p>
</blockquote>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> install proxychains</span><br><span class="line"><span class="keyword">vi</span> /etc/proxychains.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在最后的ProxyList里注释默认的socks代理： socks4 前增加#表示注释<br>在最后的ProxyList里加入Trojan的代理设置： socks5 127.0.0.1 1080<br>测试本地IP: curl -4 ip.sb，将显示自己的IP<br>测试代理IP: proxychains curl -4 ip.sb，将显示Trojan代理的IP<br>后续使用的命令行需要代理时，只需要在前面加上 proxychains 即可<br>如 </p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">proxychains wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/cdr/</span>code-server<span class="regexp">/releases/</span>download<span class="regexp">/v3.9.3/</span>code-server-<span class="number">3.9</span>.<span class="number">3</span>-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hahahaha,，没错，我要开始配置code-server了。见下一讲 code-server.</p>
</blockquote>
</li>
</ul>
<h4 id="linux-加速"><a href="#linux-加速" class="headerlink" title="linux 加速"></a>linux 加速</h4><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">wget <span class="string">&quot;https://github.com/chiakge/Linux-NetSpeed/raw/master/tcp.sh&quot;</span> <span class="variable">&amp;&amp;</span> chmod +<span class="meta">x</span> tcp.sh <span class="variable">&amp;&amp;</span> ./tcp.sh</span><br></pre></td></tr></table></figure>

<h2 id="手动配置-trojan"><a href="#手动配置-trojan" class="headerlink" title="手动配置 trojan"></a>手动配置 trojan</h2><p>Ubuntu 20.04</p>
<p><a href="https://github.com/trojan-gfw/trojan/wiki/Binary-&-Package-Distributions">Trojan官方</a></p>
<h3 id="简略版"><a href="#简略版" class="headerlink" title="简略版"></a>简略版</h3><p>简略版不提供伪装，安装方式也较为简单。不适合学习。</p>
<h4 id="第一步-安装Trojan"><a href="#第一步-安装Trojan" class="headerlink" title="第一步 安装Trojan"></a>第一步 安装Trojan</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">apt -y <span class="keyword">install</span> trojan</span><br></pre></td></tr></table></figure>

<p>trojan的配置目录在 /etc/trojan/config.json</p>
<h4 id="第二步-获取证书"><a href="#第二步-获取证书" class="headerlink" title="第二步 获取证书"></a>第二步 获取证书</h4><p>将一个域名解析到VPS上并获取证书</p>
<p><a href="https://console.cloud.tencent.com/certoverview">腾讯云获取证书</a></p>
<h4 id="第三步-安装证书"><a href="#第三步-安装证书" class="headerlink" title="第三步 安装证书"></a>第三步 安装证书</h4><p>将得到的证书上传云服务器，在下载文件中的nginx文件夹中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp trojan.cuimouren.cn.crt root@trojan.cuimouren.cn:/etc/trojan/trojancert</span><br><span class="line">scp trojan.cuimouren.cn.key root@trojan.cuimouren.cn:/etc/trojan/trojancert</span><br></pre></td></tr></table></figure>

<h4 id="第四步-修改trojan的配置文件"><a href="#第四步-修改trojan的配置文件" class="headerlink" title="第四步 修改trojan的配置文件"></a>第四步 修改trojan的配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/trojan/</span><br><span class="line">rm -rf config.json</span><br><span class="line"><span class="comment"># 写入配置文件</span></span><br><span class="line">    cat &gt; config.json &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;run_type&quot;: &quot;server&quot;,</span></span><br><span class="line"><span class="string">    &quot;local_addr&quot;: &quot;0.0.0.0&quot;,</span></span><br><span class="line"><span class="string">    &quot;local_port&quot;: 443,</span></span><br><span class="line"><span class="string">    &quot;remote_addr&quot;: &quot;127.0.0.1&quot;,</span></span><br><span class="line"><span class="string">    &quot;remote_port&quot;: 80,</span></span><br><span class="line"><span class="string">    &quot;password&quot;: [</span></span><br><span class="line"><span class="string">        &quot;passwd&quot;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    &quot;log_level&quot;: 1,</span></span><br><span class="line"><span class="string">    &quot;ssl&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;cert&quot;: &quot;/etc/trojan/trojancert/domain.crt&quot;,</span></span><br><span class="line"><span class="string">        &quot;key&quot;: &quot;/etc/trojan/trojancert/domain.key&quot;,</span></span><br><span class="line"><span class="string">        &quot;key_password&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">        &quot;cipher_tls13&quot;:&quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;,</span></span><br><span class="line"><span class="string">        &quot;prefer_server_cipher&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;alpn&quot;: [</span></span><br><span class="line"><span class="string">            &quot;http/1.1&quot;</span></span><br><span class="line"><span class="string">        ],</span></span><br><span class="line"><span class="string">        &quot;reuse_session&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;session_ticket&quot;: false,</span></span><br><span class="line"><span class="string">        &quot;session_timeout&quot;: 600,</span></span><br><span class="line"><span class="string">        &quot;plain_http_response&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">        &quot;curves&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">        &quot;dhparam&quot;: &quot;&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;tcp&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;no_delay&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;keep_alive&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;fast_open&quot;: false,</span></span><br><span class="line"><span class="string">        &quot;fast_open_qlen&quot;: 20</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;mysql&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;enabled&quot;: false,</span></span><br><span class="line"><span class="string">        &quot;server_addr&quot;: &quot;127.0.0.1&quot;,</span></span><br><span class="line"><span class="string">        &quot;server_port&quot;: 3306,</span></span><br><span class="line"><span class="string">        &quot;database&quot;: &quot;trojan&quot;,</span></span><br><span class="line"><span class="string">        &quot;username&quot;: &quot;trojan&quot;,</span></span><br><span class="line"><span class="string">        &quot;password&quot;: &quot;&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> trojan</span><br><span class="line"></span><br><span class="line">systemctl restart trojan</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="第五步-clash-使用Trojan"><a href="#第五步-clash-使用Trojan" class="headerlink" title="第五步 clash 使用Trojan"></a>第五步 clash 使用Trojan</h4><p>clash 完整配置文件，附带自动自动选择代理功能。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">port: 7890</span><br><span class="line">socks-port: 7891</span><br><span class="line">redir-port: 7892</span><br><span class="line">allow-lan: false</span><br><span class="line">mode: rule</span><br><span class="line">log-level: info</span><br><span class="line">external-controller: &#x27;127.0.0.1:9090&#x27;</span><br><span class="line">proxies:</span><br><span class="line">    - &#123;type: trojan, name: &#x27;American.trojan&#x27;, server: &#x27;208.167.245.186&#x27;, port: 443, password: &#x27;Yaoyao1234&#x27;, sni: download.windowsupdate.com, skip-cert-verify: true&#125;</span><br><span class="line">proxy-groups:</span><br><span class="line">    - &#123;name: Proxy, type: select, proxies: [自动选择, &#x27;American.trojan&#x27;]&#125;</span><br><span class="line">    - &#123;name: 自动选择, type: url-test, proxies: [&#x27;American.trojan&#x27;], url: &#x27;http://www.gstatic.com/generate_204&#x27;, interval: 300&#125; </span><br><span class="line">rules:</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,mzstatic.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,akadns.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,aaplimg.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cdn-apple.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,apple.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,icloud.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,icloud-content.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,zcool.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cn,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,-cn,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,baotian.me,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,jovi.cc,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,126.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,126.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,127.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,163.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,360buyimg.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,36kr.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,acfun.tv,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,air-matters.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,aixifan.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,akamaized.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,alicdn,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,alipay,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,taobao,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,amap.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,autonavi.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,baidu,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bdimg.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bdstatic.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bilibili.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,caiyunapp.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,clouddn.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cnbeta.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cnbetacdn.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cootekservice.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,csdn.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ctrip.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,dgtle.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,dianping.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,douban.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,doubanio.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,duokan.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,easou.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ele.me,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,feng.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,fir.im,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,frdic.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,g-cores.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,godic.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,gtimg.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN,cdn.hockeyapp.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,hongxiu.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,hxcdn.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,iciba.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ifeng.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ifengimg.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ipip.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,iqiyi.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,jd.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,jianshu.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,knewone.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,le.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,lecloud.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,lemicp.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,luoo.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,meituan.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,meituan.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,mi.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,miaopai.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,microsoft.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,microsoftonline.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,miui.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,miwifi.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,mob.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,netease.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,officecdn,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,oschina.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ppsimg.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,pstatp.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,qcloud.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,qdaily.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,qdmm.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,qhimg.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,qidian.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,qihucdn.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,qiniu.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,qiniucdn.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,qiyipic.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,qq.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,qqurl.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,rarbg.to,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,rr.tv,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ruguoapp.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,segmentfault.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sinaapp.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sogou.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sogoucdn.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sohu.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,soku.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,speedtest.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sspai.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,suning.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,taobao.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tenpay.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tmall.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tudou.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,umetrip.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,upaiyun.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,upyun.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,v2ex.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,veryzhun.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,weather.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,weibo.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,xiami.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,xiami.net,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,xiaomicp.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ximalaya.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,xmcdn.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,xunlei.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,yhd.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,yihaodianimg.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,yinxiang.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ykimg.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,youdao.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,youku.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,zealer.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,zhihu.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,zhimg.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,umeng.com,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,local,DIRECT&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,127.0.0.0/8,DIRECT&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,172.16.0.0/12,DIRECT&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,192.168.0.0/16,DIRECT&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,192.168.3.0/16,DIRECT&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,10.0.0.0/8,DIRECT&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,17.0.0.0/8,DIRECT&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,100.64.0.0/10,DIRECT&#x27;</span><br><span class="line">    - &#x27;GEOIP,CN,DIRECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN,gs.apple.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN,itunes.apple.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN,beta.itunes.apple.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN,ai.google,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,amazonaws.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,awsstatic.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,awstrack.me,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,amazon.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ant.design,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,applypixels.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,apple.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,azureedge.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,adobedtm.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,adobeccstatic.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,adobelogion.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,adobe.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bechance.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bechance.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bestfolios.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,clippings.io,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,colourlovers.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,dribbble.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,dropbox.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,designernews.co,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,deviantart.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,deviantart.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,envato-static.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,envato.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,fontawesome.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,fancy.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,googleapis.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,github.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,github.io,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,goabstract.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,google.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,gmail.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,godaddy.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,hdwallpapers.in,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,iconfinder.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,imgur.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,instagram.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,imgix.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,kickstarter.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,live.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,lizhi.io,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,microsoft.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,medium.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,muz.li,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,mockupeditor.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,microsoft.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,nngroup.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,omnigroup.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,producthunt.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,pinterest.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,photolemur.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,reddit.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,segment.io,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sfx.ms,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,setapp.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sketchapp.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sketch.cloud,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,stackoverflow.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sketchpacks.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,smallpdf.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,techsmith.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,typora.io,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,themeforest.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,uistencils.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ui8.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,unsplash.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,zeplin.io,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,pusher.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,mixpanel.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,gravatar.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,hockeyapp.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cloudfront.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,gstatic.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,googleapis.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,goo.gl,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,material.io,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,googletagmanager.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,google-analytics.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,doubleclick.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,paddleapi.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,devmate.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,amazon,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,google,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,gmail,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,youtube,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,facebook,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,fb.me,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,fbcdn.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,twitter,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,instagram,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,dropbox,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,twimg.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,blogspot,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,youtu.be,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,whatsapp,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,admarvel,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,admaster,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,adsage,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,adsmogo,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,adsrvmedia,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,adwords,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,adservice,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,domob,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,duomeng,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,dwtrack,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,guanggao,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,lianmeng,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,omgmta,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,openx,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,partnerad,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,pingfore,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,supersonicads,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,tracking,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,uedas,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,umeng,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,usage,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,wlmonitor,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,zjtoolbar,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,club,REJECT&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,9to5mac.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,abpchina.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,adblockplus.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,adobe.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,alfredapp.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,amplitude.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ampproject.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,android.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,angularjs.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,aolcdn.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,apkpure.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,appledaily.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,appshopper.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,appspot.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,arcgis.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,archive.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,armorgames.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,aspnetcdn.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,att.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,awsstatic.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,azureedge.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,azurewebsites.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bing.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bintray.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bit.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bit.ly,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bitbucket.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bjango.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bkrtx.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,blog.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,blogcdn.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,blogger.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,blogsmithmedia.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,blogspot.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,blogspot.hk,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,bloomberg.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,box.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,box.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cachefly.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,chromium.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cl.ly,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cloudflare.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cloudfront.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cloudmagic.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cmail19.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cnet.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,cocoapods.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,comodoca.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,content.office.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,crashlytics.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,culturedcode.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,d.pr,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,danilo.to,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,dayone.me,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,db.tt,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,deskconnect.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,digicert.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,disq.us,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,disqus.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,disquscdn.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,dnsimple.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,docker.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,droplr.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,duckduckgo.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,dueapp.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,dytt8.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,edgecastcdn.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,edgekey.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,edgesuite.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,engadget.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,entrust.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,eurekavpt.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,evernote.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,fabric.io,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,fast.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,fastly.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,fc2.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,feedburner.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,feedly.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,feedsportal.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,fiftythree.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,firebaseio.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,flexibits.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,flickr.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,flipboard.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,g.co,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,gabia.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,geni.us,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,gfx.ms,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ggpht.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ghostnoteapp.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,git.io,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-KEYWORD,github,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,globalsign.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,gmodules.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,godaddy.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,golang.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,gongm.in,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,goo.gl,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,goodreaders.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,goodreads.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,gravatar.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,gstatic.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,gvt0.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,hockeyapp.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,hotmail.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,icons8.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ift.tt,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ifttt.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,iherb.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,imageshack.us,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,img.ly,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,imgur.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,imore.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,instapaper.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ipn.li,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,is.gd,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,issuu.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,itgonglun.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,itun.es,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ixquick.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,j.mp,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,js.revsci.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,jshint.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,jtvnw.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,justgetflux.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,kat.cr,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,klip.me,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,libsyn.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,licdn.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,linkedin.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,linode.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,lithium.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,littlehj.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,live.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,live.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,livefilestore.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,llnwd.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,macid.co,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,macromedia.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,macrumors.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,mashable.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,mathjax.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,medium.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,mega.co.nz,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,mega.nz,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,megaupload.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,microsofttranslator.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,mindnode.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,mobile01.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,modmyi.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,msedge.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,myfontastic.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,name.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,nextmedia.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,nsstatic.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,nssurge.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,nyt.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,nytimes.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,office365.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,omnigroup.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,onedrive.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,onedrive.live.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,onenote.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ooyala.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,openvpn.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,openwrt.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,orkut.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,osxdaily.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,outlook.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ow.ly,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,paddleapi.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,parallels.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,parse.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,pdfexpert.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,periscope.tv,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,pinboard.in,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,pinterest.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,pixelmator.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,pixiv.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,playpcesor.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,playstation.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,playstation.com.hk,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,playstation.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,playstationnetwork.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,pushwoosh.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,rime.im,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,servebom.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sfx.ms,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,shadowsocks.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sharethis.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,shazam.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,skype.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,smartdnsProxy.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,smartmailcloud.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sndcdn.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sony.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,soundcloud.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sourceforge.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,spotify.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,squarespace.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,sstatic.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,st.luluku.pw,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,stackoverflow.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,startpage.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,staticflickr.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,steamcommunity.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,symauth.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,symcb.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,symcd.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tapbots.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tapbots.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tdesktop.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,techcrunch.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,techsmith.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,thepiratebay.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,theverge.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,time.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,timeinc.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tiny.cc,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tinypic.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tmblr.co,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,todoist.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,trello.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,trustasiassl.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tumblr.co,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tumblr.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tweetdeck.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,tweetmarker.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,twitch.tv,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,txmblr.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,typekit.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ubertags.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ublock.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ubnt.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ulyssesapp.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,urchin.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,usertrust.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,v.gd,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,vimeo.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,vimeocdn.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,vine.co,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,vivaldi.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,vox-cdn.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,vsco.co,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,vultr.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,w.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,w3schools.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,webtype.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,wikiwand.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,wikileaks.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,wikimedia.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,wikipedia.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,wikipedia.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,windows.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,windows.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,wire.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,wordpress.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,workflowy.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,wp.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,wsj.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,wsj.net,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,xda-developers.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,xeeno.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,xiti.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,yahoo.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,yimg.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ying.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,yoyo.org,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,ytimg.com,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,telegra.ph,Proxy&#x27;</span><br><span class="line">    - &#x27;DOMAIN-SUFFIX,telegram.org,Proxy&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,91.108.56.0/22,Proxy&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,91.108.4.0/22,Proxy&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,91.108.8.0/22,Proxy&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,109.239.140.0/24,Proxy&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,149.154.160.0/20,Proxy&#x27;</span><br><span class="line">    - &#x27;IP-CIDR,149.154.164.0/22,Proxy&#x27;</span><br><span class="line">    - &#x27;MATCH,Proxy&#x27;</span><br></pre></td></tr></table></figure>




<h3 id="非简略版"><a href="#非简略版" class="headerlink" title="非简略版"></a>非简略版</h3><p>我写了一个脚本放在了<a href="https://github.com/cuiwenyao/trojan-auto-install">GitHub</a>上.</p>
<p>这个版本主要实现了输入自己的域名和密码。</p>
<p>现在试着进行自动获取证书。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/cuiwenyao/trojan-auto-install/master/trojan-install.sh &amp;&amp; chmod +x trojan-install.sh &amp;&amp; ./trojan-install.sh</span><br></pre></td></tr></table></figure>

<h4 id="自动获取证书"><a href="#自动获取证书" class="headerlink" title="自动获取证书"></a>自动获取证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装 socat for acme</span></span><br><span class="line">apt -y install socat</span><br><span class="line"><span class="comment">#acme</span></span><br><span class="line">curl https://get.acme.sh | sh</span><br><span class="line">systemctl stop trojan</span><br><span class="line">systemctl stop nginx</span><br><span class="line">green <span class="string">&quot;注册acme for <span class="variable">$&#123;trojan_email&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">~/.acme.sh/acme.sh --register-account -m <span class="variable">$&#123;trojan_email&#125;</span></span><br><span class="line">systemctl stop nginx</span><br><span class="line">systemctl stop trojan</span><br><span class="line">rm -rf ~/.acme/<span class="variable">$&#123;trojan_domain&#125;</span></span><br><span class="line">~/.acme.sh/acme.sh  --issue --standalone -d <span class="variable">$&#123;trojan_domain&#125;</span></span><br><span class="line"></span><br><span class="line">green <span class="string">&quot;安装证书 for <span class="variable">$&#123;trojan_domain&#125;</span>&quot;</span></span><br><span class="line">rm -rf /etc/trojan/trojancert/<span class="variable">$&#123;trojan_domain&#125;</span>/</span><br><span class="line">mkdir -p /etc/trojan/trojancert/<span class="variable">$&#123;trojan_domain&#125;</span>/</span><br><span class="line">~/.acme.sh/acme.sh  --installcert  -d  <span class="variable">$&#123;trojan_domain&#125;</span>   \</span><br><span class="line">    --key-file   /etc/trojan/trojancert/<span class="variable">$&#123;trojan_domain&#125;</span>/private.key \</span><br><span class="line">    --fullchain-file  /etc/trojan/trojancert/<span class="variable">$&#123;trojan_domain&#125;</span>/fullchain.cer \</span><br><span class="line">    --reloadcmd  <span class="string">&quot;systemctl restart trojan&quot;</span>	</span><br></pre></td></tr></table></figure>

<h4 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#写入nginx配置</span></span><br><span class="line">green <span class="string">&quot;正在写入nginx配置文件 /etc/nginx/nginx.conf&quot;</span></span><br><span class="line">rm /etc/nginx/nginx.conf</span><br><span class="line">        cat &gt; /etc/nginx/nginx.conf &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">user  root;</span></span><br><span class="line"><span class="string">worker_processes  1;</span></span><br><span class="line"><span class="string">error_log  /var/log/nginx/error.log warn;</span></span><br><span class="line"><span class="string">pid        /var/run/nginx.pid;</span></span><br><span class="line"><span class="string">events &#123;</span></span><br><span class="line"><span class="string">    worker_connections  1024;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">http &#123;</span></span><br><span class="line"><span class="string">    include       /etc/nginx/mime.types;</span></span><br><span class="line"><span class="string">    default_type  application/octet-stream;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    access_log  /var/log/nginx/access.log;</span></span><br><span class="line"><span class="string">    sendfile        on;</span></span><br><span class="line"><span class="string">    keepalive_timeout  120;</span></span><br><span class="line"><span class="string">    client_max_body_size 20m;</span></span><br><span class="line"><span class="string">    server &#123;</span></span><br><span class="line"><span class="string">        listen       80;</span></span><br><span class="line"><span class="string">        server_name  $&#123;trojan_domain&#125;;</span></span><br><span class="line"><span class="string">        root /etc/nginx/html;</span></span><br><span class="line"><span class="string">        index index.php index.html index.htm;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入配置文件</span></span><br><span class="line">rm /etc/trojan/config.json</span><br><span class="line">    cat &gt; /etc/trojan/config.json &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;run_type&quot;: &quot;server&quot;,</span></span><br><span class="line"><span class="string">    &quot;local_addr&quot;: &quot;0.0.0.0&quot;,</span></span><br><span class="line"><span class="string">    &quot;local_port&quot;: 443,</span></span><br><span class="line"><span class="string">    &quot;remote_addr&quot;: &quot;127.0.0.1&quot;,</span></span><br><span class="line"><span class="string">    &quot;remote_port&quot;: 80,</span></span><br><span class="line"><span class="string">    &quot;password&quot;: [</span></span><br><span class="line"><span class="string">        &quot;$trojan_passwd&quot;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    &quot;log_level&quot;: 1,</span></span><br><span class="line"><span class="string">    &quot;ssl&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;cert&quot;: &quot;/etc/trojan/trojancert/$&#123;trojan_domain&#125;/fullchain.cer&quot;,</span></span><br><span class="line"><span class="string">        &quot;key&quot;: &quot;/etc/trojan/trojancert/$&#123;trojan_domain&#125;/private.key&quot;,</span></span><br><span class="line"><span class="string">        &quot;key_password&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">        &quot;cipher&quot;: &quot;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384&quot;,</span></span><br><span class="line"><span class="string">        &quot;cipher_tls13&quot;: &quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;,</span></span><br><span class="line"><span class="string">        &quot;prefer_server_cipher&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;alpn&quot;: [</span></span><br><span class="line"><span class="string">            &quot;http/1.1&quot;</span></span><br><span class="line"><span class="string">        ],</span></span><br><span class="line"><span class="string">        &quot;alpn_port_override&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;h2&quot;: 81</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &quot;reuse_session&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;session_ticket&quot;: false,</span></span><br><span class="line"><span class="string">        &quot;session_timeout&quot;: 600,</span></span><br><span class="line"><span class="string">        &quot;plain_http_response&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">        &quot;curves&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">        &quot;dhparam&quot;: &quot;&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;tcp&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;prefer_ipv4&quot;: false,</span></span><br><span class="line"><span class="string">        &quot;no_delay&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;keep_alive&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;reuse_port&quot;: false,</span></span><br><span class="line"><span class="string">        &quot;fast_open&quot;: false,</span></span><br><span class="line"><span class="string">        &quot;fast_open_qlen&quot;: 20</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;mysql&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;enabled&quot;: false,</span></span><br><span class="line"><span class="string">        &quot;server_addr&quot;: &quot;127.0.0.1&quot;,</span></span><br><span class="line"><span class="string">        &quot;server_port&quot;: 3306,</span></span><br><span class="line"><span class="string">        &quot;database&quot;: &quot;trojan&quot;,</span></span><br><span class="line"><span class="string">        &quot;username&quot;: &quot;trojan&quot;,</span></span><br><span class="line"><span class="string">        &quot;password&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">        &quot;key&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">        &quot;cert&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">        &quot;ca&quot;: &quot;&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意这里，user默认值为nobody导致服务没有办法正常运行，改为root</span></span><br><span class="line">rm /lib/systemd/system/trojan.service</span><br><span class="line">    cat &gt; /lib/systemd/system/trojan.service &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=trojan</span></span><br><span class="line"><span class="string">Documentation=man:trojan(1) https://trojan-gfw.github.io/trojan/config https://trojan-gfw.github.io/trojan/</span></span><br><span class="line"><span class="string">After=network.target network-online.target nss-lookup.target mysql.service mariadb.service mysqld.service</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=simple</span></span><br><span class="line"><span class="string">StandardError=journal</span></span><br><span class="line"><span class="string">User=root</span></span><br><span class="line"><span class="string">AmbientCapabilities=CAP_NET_BIND_SERVICE</span></span><br><span class="line"><span class="string">ExecStart=/usr/bin/trojan /etc/trojan/config.json</span></span><br><span class="line"><span class="string">ExecReload=/bin/kill -HUP $MAINPID</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string">RestartSec=3s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="一键脚本"><a href="#一键脚本" class="headerlink" title="一键脚本"></a>一键脚本</h4><p>为了方便再次配置Trojan，我将整个过程写成了一个脚本，放在了<a href="https://github.com/cuiwenyao/trojan-auto-install">GitHub上</a></p>
<p>你也可以直接使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/cuiwenyao/trojan-auto-install/master/trojan-install.sh &amp;&amp; chmod +x trojan-install.sh &amp;&amp; ./trojan-install.sh</span><br></pre></td></tr></table></figure>

<p>安装bbr加速模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate <span class="string">&quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;</span> &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span><br></pre></td></tr></table></figure>

<p>这次搞这个trojan着实麻烦，好在弄好了，我的Linux技术也增加了一点点。去学习数据结构了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>proxy</tag>
        <tag>trojan</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 编程</title>
    <url>/2021/05/06/shell-%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="shell-编程"><a href="#shell-编程" class="headerlink" title="shell 编程"></a>shell 编程</h1><ul>
<li>最近在用Linux倒腾一些东西，发现好多东西都可以使用写成一个shell脚本来简化，所以学习一下shell.</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello,world!&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="shell-变量"><a href="#shell-变量" class="headerlink" title="shell 变量"></a>shell 变量</h4> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意不能加空格</span></span><br><span class="line">myname=<span class="string">&quot;cuiwenyao&quot;</span></span><br><span class="line">echo $&#123;myname&#125;</span><br><span class="line">hername=<span class="string">&quot;qinmengyao&quot;</span></span><br><span class="line">echo $&#123;myname&#125; <span class="string">&quot;love&quot;</span> $&#123;hername&#125;</span><br><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="built_in">string</span>=<span class="string">&quot;$&#123;myname&#125; &quot;</span>love<span class="string">&quot; $&#123;hername&#125;&quot;</span></span><br><span class="line">echo <span class="built_in">string</span></span><br><span class="line"><span class="comment">//获取长度</span></span><br><span class="line">echo $&#123;<span class="meta">#myname&#125;</span></span><br><span class="line"><span class="comment">//提取字串</span></span><br><span class="line"><span class="built_in">string</span>=$&#123;myname:<span class="number">1</span>:<span class="number">2</span>&#125;</span><br><span class="line">echo <span class="built_in">string</span></span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li>bash 只支持一维数组。</li>
<li>shell用小括号表示数组，数组元素用空格分开。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">myarray=(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line">echo $&#123;myarray[<span class="number">0</span>]&#125;</span><br><span class="line">myarray[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">echo $&#123;myarray[<span class="number">0</span>]&#125;</span><br><span class="line"><span class="comment">//获取所有元素</span></span><br><span class="line">echo $&#123;myarray[@]&#125;</span><br><span class="line"><span class="comment">//获取数组长度</span></span><br><span class="line">echo $&#123;<span class="meta">#myarray[@]&#125;</span></span><br><span class="line">echo $&#123;<span class="meta">#myarray[*]&#125;</span></span><br><span class="line"><span class="comment">//获取单个元素的长度</span></span><br><span class="line">echo $&#123;<span class="meta">#myarray[0]&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
<td>`expr $a + $b`</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>`expr $a - $b`</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>`expr $a * $b`</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>`expr $a / $b`</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>`expr $a % $b`</td>
</tr>
<tr>
<td>=</td>
<td>赋值</td>
<td>`expr $a = $b`</td>
</tr>
<tr>
<td>==</td>
<td>相等。</td>
<td>`expr $a == $b`</td>
</tr>
<tr>
<td>!=</td>
<td>不相等。</td>
<td>`expr $a != $b`</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">20</span></span><br><span class="line">r=`expr $&#123;a&#125; + $&#123;b&#125;`</span><br><span class="line">echo $&#123;r&#125;</span><br><span class="line">r=`expr $&#123;a&#125; - $&#123;b&#125;`</span><br><span class="line">echo $&#123;r&#125;</span><br><span class="line">r=`expr $&#123;a&#125; \* $&#123;b&#125;`</span><br><span class="line">echo $&#123;r&#125;</span><br><span class="line">r=`expr $&#123;a&#125; / $&#123;b&#125;`</span><br><span class="line">echo $&#123;r&#125;</span><br><span class="line">r=`expr $&#123;a&#125; % $&#123;b&#125;`</span><br><span class="line">echo $&#123;r&#125;</span><br></pre></td></tr></table></figure>
<h6 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h6><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>相等</td>
<td>[${a} -eq ${b}]</td>
</tr>
<tr>
<td>-ne</td>
<td>不相等</td>
<td>[${a} -ne ${b}]</td>
</tr>
<tr>
<td>-gt</td>
<td>大于</td>
<td>[${a} -gt ${b}]</td>
</tr>
<tr>
<td>-lt</td>
<td>小于</td>
<td>[${a} -lt ${b}]</td>
</tr>
<tr>
<td>-ge</td>
<td>大于等于</td>
<td>[${a} -ge ${b}]</td>
</tr>
<tr>
<td>-le</td>
<td>小于等于</td>
<td>[${a} -le ${b}]</td>
</tr>
<tr>
<td>!</td>
<td>非</td>
<td>[！false]</td>
</tr>
<tr>
<td>-o</td>
<td>或</td>
<td>[${a} -lt 20 -o ${b} -gt 100]</td>
</tr>
<tr>
<td>-a</td>
<td>与</td>
<td>[${a} -lt 20 -a ${b} -gt 100]</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>[[${a} -lt 20 || ${b} -gt 100]]</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>[[${a} -lt 20 &amp;&amp; ${b} -gt 100]]</td>
</tr>
</tbody></table>
<h6 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h6><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>检测两个字符串是否相等，相等返回 true。</td>
<td>[ $a = $b ] 返回 false。</td>
</tr>
<tr>
<td>!=</td>
<td>检测两个字符串是否相等，不相等返回 true。</td>
<td>[ $a != $b ] 返回 true。</td>
</tr>
<tr>
<td>-z</td>
<td>检测字符串长度是否为0，为0返回 true。</td>
<td>[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td>-n</td>
<td>检测字符串长度是否为0，不为0返回 true。</td>
<td>[ -n $a ] 返回 true。</td>
</tr>
<tr>
<td>str</td>
<td>检测字符串是否为空，不为空返回 true。</td>
<td>[ $a ] 返回 true。</td>
</tr>
</tbody></table>
<h6 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h6><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>是否是块设备文件</td>
<td>[ -b $file ]</td>
</tr>
<tr>
<td>-c</td>
<td>是否是字符设备文件</td>
<td>[ -c $file ]</td>
</tr>
<tr>
<td>-d</td>
<td>是否是目录</td>
<td>[ -d $file ]</td>
</tr>
<tr>
<td>-f</td>
<td>是否是普通文件（既不是目录，也不是设备文件）</td>
<td>[ -f $file ]</td>
</tr>
<tr>
<td>-g</td>
<td>是否设置了 SGID 位</td>
<td>[ -g $file ]</td>
</tr>
<tr>
<td>-k</td>
<td>是否设置了粘着位</td>
<td>[ -k $file ]</td>
</tr>
<tr>
<td>-p</td>
<td>是否是有名管道</td>
<td>[ -p $file ]</td>
</tr>
<tr>
<td>-u</td>
<td>是否设置了 SUID 位</td>
<td>[ -u $file ]</td>
</tr>
<tr>
<td>-r</td>
<td>文件是否可读</td>
<td>[ -r $file ]</td>
</tr>
<tr>
<td>-w</td>
<td>是否可写</td>
<td>[ -w $file ]</td>
</tr>
<tr>
<td>-x</td>
<td>是否可执行</td>
<td>[ -x $file ]</td>
</tr>
<tr>
<td>-s</td>
<td>是否为空</td>
<td>[ -s $file ]</td>
</tr>
<tr>
<td>-e</td>
<td>检测文件（包括目录）是否存在</td>
<td>[ -e $file ]</td>
</tr>
</tbody></table>
<h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><ul>
<li>shell的流程不可为空。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">num1=$[2*4]</span><br><span class="line">num2=$[1+5]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[num1] -eq 8</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个数字相等!&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span> $[num1] -lt $[num2]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个数字不相等!&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;this is else&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">array=(1 2 3 4)</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;while 测试 1&quot;</span></span><br><span class="line">var=5</span><br><span class="line"><span class="keyword">while</span> (( <span class="variable">$&#123;var&#125;</span>&lt;=10 ))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line">    var=`expr <span class="variable">$&#123;var&#125;</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;while 测试 2&quot;</span></span><br><span class="line">var=5</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">test</span> <span class="variable">$&#123;var&#125;</span> -ne 10</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">&quot;var++&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;while 测试 3&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;按下ctrl+d退出&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;输入a,b的值,我会帮你输出和&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> a b</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$&#123;a&#125;</span> -eq 10 </span><br><span class="line">    <span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;退出&quot;</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> `expr <span class="variable">$&#123;a&#125;</span> + <span class="variable">$&#123;b&#125;</span>`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;until 测试 1&quot;</span></span><br><span class="line">var=0</span><br><span class="line">until <span class="built_in">test</span> <span class="variable">$&#123;var&#125;</span> -eq 10</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line">    var=`expr <span class="variable">$&#123;var&#125;</span> + 1`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">&quot;var++&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;case 测试 1&quot;</span></span><br><span class="line">var=1</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;var&#125;</span> <span class="keyword">in</span></span><br><span class="line">1)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">2) </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;这个函数会对三个数字进行相加运算...&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;输入第一个数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;输入第二个数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> anotherNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个数字分别为 <span class="variable">$aNum</span> 和 <span class="variable">$anotherNum</span> !&quot;</span></span><br><span class="line">    <span class="built_in">return</span> $((<span class="variable">$&#123;aNum&#125;</span>+<span class="variable">$&#123;anotherNum&#125;</span>+<span class="variable">$&#123;1&#125;</span>))</span><br><span class="line">&#125;</span><br><span class="line">fun 10</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;三个数字之和为 $? !&quot;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td>$-</td>
<td>显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
<h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">. <span class="keyword">test</span>.<span class="keyword">sh</span></span><br><span class="line">source <span class="keyword">test</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>use nginx on ubuntu 18.04</title>
    <url>/2021/04/25/use-nginx-on-ubuntu-18-04/</url>
    <content><![CDATA[<h1 id="nginx-on-ubuntu-18-04"><a href="#nginx-on-ubuntu-18-04" class="headerlink" title="nginx on ubuntu 18.04"></a>nginx on ubuntu 18.04</h1><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><ol>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04">How To Install Nginx on Ubuntu 18.04</a></li>
<li><a href="http://nginx.org/en/docs/beginners_guide.html">nginx beginner’s guide</a><h4 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h4></li>
</ol>
<ul>
<li>nginx is one of the most popular web servers in the world and is responsible for hosting some of the largest and high-traffic sites on the internet. it is more resource-friendly than apache in most cases and can be used as a web server or reverse proxy.</li>
<li>in this guild, we will discuss how to install nginx on my ubuntu 18.04 server.<h4 id="step1-install-nginx"><a href="#step1-install-nginx" class="headerlink" title="step1 (install nginx)"></a>step1 (install nginx)</h4></li>
<li>because nginx is available in ubuntu’s default repositories, it is possible to install it from these repositories using the apt packaging system.</li>
<li>it may be the first interaction with the apt packaging system, so i’d like to update my local package index so that i have access to the most recent package listings. afterwards, i can install nginx<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt <span class="keyword">install</span> nginx</span><br></pre></td></tr></table></figure></li>
<li>after accepting the procedure, apt will install nginx and any required dependencies to my server.<h4 id="step2-adjusting-the-firewall"><a href="#step2-adjusting-the-firewall" class="headerlink" title="step2 (adjusting the firewall)"></a>step2 (adjusting the firewall)</h4></li>
<li>before testing nginx, the firewall software needs to be adjusted to allow access to the service. nginx registers itself as a service with ufw upon installation, making it straightforward to allow nginx access.</li>
<li>list the application configurations that ufw know how to work with by typing:<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ufw app list</span></span><br></pre></td></tr></table></figure></li>
<li>you should get a listing of the application profiles.<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">Available applications:</span><br><span class="line">  Nginx <span class="literal">Full</span></span><br><span class="line">  Nginx HTTP</span><br><span class="line">  Nginx HTTPS</span><br><span class="line">  OpenSSH</span><br></pre></td></tr></table></figure></li>
<li>Nginx Full: this profile opens both port 80(normal, unencrypted web traffic) and port 443(TLS/SSL encrypted traffic)</li>
<li>Nginx HTTP: this profile opens only the port 80.</li>
<li>Nginx HTTPS: this profile opens only port 443.</li>
<li>it is recommended that you enable the most restrictive profile that will still allow the traffic you have configured. however, i have not configured SSL for my server, i will only need to allow traffic on port 80.<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ufw <span class="builtin-name">enable</span> <span class="string">&quot;Nginx HTTP&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="checking-your-web-server"><a href="#checking-your-web-server" class="headerlink" title="checking your web server"></a>checking your web server</h4></li>
<li>at the end of the installation process, ubuntu starts nginx, the web server should already be up and running. we can check with the systemd init system to make sure the service is running by typing:<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl status nginx</span></span><br></pre></td></tr></table></figure></li>
<li>output:<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">● nginx.service - A high performance web <span class="keyword">server</span> <span class="keyword">and</span> a <span class="keyword">reverse</span> proxy <span class="keyword">server</span></span><br><span class="line">   Loaded: loaded (/lib/systemd/<span class="keyword">system</span>/nginx.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Sun <span class="number">2021</span><span class="number">-04</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">46</span>:<span class="number">15</span> CST; <span class="number">7</span>min ago</span><br><span class="line">     Docs: man:nginx(<span class="number">8</span>)</span><br><span class="line">  Process: <span class="number">1156</span> ExecStart=/usr/sbin/nginx -g daemon <span class="keyword">on</span>; master_process <span class="keyword">on</span>; (code=exited, s</span><br><span class="line">  Process: <span class="number">1039</span> ExecStartPre=/usr/sbin/nginx -t -q -g daemon <span class="keyword">on</span>; master_process <span class="keyword">on</span>; (code=</span><br><span class="line"> Main PID: <span class="number">1170</span> (nginx)</span><br><span class="line">    Tasks: <span class="number">2</span> (<span class="keyword">limit</span>: <span class="number">2121</span>)</span><br><span class="line">   CGroup: /<span class="keyword">system</span>.<span class="keyword">slice</span>/nginx.service</span><br><span class="line">           ├─<span class="number">1170</span> nginx: master process /usr/sbin/nginx -g daemon <span class="keyword">on</span>; master_process <span class="keyword">on</span>;</span><br><span class="line">           └─<span class="number">1176</span> nginx: worker process</span><br><span class="line"></span><br><span class="line">Apr <span class="number">25</span> <span class="number">17</span>:<span class="number">46</span>:<span class="number">15</span> VM<span class="number">-4</span><span class="number">-14</span>-ubuntu systemd[<span class="number">1</span>]: Starting A high performance web <span class="keyword">server</span> <span class="keyword">and</span> a re</span><br><span class="line">Apr <span class="number">25</span> <span class="number">17</span>:<span class="number">46</span>:<span class="number">15</span> VM<span class="number">-4</span><span class="number">-14</span>-ubuntu systemd[<span class="number">1</span>]: nginx.service: Failed <span class="keyword">to</span> parse PID <span class="keyword">from</span> file /r</span><br><span class="line">Apr <span class="number">25</span> <span class="number">17</span>:<span class="number">46</span>:<span class="number">15</span> VM<span class="number">-4</span><span class="number">-14</span>-ubuntu systemd[<span class="number">1</span>]: Started A high performance web <span class="keyword">server</span> <span class="keyword">and</span> a rev</span><br><span class="line">lines <span class="number">1</span><span class="number">-15</span>/<span class="number">15</span> (<span class="keyword">END</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>as you can see above, the service appears to have started successfully, however, the best way to test this is to actually request a page from nginx.</li>
<li>you can access the default nginx landing page to confirm that the software is running properly by navigating to your server’s ip address. you can get your ipv4 address on the internet by typing:<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">curl</span> -<span class="number">4</span> icanhazip.com</span><br></pre></td></tr></table></figure></li>
<li>enter it to your browser’s address bar, you will see the default nginx landing page.<h4 id="step4-manager-the-nginx-process"><a href="#step4-manager-the-nginx-process" class="headerlink" title="step4 (manager the nginx process)"></a>step4 (manager the nginx process)</h4><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br><span class="line">systemctl stop nginx</span><br><span class="line">systemctl restart nginx</span><br><span class="line">systemctl reload nginx</span><br><span class="line">systemctl enable nginx</span><br><span class="line">systemctl disable nginx</span><br></pre></td></tr></table></figure>
<h4 id="step5-setting-up-server-blocks"><a href="#step5-setting-up-server-blocks" class="headerlink" title="step5 (setting up server blocks)"></a>step5 (setting up server blocks)</h4></li>
<li>when using the nginx web server, server blocks(similar to virtual hosts in apache)can be used to encapsulate configuration details and host more than one domain form a single server. i will set a domain called nginx.cuimouren.cn to test this.</li>
<li>nginx on ubuntu has one server block enabled by default that is configured to serve documents out of a directory at /var/www/html. while this works well for one single site, it can become unwieldly if you are hosting multiple sites. instead of modifying /var/www/html, let’s create a directory structure within /var/www for my nginx.cuimouren.cn site, leaving /var/www/html in place as the default directory to be served if a client request does not match any other sites.</li>
<li>create a directory for nginx.cuimouren.cn, using -p flag to create any necessary parent directories. i will using my github page as a test.<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="regexp">/var/</span>www/nginx.cuimouren.cn</span><br><span class="line">cd <span class="regexp">/var/</span>www/nginx.cuimouren.cn</span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/yishuilingbo/yi</span>shuilingbo.github.io.git</span><br><span class="line">cd yishuilingbo.github.io</span><br><span class="line">mv * ../</span><br><span class="line">rm -rf yishuilingbo.github.io</span><br></pre></td></tr></table></figure></li>
<li>in order for nginx to server this content, it’s necessary to create a server block with the correct directives, instead of modifying the default configuration file directly, let’s make a new one.<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span>nginx.cuimouren.cn</span><br></pre></td></tr></table></figure></li>
<li>write like these<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span> /var/www/nginx.cuimouren.cn;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">server_name</span> nginx.cuimouren.cn www.nginx.cuimouren.cn;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">                <span class="attribute">try_files</span> $uri $uri/ =<span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>enable the file by creating a link form it to the “sites-enabled” directory, which nginx reads from during startup<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ln -s <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span>nginx.cuimouren.cn <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-enabled/</span></span><br></pre></td></tr></table></figure></li>
<li>test to make sure that there are no syntax error in any nginx files.<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nginx -t</span></span><br></pre></td></tr></table></figure></li>
<li>restart nginx<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl restart nginx</span></span><br></pre></td></tr></table></figure></li>
<li>look my site on the browser.<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">nginx.cuimouren.<span class="literal">cn</span></span><br></pre></td></tr></table></figure>
<h4 id="step6-securing-my-domain"><a href="#step6-securing-my-domain" class="headerlink" title="step6 securing my domain"></a>step6 securing my domain</h4></li>
<li>in this section, i will secure my domain using a let’s encrypt tls sertificate, which i will provision using certbot.<br>to install the lastest version of sertbot, i will need to add its package repository to my server by running the following command:<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add</span>-apt-repository ppa:certbot/certbot</span><br><span class="line"><span class="comment">#install its nginx plugin</span></span><br><span class="line">apt install python-sertbot-nginx</span><br><span class="line">ufw allow <span class="keyword">https</span></span><br><span class="line">ufw reload</span><br><span class="line">certbot <span class="comment">--nginx -d mydomain</span></span><br></pre></td></tr></table></figure></li>
<li>i recommand to use the second option in order to maximize security.</li>
</ul>
<h4 id="step7-getting-familiar-with-important-nginx-files-and-directories"><a href="#step7-getting-familiar-with-important-nginx-files-and-directories" class="headerlink" title="step7 (getting familiar with important nginx files and directories)"></a>step7 (getting familiar with important nginx files and directories)</h4><ul>
<li>now that you know how to manage the nginx service itself, you should take a few minutes to familiarize yourself with a few important directories and files.</li>
</ul>
<h6 id="content"><a href="#content" class="headerlink" title="content"></a>content</h6><ul>
<li><strong>/var/www/html</strong><blockquote>
<p>the actual web content, which by default only consists of the nginx page you saw earlier, is served out of the <strong>/var/www/html</strong> directory, this can be changed by altering nginx configuration files.</p>
</blockquote>
</li>
</ul>
<h6 id="server-configuration"><a href="#server-configuration" class="headerlink" title="server configuration"></a>server configuration</h6><ul>
<li><p><strong>/etc/nginx</strong></p>
<blockquote>
<p>the nginx configuration direction. all of the nginx configuration files reside here.</p>
</blockquote>
</li>
<li><p>** /etc/nginx/nginx.conf**</p>
<blockquote>
<p>the main nginx configuration file. this can be modified to make changes to the nginx global configuration.</p>
</blockquote>
</li>
<li><p><strong>/etc/nginx/sites-available</strong></p>
<blockquote>
<p>the directory where per-site server blocks can be stored. nginx will not use the configuration files found in this directory unless they are linked to the <strong>sites-enabled</strong> directory. typically, all server block configuration is done in the directory, and then enabled by linking to the other directory.</p>
</blockquote>
</li>
<li><p><strong>/etc/nginx/sites-enabled</strong></p>
<blockquote>
<p>the directory where enabled per-site server blocks are stored. typically, these are created by linking to configuration files found in the <strong>sites-available</strong> directory.</p>
</blockquote>
</li>
<li><p><strong>/etc/nginx/snippets</strong></p>
<blockquote>
<p>this directory contains configuration fragments that can be included elsewhere in the nginx configuration. potentially repeatable configuration segments are good candidates for refactoring into snippets.</p>
</blockquote>
</li>
</ul>
<h6 id="server-logs"><a href="#server-logs" class="headerlink" title="server logs"></a>server logs</h6><ul>
<li><p><strong>/var/log/nginx/access.log</strong></p>
<blockquote>
<p>every request to your web server is recorded in the log file unless nginx is configured to do otherwise.</p>
</blockquote>
</li>
<li><p><strong>/var/log/nginx/error/log</strong></p>
<blockquote>
<p>any nginx error will be recorded in this log.</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>ngiinx</tag>
      </tags>
  </entry>
  <entry>
    <title>双创工作日志</title>
    <url>/2021/07/16/%E5%8F%8C%E5%88%9B%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="双创工作日志"><a href="#双创工作日志" class="headerlink" title="双创工作日志"></a>双创工作日志</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><h3 id="工作内容"><a href="#工作内容" class="headerlink" title="工作内容"></a>工作内容</h3><p>确定要做的项目的大概方向。</p>
<h3 id="存在问题及解决办法"><a href="#存在问题及解决办法" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>暂时只知道要去找做一个项目，具体要做什么还不是很清楚。还要再看看资料多了解一下前沿知识。</p>
<h3 id="体会和建议"><a href="#体会和建议" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学海无涯，想要做出一点厉害的东西只有好好学习。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h3 id="工作内容-1"><a href="#工作内容-1" class="headerlink" title="工作内容"></a>工作内容</h3><p>确定了项目的大概方向是做一个3D方向的软件。</p>
<h3 id="存在问题及解决办法-1"><a href="#存在问题及解决办法-1" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>只是直到项目大概要做一个3D方向的软件，至于真正的要做出来什么还不确定。</p>
<h3 id="体会和建议-1"><a href="#体会和建议-1" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>要好好学习，多学习一些技术才能在要做事情的时候不至于只知道做什么。</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><h3 id="工作内容-2"><a href="#工作内容-2" class="headerlink" title="工作内容"></a>工作内容</h3><p>查阅大量资料，了解有关3D的知识，直到制作一个3D场景的途径和相关知识。</p>
<h3 id="存在问题及解决办法-2"><a href="#存在问题及解决办法-2" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>虽然知道了有关3D的相关知识，涉及到了有关3D的一些领域。但是对于真正的使用3D知识做出来一些东西还是没有什么确切的了解。需要继续学习。</p>
<h3 id="体会和建议-2"><a href="#体会和建议-2" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>永远都到学习，只有学习的东西足够的多才能直到自己可以做出什么。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><h3 id="工作内容-3"><a href="#工作内容-3" class="headerlink" title="工作内容"></a>工作内容</h3><p>了解有关3D图像学的知识，知道了图形学的集大成者，游戏引擎。于是确定目标要做一个游戏引擎。</p>
<h3 id="存在问题及解决办法-3"><a href="#存在问题及解决办法-3" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>虽然确定了目标是做出一个游戏引擎，但是对于相关领域的知识还是知之甚少。需要继续学习。</p>
<h3 id="体会和建议-3"><a href="#体会和建议-3" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>确定了目标说明对一件事情的了解至少到达了一定的程度，但是还远没有到达可以运用知识的程度，需要继续学习。</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><h3 id="工作内容-4"><a href="#工作内容-4" class="headerlink" title="工作内容"></a>工作内容</h3><p>学习了有关游戏引擎的相关知识，知道了当今在游戏引擎领域的相关软件，比如虚幻引擎和u3d等等。</p>
<h3 id="存在问题及解决办法-4"><a href="#存在问题及解决办法-4" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>不知道一个游戏引擎的具体组成和功能，需要亲自使用相关游戏引擎才可以直到游戏引擎的相关使用和功能。</p>
<h3 id="体会和建议-4"><a href="#体会和建议-4" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>要多多了解相关领域的知识。</p>
<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><h3 id="工作内容-5"><a href="#工作内容-5" class="headerlink" title="工作内容"></a>工作内容</h3><p>学习游戏引擎，了解u3d和虚幻引擎的基本使用方法和功能，学会游戏引擎的基本使用方法，学会制作一个游戏的基本路径。</p>
<h3 id="存在问题及解决办法-5"><a href="#存在问题及解决办法-5" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>没有深入了解制作一个游戏所需的知识，不知道支撑起一个游戏所需要的知识。</p>
<h3 id="体会和建议-5"><a href="#体会和建议-5" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>要继续学习游戏引擎的相关知识，最好使用虚幻引擎亲自做出来一个游戏来加深对游戏制作的了解。</p>
<h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><h3 id="工作内容-6"><a href="#工作内容-6" class="headerlink" title="工作内容"></a>工作内容</h3><p>使用虚幻引擎做出来了一个小的第一人人称射击游戏的Demo，基本了解了制作一个游戏所需要的基础和资源，以及制作一个游戏的路径。</p>
<h3 id="存在问题及解决办法-6"><a href="#存在问题及解决办法-6" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>虽然可以使用市场上有的游戏引擎做出一个小的Demo，但是对制作一个游戏引擎仍然只知甚少，需要继续了解计算机图形学和游戏引擎的基础功能架构。</p>
<h3 id="体会和建议-6"><a href="#体会和建议-6" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>持续学习，不断增强自身技术才能制作出来一个好的软件。</p>
<h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><h3 id="工作内容-7"><a href="#工作内容-7" class="headerlink" title="工作内容"></a>工作内容</h3><p>深入学习了游戏引擎的基本功能逻辑，了解制作出一个游戏引擎所需要的基础。了解了计算机图形学相关知识，对制作出一个游戏引擎有了更加深入的了解。</p>
<h3 id="存在问题及解决办法-7"><a href="#存在问题及解决办法-7" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>计算机图形学基础太薄弱，需要深入学习计算机图形学。</p>
<h3 id="体会和建议-7"><a href="#体会和建议-7" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境，计算机图形学是一个令人着迷的领域。</p>
<h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><h3 id="工作内容-8"><a href="#工作内容-8" class="headerlink" title="工作内容"></a>工作内容</h3><p>深入学习计算机图形学，了解计算机图形学领域的三大名剑–OpenGL、vulkan、direct3D<br>在斟酌了其中的使用范围之后，我们为了增强项目的可移植性，最终选择了使用OpenGL作为项目的基础。</p>
<h3 id="存在问题及解决办法-8"><a href="#存在问题及解决办法-8" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>要继续学习计算机图形学，首先要深入学习OpenGL，下一步要做的事情就是深入学习OpenGL。</p>
<h3 id="体会和建议-8"><a href="#体会和建议-8" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>计算机图形学真不愧被称作计算机领域的三大浪漫之一，果然难度挺高的。好好学习。</p>
<h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><h3 id="工作内容-9"><a href="#工作内容-9" class="headerlink" title="工作内容"></a>工作内容</h3><p>深入学习计算机图形学，深入学OpenGL，并使用OpenGL做出了一些3D空间的小Demo。</p>
<h3 id="存在问题及解决办法-9"><a href="#存在问题及解决办法-9" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>虽然OpenGL入门挺难的，但是OpenGL的精通也是挺难的，不过要知难而上，好好学习。</p>
<h3 id="体会和建议-9"><a href="#体会和建议-9" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>艰苦奋斗，好好学习。</p>
<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><h3 id="工作内容-10"><a href="#工作内容-10" class="headerlink" title="工作内容"></a>工作内容</h3><p>深入学习计算机图形学，深入学OpenGL，并使用OpenGL做出了更多3D空间的小Demo。初步验证了制作一个游戏引擎的可行性。</p>
<h3 id="存在问题及解决办法-10"><a href="#存在问题及解决办法-10" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>计算机图形学是一个非常复杂的学科，目前为止还不能确定到底可不可以很好的制作出一个游戏引擎。要继续学习。</p>
<h3 id="体会和建议-10"><a href="#体会和建议-10" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><h3 id="工作内容-11"><a href="#工作内容-11" class="headerlink" title="工作内容"></a>工作内容</h3><p>继续学习计算机图形学，现在已经可以使用OpenGL做出一个想要的3D场景了，下一步要将模型的导入学会，这样在场景中就不只有自己写的顶点组成的模型了，就可以做出一个任意的3D场景。</p>
<h3 id="存在问题及解决办法-11"><a href="#存在问题及解决办法-11" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>目前对于3D场景中的模型加载仍然有很大的问题，只是一个难点，要继续深入学习。</p>
<h3 id="体会和建议-11"><a href="#体会和建议-11" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><h3 id="工作内容-12"><a href="#工作内容-12" class="headerlink" title="工作内容"></a>工作内容</h3><p>深入学习了适应assimop加载模型的方法，现在已经可以使用assimp加载模型了。</p>
<h3 id="存在问题及解决办法-12"><a href="#存在问题及解决办法-12" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>assimp有一些问题，有一些模型没有办法正常导入，头疼。</p>
<h3 id="体会和建议-12"><a href="#体会和建议-12" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2><h3 id="工作内容-13"><a href="#工作内容-13" class="headerlink" title="工作内容"></a>工作内容</h3><p>现在终于对计算机图形学有了很深的了解了，虽然对于在这个领域深耕多年的前辈来讲我只是一个菜鸟罢了，但是制作出一个简易的3D引擎来讲可以说是足够了。</p>
<h3 id="存在问题及解决办法-13"><a href="#存在问题及解决办法-13" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>虽然具备了计算机图形学的相关知识，但是对于制作出一个游戏引擎仍然没有一定的了解。需要深入思考游戏引擎的设计和功能。</p>
<h3 id="体会和建议-13"><a href="#体会和建议-13" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><h3 id="工作内容-14"><a href="#工作内容-14" class="headerlink" title="工作内容"></a>工作内容</h3><p>深入思考了游戏引擎的架构，确定了制作游戏引擎的步骤和方法。</p>
<h3 id="存在问题及解决办法-14"><a href="#存在问题及解决办法-14" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>对是否可以使用计算机图形学进行游戏引擎的开饭仍然不太确定，需要制作出一个Demo进行验证。</p>
<h3 id="体会和建议-14"><a href="#体会和建议-14" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><h3 id="工作内容-15"><a href="#工作内容-15" class="headerlink" title="工作内容"></a>工作内容</h3><p>继续确定游戏引擎的额架构，确定游戏引擎所需要的模块功能。开始制作游戏引擎Demo来验证想法。</p>
<h3 id="存在问题及解决办法-15"><a href="#存在问题及解决办法-15" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>没有制作大型项目的经验，所以制作大型项目不太熟练，对于协同开发的版本控制也是处于要学习的阶段。要学习一些版本控制进行协同开发。</p>
<h3 id="体会和建议-15"><a href="#体会和建议-15" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境</p>
<h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><h3 id="工作内容-16"><a href="#工作内容-16" class="headerlink" title="工作内容"></a>工作内容</h3><p>学习了版本控制相关知识，学习使用git进行开发。将开发的源代码使用GitHub进行共享。</p>
<h3 id="存在问题及解决办法-16"><a href="#存在问题及解决办法-16" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>虽然解决了开发工具的问题和协同开发中的版本控制的问题，但是对于游戏引擎的开发仍然需要努力写出一个小的Demo来验证想法的正确性。</p>
<h3 id="体会和建议-16"><a href="#体会和建议-16" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境</p>
<h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><h3 id="工作内容-17"><a href="#工作内容-17" class="headerlink" title="工作内容"></a>工作内容</h3><p>加班加点努力做出来了一个3D游戏币引擎Demo，现在可以实现使用几条很短的额代码就可以加载出一个宏大的3D场景。</p>
<h3 id="存在问题及解决办法-17"><a href="#存在问题及解决办法-17" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>C++的面向对象有点烦人，先前制作的游戏引擎架构在进行初步实现的时候发现了一些问题。引擎的结构框架在c++的特性下没有办法很好的实现，迫于语言的限制，只好在一定范围内修改游戏引擎的架构来适应c++的特性。</p>
<h3 id="体会和建议-17"><a href="#体会和建议-17" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境</p>
<h2 id="19"><a href="#19" class="headerlink" title="19"></a>19</h2><h3 id="工作内容-18"><a href="#工作内容-18" class="headerlink" title="工作内容"></a>工作内容</h3><p>使用修改过后的引擎架构做出了一个小的Demo，现在的Demo已经可以拥有灯光等高级更能。</p>
<h3 id="存在问题及解决办法-18"><a href="#存在问题及解决办法-18" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>是时候基于现有的Demo做出一个真正的游戏引擎了，有了Demo的经验，要制作一个真正的游戏引擎也不是无稽之谈了，但是现在由于引擎的规模变大，先前的架构有一些地方不太适合了，需要因地制宜地修改项目的架构。</p>
<h3 id="体会和建议-18"><a href="#体会和建议-18" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境</p>
<h2 id="20"><a href="#20" class="headerlink" title="20"></a>20</h2><h3 id="工作内容-19"><a href="#工作内容-19" class="headerlink" title="工作内容"></a>工作内容</h3><p>现在基于先前的经验因地制宜地修改了项目的架构。现在的任务是基于这个新的架构制作出一个全新的游戏引擎。</p>
<h3 id="存在问题及解决办法-19"><a href="#存在问题及解决办法-19" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>项目大了之后，对于开发的要求也更加高了，为了更加方便的进行协同开发，我们开发人员组建了一个开发交流群，得益于交流的效率加深，现在进行开发就很方便了。</p>
<h3 id="体会和建议-19"><a href="#体会和建议-19" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境</p>
<h2 id="21"><a href="#21" class="headerlink" title="21"></a>21</h2><h3 id="工作内容-20"><a href="#工作内容-20" class="headerlink" title="工作内容"></a>工作内容</h3><p>现在进行真正的游戏引擎开发工作。游戏引擎制作中。</p>
<h3 id="存在问题及解决办法-20"><a href="#存在问题及解决办法-20" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>项目很大，架构很大，每一次编译都要好长时间。</p>
<h3 id="体会和建议-20"><a href="#体会和建议-20" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="22"><a href="#22" class="headerlink" title="22"></a>22</h2><h3 id="工作内容-21"><a href="#工作内容-21" class="headerlink" title="工作内容"></a>工作内容</h3><p>完成项目的局部驱动。</p>
<h3 id="存在问题及解决办法-21"><a href="#存在问题及解决办法-21" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>局部驱动要和全局驱动整合起来，所以要进行全局驱动的编写。</p>
<h3 id="体会和建议-21"><a href="#体会和建议-21" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="23"><a href="#23" class="headerlink" title="23"></a>23</h2><h3 id="工作内容-22"><a href="#工作内容-22" class="headerlink" title="工作内容"></a>工作内容</h3><p>完成项目的全局驱动。</p>
<h3 id="存在问题及解决办法-22"><a href="#存在问题及解决办法-22" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>项目的驱动已经完成，现在需要将物体表达出来。</p>
<h3 id="体会和建议-22"><a href="#体会和建议-22" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="24"><a href="#24" class="headerlink" title="24"></a>24</h2><h3 id="工作内容-23"><a href="#工作内容-23" class="headerlink" title="工作内容"></a>工作内容</h3><p>编写Element代码，现在将物体的表示码了出来。</p>
<h3 id="存在问题及解决办法-23"><a href="#存在问题及解决办法-23" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>物体的架构安排有一些不合理需要进行思考更改。</p>
<h3 id="体会和建议-23"><a href="#体会和建议-23" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="25"><a href="#25" class="headerlink" title="25"></a>25</h2><h3 id="工作内容-24"><a href="#工作内容-24" class="headerlink" title="工作内容"></a>工作内容</h3><p>完成资源管理的编写，现在可以很方便的进行资源的管理了。</p>
<h3 id="存在问题及解决办法-24"><a href="#存在问题及解决办法-24" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>虽然资源管理可以实现，但是只是在方法层面上的实现，需要在应用上进行实现。</p>
<h3 id="体会和建议-24"><a href="#体会和建议-24" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="26"><a href="#26" class="headerlink" title="26"></a>26</h2><h3 id="工作内容-25"><a href="#工作内容-25" class="headerlink" title="工作内容"></a>工作内容</h3><p>完成场景的编写，现在可以实现一个场景带动全部代码。</p>
<h3 id="存在问题及解决办法-25"><a href="#存在问题及解决办法-25" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>加载场景仍然有一些繁琐，需要一个个的进行写入路径，这些代码集中在主程序中不雅观。</p>
<h3 id="体会和建议-25"><a href="#体会和建议-25" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="27"><a href="#27" class="headerlink" title="27"></a>27</h2><h3 id="工作内容-26"><a href="#工作内容-26" class="headerlink" title="工作内容"></a>工作内容</h3><p>完成场景加载XML的实现，现在可以使用xml文件将场景的信息加载出来，非常优雅。</p>
<h3 id="存在问题及解决办法-26"><a href="#存在问题及解决办法-26" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>现在虽然游戏引擎在开发中可以很方便的进行使用了，但是怎样让用户方便的使用是一个问题。于是决定将项目以开源的形式进行开源。使用cmake进行开源发布。</p>
<h3 id="体会和建议-26"><a href="#体会和建议-26" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="28"><a href="#28" class="headerlink" title="28"></a>28</h2><h3 id="工作内容-27"><a href="#工作内容-27" class="headerlink" title="工作内容"></a>工作内容</h3><p>将项目使用cmake进行构建，这样用户就可以使用cmake很方便的进行项目的构建了。</p>
<h3 id="存在问题及解决办法-27"><a href="#存在问题及解决办法-27" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>项目需要有门面</p>
<h3 id="体会和建议-27"><a href="#体会和建议-27" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境</p>
<h2 id="29"><a href="#29" class="headerlink" title="29"></a>29</h2><h3 id="工作内容-28"><a href="#工作内容-28" class="headerlink" title="工作内容"></a>工作内容</h3><p>完成项目的网站制作，现在用户在网站上就可以方便的进行引擎的下载和学习、开发了。</p>
<h3 id="存在问题及解决办法-28"><a href="#存在问题及解决办法-28" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>引擎使用文档不够仔细，需要认真编写引擎的使用文档。</p>
<h3 id="体会和建议-28"><a href="#体会和建议-28" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h2 id="30"><a href="#30" class="headerlink" title="30"></a>30</h2><h3 id="工作内容-29"><a href="#工作内容-29" class="headerlink" title="工作内容"></a>工作内容</h3><p>工作结尾，引擎项目到达尾声。开始收尾工作。编写项目的各种文档。</p>
<h3 id="存在问题及解决办法-29"><a href="#存在问题及解决办法-29" class="headerlink" title="存在问题及解决办法"></a>存在问题及解决办法</h3><p>引擎还有很大的成长空间。祝他越来越好。</p>
<h3 id="体会和建议-29"><a href="#体会和建议-29" class="headerlink" title="体会和建议"></a>体会和建议</h3><p>学习永无止境。</p>
<h1 id="时间-共-30-个"><a href="#时间-共-30-个" class="headerlink" title="时间  共 30 个"></a>时间  共 30 个</h1><p>10 29   1</p>
<p>11 06   2</p>
<p>11 14   3</p>
<p>11 22   4</p>
<p>11 30   5</p>
<p>12 08   6</p>
<p>12 12   7</p>
<p>12 20   8</p>
<p>12 28   9</p>
<p>1  06   10</p>
<p>1  14   11</p>
<p>1  22   12</p>
<p>1  30   13</p>
<p>2  08   14</p>
<p>2  24   15</p>
<p>3  04   16</p>
<p>3  12   17</p>
<p>3  20   18</p>
<p>4  05   19</p>
<p>4  13   20</p>
<p>4  21   21</p>
<p>4  29   22</p>
<p>5  07   23</p>
<p>5  23   24</p>
<p>5  31   25</p>
<p>6  09   26</p>
<p>6  17   27</p>
<p>6  25   28</p>
<p>7  11   29</p>
<p>7  16   30</p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>nonetag</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 CentOS 搭建 Discuz 论坛</title>
    <url>/2021/04/19/%E5%9F%BA%E4%BA%8E-CentOS-%E6%90%AD%E5%BB%BA-Discuz-%E8%AE%BA%E5%9D%9B/</url>
    <content><![CDATA[<h1 id="基于-CentOS-搭建-Discuz-论坛"><a href="#基于-CentOS-搭建-Discuz-论坛" class="headerlink" title="基于 CentOS 搭建 Discuz 论坛"></a>基于 CentOS 搭建 Discuz 论坛</h1><h4 id="准备LAMP环境"><a href="#准备LAMP环境" class="headerlink" title="准备LAMP环境"></a>准备LAMP环境</h4><ul>
<li>LAMP 是 Linux、Apache、MySQL 和 PHP 的缩写，是 Discuz 论坛系统依赖的基础运行环境。</li>
<li>MySQL<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">yum -y install mysql-<span class="keyword">server</span> </span><br><span class="line">service mysqld <span class="keyword">restart</span></span><br><span class="line">设置MySQL的账户和密码</span><br><span class="line">/usr/bin/mysqladmin -u root <span class="keyword">password</span> <span class="string">&#x27;mypassword&#x27;</span> </span><br><span class="line">设置开机自启动</span><br><span class="line">chkconfig mysqld <span class="keyword">on</span></span><br></pre></td></tr></table></figure></li>
<li>apache<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> httpd</span><br><span class="line">service httpd restart</span><br><span class="line">chkconfig httpd <span class="keyword">on</span></span><br></pre></td></tr></table></figure></li>
<li>php<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> php php-fpm -php-mysql -y</span><br><span class="line">service php-fpm restart</span><br><span class="line">查看php-fpm 进程监听的窗口</span><br><span class="line">netstat -nlpt |grep php-fpm</span><br><span class="line">chkconfig php-fpm <span class="keyword">on</span></span><br></pre></td></tr></table></figure></li>
<li>discuz<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">下载</span><br><span class="line">wget https:<span class="regexp">//</span>labs-<span class="number">1253675457</span>.cos.ap-guangzhou.myqcloud.com/Discuz_X3.<span class="number">2</span>_SC_UTF8.zip</span><br><span class="line">unzip Discuz_X3.<span class="number">2</span>_SC_UTF8.zip</span><br><span class="line">由于PHP默认访问 <span class="regexp">/var/</span>www<span class="regexp">/html/</span> 文件夹，所以我们需要把upload文件夹里的文件都复制到 <span class="regexp">/var/</span>www<span class="regexp">/html/</span> 文件夹</span><br><span class="line">cp -r upload<span class="regexp">/* /</span>var<span class="regexp">/www/</span>html/</span><br><span class="line">给 <span class="regexp">/var/</span>www/html 目录及其子目录赋予权限</span><br><span class="line">chmod -R <span class="number">777</span> <span class="regexp">/var/</span>www/html</span><br><span class="line">service httpd restart</span><br></pre></td></tr></table></figure></li>
<li>域名</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>discuz</tag>
      </tags>
  </entry>
  <entry>
    <title>学百年党史，做红色传人</title>
    <url>/2021/06/09/%E5%AD%A6%E7%99%BE%E5%B9%B4%E5%85%9A%E5%8F%B2%EF%BC%8C%E5%81%9A%E7%BA%A2%E8%89%B2%E4%BC%A0%E4%BA%BA/</url>
    <content><![CDATA[<p>一百年来，中国共产党从小到大、由弱到强，一路艰辛、一路奋斗，在中华民族的历史上谱写了前所未有的辉煌篇章，在人类发展史上创造了世所罕见的伟大奇迹。在我们党的百年发展历程中，有无数感天动地的红色故事，正是这一个个生动精彩的故事，构成了一部波澜壮阔、气壮山河的党的史诗。中国共产党带领着中国人民高举着中国特色社会主义伟大旗帜稳步迈向中华民族伟大复兴新征程。<br>农业是大国的立国之本，中国是一个十几亿人口的大国，要有坚实的农业基础。务农重本，国之大纲。对于我国这样一个人口众多的大国来说，解决好吃饭问题始终是治国理政的头等大事。新中国成立以来，在我们党的领导下，我国粮食生产在不懈探索和制度创新中取得新突破、实现新跨越。习近平总书记指出：“农业是基础性产业，中国现代化离不开农业现代化。”“农业农村现代化是实施乡村振兴战略的总目标，坚持农业农村优先发展是总方针，产业兴旺、生态宜居、乡风文明、治理有效、生活富裕是总要求，建立健全保障城乡融合发展体制机制和政策体系是制度保障。”回望历史，中国共产党成立后，充分认识到中国革命的基本问题是农民问题，把为广大农民谋幸福作为重要使命。改革开放以来，我们党领导亿万农民率先拉开改革大幕，不断解放和发展农村社会生产力，推动农村全面进步。党的十八大以来，以习近平同志为核心的党中央把解决好“三农”问题作为全党工作的重中之重，坚持农业农村优先发展总方针，启动实施乡村振兴战略，深化农业供给侧结构性改革，高度重视粮食生产，高屋建瓴地提出了国家粮食安全新战略，我国农业生产取得历史性成就，走出了一条中国特色粮食安全之路。习近平总书记指出，新形势下，要着力解决农业发展中存在的深层次矛盾和问题，重点从农产品结构、抗风险能力、农业现代化水平上发力。党的十八大以来，农业供给侧结构性改革不断深化，农业发展从增产导向转向提质导向，供给体系的质量效益不断提升。没有农业农村现代化，就没有整个国家现代化。党的十八大以来，我国农业生产方式、组织方式、管理方式发生了深刻变革，农业现代化稳步推进，从农业大国向农业强国迈进。广大干部群众表示，站在“两个一百年”奋斗目标的历史交汇点上，要坚持以习近平新时代中国特色社会主义思想为指导，全面推进乡村振兴战略，加快农业农村现代化。全面建设社会主义现代化国家，实现中华民族伟大复兴，最艰巨最繁重的任务在农村，最广泛最深厚的基础在农村。当前，向第二个百年奋斗目标进军的号角已经吹响，让我们坚持以习近平新时代中国特色社会主义思想为指导，坚定不移贯彻新发展理念，加快农业农村现代化，促进农业高质高效、乡村宜居宜业、农民富裕富足，奋力谱写新时代农业农村现代化的新篇章。<br>2021年2月25日，习近平总书记在全国脱贫攻坚总结表彰大会上庄严宣告：“经过全党全国各族人民共同努力，在迎来中国共产党成立一百周年的重要时刻，我国脱贫攻坚战取得了全面胜利，现行标准下9899万农村贫困人口全部脱贫，832个贫困县全部摘帽，12.8万个贫困村全部出列，区域性整体贫困得到解决，完成了消除绝对贫困的艰巨任务，创造了又一个彪炳史册的人间奇迹！”中国共产党从成立之日起，就坚持把为中国人民谋幸福、为中华民族谋复兴作为初心使命。新中国成立后，党组织人民自力更生、发愤图强、重整山河，为摆脱贫困、改善人民生活打下了坚实基础。改革开放以来，党团结带领人民实施了大规模、有计划、有组织的扶贫开发，取得了前所未有的伟大成就。党的十八大以来，以习近平同志为核心的党中央把脱贫攻坚摆在治国理政的突出位置，把脱贫攻坚作为全面建成小康社会的底线任务，组织开展了声势浩大的脱贫攻坚人民战争。党和人民披荆斩棘、栉风沐雨，攻克了一个又一个贫中之贫、坚中之坚，脱贫攻坚战取得了全面胜利。千年梦想，百年奋斗，圆梦今朝。这是我国经济社会发展的重大历史性成就，也是世界减贫史上的中国奇迹。改革开放以来，中国减贫人口占同期全球减贫人口70%以上。中国如期打赢脱贫攻坚战，提前10年实现《联合国2030年可持续发展议程》减贫目标。我们积极开展国际减贫合作，履行减贫国际责任，为推动构建人类命运共同体贡献了中国力量！经过8年脱贫攻坚，困扰中华民族千百年的绝对贫困问题历史性画上句号。在脱贫攻坚战中，正是靠着上下同心、尽锐出战，我们凝聚起合力攻坚的磅礴伟力。以习近平同志为核心的党中央团结带领全党全国各族人民向绝对贫困发起最后的总攻，举国合力、上下同心，形成了脱贫攻坚的共同意志、共同行动。在脱贫攻坚战中，正是践行为中国人民谋幸福、为中华民族谋复兴的初心使命，攻坚克难，兑现了让现行标准下农村贫困人口全部脱贫的庄严承诺。脱贫攻坚是一场硬仗，党团结带领全国各族人民迎难而上，啃下了深度贫困等一块块硬骨头。我们要大力弘扬脱贫攻坚精神，团结一心，英勇奋斗，我们必将战胜前进道路上的一切困难和风险，不断夺取坚持和发展中国特色社会主义新的更大的胜利！<br>科技事业在党和人民事业中始终具有十分重要的战略地位、发挥了十分重要的战略作用。在中国共产党的坚强领导下，我国科技事业从一穷二白处起步、在砥砺奋进中开拓，实现了历史性跨越，取得了历史性成就。在神州大地奔腾涌动的创新热潮，汇聚成澎湃强劲的“第一动力”，推动着高质量发展。中国共产党自成立之初就深刻地意识到了科技的重要性，从革命时期高度重视知识分子工作，到新中国成立后吹响“向科学进军”的号角，到改革开放提出“科学技术是第一生产力”的论断，从进入新世纪深入实施知识创新工程、科教兴国战略、人才强国战略，不断完善国家创新体系、建设创新型国家，到党的十八大后提出创新是第一动力、全面实施创新驱动发展战略、建设世界科技强国，科技事业在党和人民事业中始终具有十分重要的战略地位、发挥了十分重要的战略作用。中国共产党针对我国科技事业面临的突出问题和挑战，坚持把科技创新摆在国家发展全局的核心位置，全面谋划科技创新工作。在党中央坚强领导下，在全国科技界和社会各界共同努力下，我国科技实力正在从量的积累迈向质的飞跃、从点的突破迈向系统能力提升，科技创新取得新的历史性成就。党的十九届五中全会提出了坚持创新在我国现代化建设全局中的核心地位，把科技自立自强作为国家发展的战略支撑。党的十八大以来，我国基础研究经费稳步增长，基础研究领域取得一系列重大突破，科技创新取得一系列重要进展。“嫦娥五号”实现地外天体采样返回，“天问一号”开启火星探测，“慧眼号”直接测量到迄今宇宙最强磁场，“中国天眼”首次发现毫秒脉冲星；在量子信息、铁基超导、干细胞、脑科学等前沿方向上，一批重大原创成果相继问世，显著提升了我国在全球科研舞台的地位。从北斗三号全球卫星导航系统开通，C919大飞机准备运营，最大直径盾构机顺利始发，到建成5G基站占全球70%以上，新能源汽车产销量连续6年蝉联世界第一，自主三代核电“华龙一号”首堆并网成功，近年来，我国着力加强关键技术攻关，在深海、深空、深地、深蓝等战略高技术领域积极抢占科技制高点，5G、高铁、三代核电、新能源汽车等高端产业不断取得新突破。新发明、新技术、新产品、新产业、新模式，正加快形成高质量发展新引擎，推动产业向中高端迈进。抗击新冠肺炎疫情，我国科技界迎难而上、集智攻关，发挥了重要作用。近年来，人工智能、远程会议、在线课堂、线上医疗等新技术新业态蓬勃发展，成为衣食住行的“新标配”。层出不穷的民生科技成果，让人们切身体验着“科技让生活更美好”的幸福感。经过多年努力，我国科技整体水平大幅提升，我们完全有基础、有底气、有信心、有能力抓住新一轮科技革命和产业变革的机遇，乘势而上，大展宏图。展望未来，科技部党组书记、部长王志刚表示“：我们要坚决落实习近平总书记关于科技创新的重要指示精神，肩负起时代赋予的重任，坚持‘四个面向’，立足自主创新，把握大势、抢占先机，直面问题、迎难而上，为加快建设科技强国，实现高水平科技自立自强作出更大贡献！”坚持面向世界科技前沿、面向经济主战场、面向国家重大需求、面向人民生命健康，坚持创新在我国现代化建设全局中的核心地位，把科技自立自强作为国家发展的战略支撑，大力弘扬科学家精神，我们一定能够在加快建设科技强国、实现高水平科技自立自强进程中，不断书写新的篇章。<br>回顾中国共产党的百年光辉历程，一幅幅历史画卷让人们心潮澎湃，一个个动人故事让人们荡气回肠。当前，我们党正团结带领全国各族人民在全面建设社会主义现代化国家的新征程上接续奋斗。在前进的道路上，我们党必将创造新的辉煌历史，为人们留下新的动人故事。我们要传颂好伟大历史、继续讲好党的故事，让红色基因代代相传，让红色江山千秋永固。            </p>
<p>通过学习青年大学习、庆祝中国共产党成立一百周年大会、党史答题活动等一些有关党的活动，应当深刻认识到时代所带给我们的机遇，无论我们个人的力量有多么微小，都可以担当起责任。也许我们来自不同行业，也许我们怀有各自的迷茫，我们责任的来源和组成也各不相同，青年时期要立志高远，不但要立足岗位、学精业务，更要时刻胸怀祖国，去思考自己可以为国家、甚至为人类社会做出点什么，改变点什么。无须过多关注结果，过分怀疑个人的微小力量能否有所成就，只是大胆放手去创造，朝着这个方向努力便可以。一百年来，中国共产党紧紧依靠人民，创造了人类发展惊天动地的奇迹。此刻，我们的国家正在进行实现中华民族伟大复兴的新长征，我们作为未来共产主义事业的接力者，应当时刻学习和继承建党时中国共产党人的奋斗精神，永远怀揣对人民的赤子之心。</p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>百年党史</tag>
      </tags>
  </entry>
  <entry>
    <title>贪吃蛇街机小游戏开题报告</title>
    <url>/2021/07/07/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%B1%87%E7%BC%96%E6%8E%A5%E5%8F%A3%E5%AE%9E%E9%AA%8C%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="开题报告"><a href="#开题报告" class="headerlink" title="开题报告"></a>开题报告</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>贪吃蛇街机小游戏是一款在8*8的LED显示灯上运行的贪吃蛇小游戏，通过红外线遥控器输入设备进行游戏控制，在LED显示灯上显示游戏画面，使用数码管显示当前得分，使用灯光和蜂鸣器营造游戏氛围。</p>
<h2 id="功能模块划分"><a href="#功能模块划分" class="headerlink" title="功能模块划分"></a>功能模块划分</h2><ul>
<li>游戏整体逻辑控制模块</li>
</ul>
<p>整个项目的入口，控制其他各个模块的调度。</p>
<ul>
<li>贪吃蛇逻辑控制模块</li>
</ul>
<p>贪吃蛇运行逻辑的控制，负责计算出下一秒贪吃蛇的状态（移动、增长、死亡）、食物位置的刷新、当前得分的计算等。</p>
<ul>
<li>LED显示控制模块</li>
</ul>
<p>将内容（游戏菜单、当前画面、）显示到8*8的LED灯上。</p>
<ul>
<li>全局时钟控制模块</li>
</ul>
<p>通过8253每10ms产生一个中断，用于控制游戏进程的同步。</p>
<ul>
<li>声音控制模块</li>
</ul>
<p>使用蜂鸣器产生游戏音效与背景音乐。</p>
<ul>
<li>灯光控制模块</li>
</ul>
<p>使用LED灯产生一些光效。</p>
<ul>
<li>数码管显示模块</li>
</ul>
<p>使用数码管显示出当前游戏的得分。</p>
<ul>
<li>红外线输入模块</li>
</ul>
<p>使用红外线输入，产生中断，控制贪吃蛇的运动。</p>
<h2 id="核心功能代码测试"><a href="#核心功能代码测试" class="headerlink" title="核心功能代码测试"></a>核心功能代码测试</h2><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; LED显示</span></span><br><span class="line">show_led proc</span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">;写入方式控制字</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span> , <span class="number">283h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span> , <span class="number">80h</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span> , <span class="built_in">al</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">;逐列刷新 红  si控制红行 di控制绿行</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">si</span>,offset red_buffer <span class="comment">;控制每一列的红8行</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">di</span>,offset green_buffer <span class="comment">;控制每一列的绿8行</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">10000000b</span> <span class="comment">;第一列 颜色通过列线进行输出，281h输出则为第零列为红，282h输出则为第零列为绿 </span></span><br><span class="line"><span class="symbol">again_show_led_col:</span></span><br><span class="line">    <span class="comment">;红列  是控制哪一列是什么颜色的 红:281h 绿：282h 第0列为红色 </span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">281h</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">    <span class="comment">;每一列控制哪一行的红灯亮    这里有问题 对于控制行线来讲，若要红灯亮绿灯不亮则都不会亮（但是由于时间间隔很短，所以我在实验室的效果就是看起来不太亮）</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]                 <span class="comment">;所以这里必须解决红绿灯互相影响的问题</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">1</span>                    <span class="comment">;因为时按列亮灯，共用列，所以不可能在一列中同时显示红灯和绿灯。</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">280h</span>                 <span class="comment">;要不试试逐个点亮  </span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>                   <span class="comment">;我觉得实验室器材不太好，必不能支持如此高频率的数据传送</span></span><br><span class="line">                                <span class="comment">;所以贪吃蛇只能做到食物和蛇一个颜色，让食物闪烁吧。</span></span><br><span class="line">    <span class="comment">;mov bx ,10000</span></span><br><span class="line">    <span class="comment">;call delay</span></span><br><span class="line">    <span class="comment">;绿列  </span></span><br><span class="line">    <span class="comment">;mov al,cl</span></span><br><span class="line">    <span class="comment">;mov dx,282h</span></span><br><span class="line">    <span class="comment">;out dx,al</span></span><br><span class="line">    <span class="comment">;每一列控制哪一行的绿灯亮</span></span><br><span class="line">    <span class="comment">;mov al,[di]</span></span><br><span class="line">    <span class="comment">;add di,1</span></span><br><span class="line">    <span class="comment">;mov dx,280h    </span></span><br><span class="line">    <span class="comment">;out dx,al</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">;显示完每一列进行delay 以bx为参数</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">10</span></span><br><span class="line">    <span class="keyword">call</span> delay</span><br><span class="line"></span><br><span class="line">    <span class="comment">;关闭所有的列显示</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">281h</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>   </span><br><span class="line">    <span class="comment">;mov dx,282h</span></span><br><span class="line">    <span class="comment">;out dx,al</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">shr</span> <span class="built_in">cl</span>,<span class="number">1</span>    <span class="comment">;下一列</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">cl</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">jnz</span> again_show_led_col</span><br><span class="line"></span><br><span class="line"><span class="symbol">show_led_end:</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">show_led endp</span><br></pre></td></tr></table></figure>

<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;运行贪吃蛇的程序   所有按键信息由中断进行扫描，程序只管从缓冲区中读取即可</span></span><br><span class="line">snake_gluttony proc</span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line"><span class="comment">;蛇的时间量，每经过100个全局时间量 加一，即蛇每1s移动一次 </span></span><br><span class="line">snake_time <span class="built_in">word</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">snake_gluttony_begin:</span></span><br><span class="line"><span class="symbol">snake_count_time:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,sync_time_buffer</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">100</span></span><br><span class="line">    <span class="keyword">div</span> <span class="built_in">bl</span>      <span class="comment">;得到余数在ah中 商在al</span></span><br><span class="line">    <span class="keyword">xor</span> <span class="number">ah</span>,<span class="number">ah</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">ax</span>,[snake_time]     <span class="comment">;当前时间比之前的时间高</span></span><br><span class="line">    <span class="keyword">ja</span> snake_flush</span><br><span class="line">    <span class="comment">;为防止因为溢出而造成的错误判断</span></span><br><span class="line">    <span class="keyword">mov</span> [snake_time],<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">jmp</span> snake_count_time</span><br><span class="line"><span class="comment">;snake的时间到了，可以刷新</span></span><br><span class="line"><span class="symbol">snake_flush:</span></span><br><span class="line">    <span class="comment">;ax中存放当前贪吃蛇时间，放入snake_time</span></span><br><span class="line">    <span class="keyword">mov</span> [snake_time],<span class="built_in">ax</span></span><br><span class="line">    <span class="comment">;判断按键，进行贪吃蛇的逻辑操作  ;蛇的前近方向 3:上  0:下  2:左   1:右</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,keyboard_input_buffer</span><br><span class="line">    <span class="comment">;处理键盘的W A S D  10-13位存放</span></span><br><span class="line">    <span class="keyword">shr</span> <span class="built_in">ax</span>,<span class="number">10</span></span><br><span class="line">    <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00001111B</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">00001000B</span></span><br><span class="line">    <span class="keyword">jz</span> snake_fulsh_process_key_w</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">00000100B</span></span><br><span class="line">    <span class="keyword">jz</span> snake_fulsh_process_key_s</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">00000010B</span></span><br><span class="line">    <span class="keyword">jz</span> snake_fulsh_process_key_a</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">00000001B</span></span><br><span class="line">    <span class="keyword">jz</span> snake_fulsh_process_key_d</span><br><span class="line"></span><br><span class="line">    <span class="comment">;没有任何按键按下则直接进行处理</span></span><br><span class="line">    <span class="keyword">jmp</span> snake_flush_process</span><br><span class="line"></span><br><span class="line"><span class="comment">;处理按键w</span></span><br><span class="line"><span class="symbol">snake_fulsh_process_key_w:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,snake_direction</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span>    <span class="comment">;当前方向不为下时改变方向为上</span></span><br><span class="line">    <span class="keyword">jz</span> snake_flush_process</span><br><span class="line">    <span class="keyword">mov</span> snake_direction,<span class="number">3</span></span><br><span class="line">    <span class="keyword">jmp</span> snake_flush_process</span><br><span class="line"><span class="comment">;处理按键s</span></span><br><span class="line"><span class="symbol">snake_fulsh_process_key_s:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,snake_direction</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">3</span>    <span class="comment">;当前方向不为上时改变方向为下</span></span><br><span class="line">    <span class="keyword">jz</span> snake_flush_process</span><br><span class="line">    <span class="keyword">mov</span> snake_direction,<span class="number">0</span></span><br><span class="line">    <span class="keyword">jmp</span> snake_flush_process</span><br><span class="line"><span class="comment">;处理按键a</span></span><br><span class="line"><span class="symbol">snake_fulsh_process_key_a:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,snake_direction</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">1</span>    <span class="comment">;当前方向不为右时改变方向为左</span></span><br><span class="line">    <span class="keyword">jz</span> snake_flush_process</span><br><span class="line">    <span class="keyword">mov</span> snake_direction,<span class="number">2</span></span><br><span class="line">    <span class="keyword">jmp</span> snake_flush_process</span><br><span class="line"><span class="comment">;处理按键d</span></span><br><span class="line"><span class="symbol">snake_fulsh_process_key_d:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,snake_direction</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">2</span>    <span class="comment">;当前方向不为左时改变方向为右</span></span><br><span class="line">    <span class="keyword">jz</span> snake_flush_process</span><br><span class="line">    <span class="keyword">mov</span> snake_direction,<span class="number">1</span></span><br><span class="line">    <span class="keyword">jmp</span> snake_flush_process</span><br><span class="line"></span><br><span class="line"><span class="comment">;按键处理完了，处理贪吃蛇的位置</span></span><br><span class="line"><span class="symbol">snake_flush_process:</span></span><br><span class="line">    <span class="comment">;将按键信息清零</span></span><br><span class="line"><span class="symbol">snake_flush_process_clear_key:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,keyboard_input_buffer</span><br><span class="line">    <span class="comment">;处理键盘的W A S D 都置为零</span></span><br><span class="line">    <span class="keyword">and</span> <span class="built_in">ax</span>,<span class="number">1100001111111111B</span></span><br><span class="line">    <span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;位置刷新，根据上一次是否吃了食物决定身体更新策略</span></span><br><span class="line"><span class="comment">;若上一次刷新吃到了食物，则这一次蛇头变为蛇尾的一部分，然后蛇头向前走一步，若没有吃到，则从最后一节开始，每一节的位置时前一个的位置，第一个位置更新为蛇头的位置。</span></span><br><span class="line"><span class="symbol">move_snake_body:</span></span><br><span class="line">    <span class="comment">;每个位置需要两个字节</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">si</span>,offset snake_body_buffer </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">di</span>,snake_body_length        <span class="comment">;其实有没有吃都从最后一节向前更新即可，无非是length的不同</span></span><br><span class="line">    <span class="keyword">dec</span> <span class="built_in">di</span>          <span class="comment">;减一 方便指向每一节</span></span><br><span class="line">    <span class="keyword">shl</span> <span class="built_in">di</span>,<span class="number">1</span>    </span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">di</span>,<span class="built_in">si</span>   <span class="comment">;指向最后一节 目标地址</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="built_in">di</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">si</span>,<span class="number">2</span>    <span class="comment">;源地址</span></span><br><span class="line"><span class="comment">;更新蛇的身体的每一节，第一节不更新</span></span><br><span class="line"><span class="symbol">move_snake_body_every_section:</span></span><br><span class="line">    <span class="comment">;跟新蛇的尾巴信息 si所指向的</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">    <span class="keyword">mov</span> snake_tail_position_x,<span class="built_in">al</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">mov</span> snake_tail_position_y,<span class="built_in">al</span></span><br><span class="line">    <span class="comment">;串传送的个数 （word）第一节不传送</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,snake_body_length</span><br><span class="line">    <span class="keyword">dec</span> <span class="built_in">cx</span>              </span><br><span class="line">    <span class="keyword">std</span>         <span class="comment">;反向传送       </span></span><br><span class="line">    <span class="keyword">rep</span> <span class="keyword">movsw</span>       </span><br><span class="line"></span><br><span class="line"><span class="comment">;更新第一节，将头的位置赋予即可</span></span><br><span class="line"><span class="symbol">move_snake_body_first_section:</span></span><br><span class="line">    <span class="comment">;高位存放纵坐标</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">si</span>,offset snake_body_buffer</span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,snake_head_position_y</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_x</span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">;位置刷新，将贪吃蛇头朝对应方向移动一格</span></span><br><span class="line"><span class="symbol">move_snake_head:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,snake_direction</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">3</span>    <span class="comment">;上</span></span><br><span class="line">    <span class="keyword">jz</span> move_snake_head_up</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span>    <span class="comment">;下</span></span><br><span class="line">    <span class="keyword">jz</span> move_snake_head_down</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">2</span>    <span class="comment">;左</span></span><br><span class="line">    <span class="keyword">jz</span> move_snake_head_left</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">1</span>    <span class="comment">;右</span></span><br><span class="line">    <span class="keyword">jz</span> move_snake_head_right</span><br><span class="line">    <span class="comment">;不可能哪个方向都不对</span></span><br><span class="line">    <span class="comment">;jmp move_snake_head_direction_error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;上</span></span><br><span class="line"><span class="symbol">move_snake_head_up:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_y</span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="number">1</span>    </span><br><span class="line">    <span class="keyword">jnc</span> snake_judge_conflict</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">7</span>    <span class="comment">;小于0，则从下面钻出来</span></span><br><span class="line">    <span class="keyword">jmp</span> snake_judge_conflict</span><br><span class="line"><span class="comment">;下</span></span><br><span class="line"><span class="symbol">move_snake_head_down:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_y</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">ax</span>,<span class="number">8</span>    </span><br><span class="line">    <span class="keyword">jnz</span> snake_judge_conflict</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>    <span class="comment">;等于8，超界，则从上面钻出来</span></span><br><span class="line">    <span class="keyword">jmp</span> snake_judge_conflict</span><br><span class="line"><span class="comment">;左</span></span><br><span class="line"><span class="symbol">move_snake_head_left:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_x</span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="number">1</span>    </span><br><span class="line">    <span class="keyword">jnc</span> snake_judge_conflict</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">7</span>    <span class="comment">;小于0，则从下右面钻出来</span></span><br><span class="line">    <span class="keyword">jmp</span> snake_judge_conflict</span><br><span class="line"><span class="comment">;右</span></span><br><span class="line"><span class="symbol">move_snake_head_right:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_x</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">ax</span>,<span class="number">8</span>    </span><br><span class="line">    <span class="keyword">jnz</span> snake_judge_conflict</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>    <span class="comment">;等于8 ，则从左面钻出来</span></span><br><span class="line">    <span class="keyword">jmp</span> snake_judge_conflict</span><br><span class="line"></span><br><span class="line"><span class="comment">;判断是否冲突</span></span><br><span class="line"><span class="symbol">snake_judge_conflict:</span></span><br><span class="line">    <span class="comment">;首先判断是否蛇头和食物重合，若没有重合则蛇尾向前一步走，若重合则蛇尾不动，将蛇的身体信息全部向后移动一位</span></span><br><span class="line">    <span class="comment">;清空上一次吃到食物的信息</span></span><br><span class="line">    <span class="keyword">mov</span> food_eaten,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,snake_head_position_x</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,food_x</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">    <span class="keyword">jnz</span> snake_judge_conflict_not_eat</span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,snake_head_position_y</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,food_y</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">    <span class="keyword">jnz</span> snake_judge_conflict_not_eat</span><br><span class="line">    <span class="comment">;下面时蛇吃了食物 </span></span><br><span class="line">    <span class="keyword">mov</span> food_eaten,<span class="number">1</span></span><br><span class="line">    <span class="keyword">add</span> snake_body_length,<span class="number">1</span></span><br><span class="line"><span class="comment">;生成新的食物 位置为（7-当前蛇头x,7-当前蛇尾y)</span></span><br><span class="line"><span class="symbol">snake_create_new_food:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">7</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>,snake_head_position_x</span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mov</span> food_x,<span class="built_in">al</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">7</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span> snake_tail_position_y</span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mov</span> food_y,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">;蛇这一步没有吃到食物</span></span><br><span class="line"><span class="symbol">snake_judge_conflict_not_eat:</span></span><br><span class="line">    <span class="keyword">mov</span> food_eaten,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;在led点阵中点亮蛇阵 使用红色</span></span><br><span class="line">snake_lighten_led_red：</span><br><span class="line">    <span class="comment">;首先点亮食物</span></span><br><span class="line">    <span class="comment">;写入红色灯亮，ah为行号，al为列号 注意这里 （0，0）在左下角    即ah为y al为x</span></span><br><span class="line">    <span class="comment">;make_it_red proc</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,food_y</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,food_x</span><br><span class="line">    <span class="keyword">call</span> make_it_red</span><br><span class="line">    <span class="comment">;点亮头</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,snake_head_position_y</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_x</span><br><span class="line">    <span class="keyword">call</span> make_it_red</span><br><span class="line">    <span class="comment">;点亮身体</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">si</span>,offset snake_body_buffer</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,snake_body_length</span><br><span class="line">snake_lighten_led_red_body：</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,[<span class="built_in">si</span>+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">loop</span> snake_lighten_led_red_body</span><br><span class="line"></span><br><span class="line">    <span class="keyword">jmp</span> snake_gluttony_begin</span><br><span class="line"></span><br><span class="line"><span class="symbol">snake_gluttony_end:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">snake_gluttony endp</span><br></pre></td></tr></table></figure>



<h2 id="任务分工"><a href="#任务分工" class="headerlink" title="任务分工"></a>任务分工</h2><p>岳希航：贪吃蛇逻辑控制模块、LED显示模块、声音控制模块、数码管显示模块</p>
<p>崔文耀：游戏整体逻辑控制模块、全局时钟控制模块、灯光控制模块、红外线输入模块</p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>nonetag</tag>
      </tags>
  </entry>
  <entry>
    <title>贪吃蛇结题报告</title>
    <url>/2021/07/17/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%B1%87%E7%BC%96%E6%8E%A5%E5%8F%A3%E5%AE%9E%E9%AA%8C%E7%BB%93%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="贪吃蛇结题报告"><a href="#贪吃蛇结题报告" class="headerlink" title="贪吃蛇结题报告"></a>贪吃蛇结题报告</h1><p><a href="/file/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%B1%87%E7%BC%96%E6%8E%A5%E5%8F%A3%E5%AE%9E%E9%AA%8C/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%B1%87%E7%BC%96%E6%8E%A5%E5%8F%A3%E5%AE%9E%E9%AA%8C.zip">代码</a></p>
<h2 id="题目意义"><a href="#题目意义" class="headerlink" title="题目意义"></a>题目意义</h2><p>这次微机实验，我们选择的题目是贪吃蛇街机小游戏。简单来讲就是使用微机试验台上的led点阵作为显示屏，配合计数操作显示得分情况，利用键盘进行IO操作的贪吃蛇小游戏。之所以选择这个题目是因为我想在有限的实验条件上极可能的做出一个比较有趣的项目。由此可见，此题目的意义就是探求自己在简陋的实验环境中做出复杂工程的能力，同时也是在检验自己在微机课程中所学到的知识是否扎实。</p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ol>
<li>图像显示<br> 使用led点阵将贪吃蛇的位置和食物的位置显示出来，首先我们必须提供一个底层的方法来方便地将led灯进行点亮，这就促使我们引入了缓存地概念（下面再说）和一个读取缓存地内容进行点亮灯的方法。</li>
<li>图像显示的缓存<br> 为了方便的进行led的显示，我门引入了缓存的概念，即将要显示的led点阵的信息以比特的形式存储在内存中，命名为red_buffer和green_buffer</li>
<li>图像操控<br> 为了方便的修改缓存中的信息，我们实现了一个函数将特定位置的额灯的颜色置红，值绿或者置暗。</li>
<li>中断<br> 使用8253产生定时中断为系统提供时间基准。</li>
<li>IO输入<br> 由中断驱动进行IO操作，将键盘等的输入存入内存。</li>
<li>时分复用<br> 由于试验台上的输出端口不够用了，所以为了添加数码管功能，我们引入了时分复用的概念，即利用led点阵灭的那一瞬间将数码管点亮，这样既不会影响led点阵也可以实现点亮数码管。</li>
</ol>
<h2 id="采用的主要技术，遇到的难点和解决方法"><a href="#采用的主要技术，遇到的难点和解决方法" class="headerlink" title="采用的主要技术，遇到的难点和解决方法"></a>采用的主要技术，遇到的难点和解决方法</h2><ol>
<li><p>led点阵驱动<br> led点阵驱动提供了make_it_red、make_it_green、make_it_dark等底层方法来供上层控制led点阵的缓冲区内容，而led点阵驱动的硬件交互部分又通过读取缓冲区的内容来按照用户设想的方式亮灯。</p>
<ol>
<li>难点<br> 操作内存与硬件底层相衔接的问题。即如何方便的在软件层面上控制底层led亮。</li>
<li>解决方法<br> 引入了缓冲区的概念，系统存在两个led点阵的缓冲区，分别为ren_buffer和green_buffer，分别用来存储led点阵上灯亮的信息，这两个缓冲区都为8字节的数据，其中每一个比特控制每一个灯的亮的情况，利用这两个缓冲区就可以将led灯亮的信息存储在内存中，led底层控制模块只需要读取这两个内存区就可以将led点阵按预设的点亮了。</li>
<li>难点<br> 没有足够的端口点亮数码管</li>
<li>解决方法<br> 引用了时分复用的概念，将led点阵和数码管点亮的过程时分复用，解决了输出端口不够的问题。由于每一次led点阵点亮过后，存在一段时间led点阵的所有列信息为零，所以此时复用使用的8255PA连接数码管的段码显示，就可以利用有限的端口点亮数码管了。</li>
</ol>
</li>
<li><p>IO输入控制<br> IO输入控制负责定时的读取外设的输入信息，并且将其信息存储到内存中的缓冲区。</p>
<ol>
<li>难点<br> 如何定时的获取输入内容</li>
<li>解决方法<br> 使用8253设置定时中断连接在IRQ10上，由此可以实现定时的扫描键盘等外设的输入，键盘输入程序中使用BIOS提供的16号中断获取键盘输入数据。</li>
<li>难点<br> 如何在将外设的输入存储到内存中。</li>
<li>解决方法<br> 以键盘为例，在内存中开辟一个键盘输入的缓冲区，keyboard_input，其为16位的字，低1位到第9位存储了1-9按键是否被按下的信息。10-13存储WASD按键的信息。</li>
</ol>
</li>
<li><p>时间同步<br> 程序需要一个全局的同步时间量来控制每一个模块进行同步操作。</p>
<ol>
<li>难点<br> 如何获取当前时间呢。</li>
<li>解决方法<br> 在上文提到的额中断程序中加上时间量处理，即每一次中断将全局的时间同步量加一。</li>
</ol>
</li>
<li><p>状态机<br> 整个程序就是一个巨大的状态机。</p>
<ol>
<li>难点<br> 控制每一个状态的转换</li>
<li>解决方法<br> 使用一个缓冲区status来存储当前状态信息，程序利用该内存数据进行状态的转移。</li>
</ol>
</li>
</ol>
<h2 id="实现的主要功能和系统结构"><a href="#实现的主要功能和系统结构" class="headerlink" title="实现的主要功能和系统结构"></a>实现的主要功能和系统结构</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li><p>状态机。<br> 整个程序就是一个巨大的状态机。使用一个缓冲区status来存储当前状态信息，程序利用该内存数据进行状态的转移。</p>
</li>
<li><p>键盘输入。<br> 读取键盘输入并存储</p>
</li>
<li><p>点亮数码管。<br> 将游戏的得分信息在使用数码管进行显示。</p>
</li>
<li><p>控制led点阵任一灯的亮暗。</p>
</li>
<li><p>控制led点阵按预定信息亮。</p>
</li>
<li><p>贪吃蛇主体程序</p>
</li>
<li><p>输入信息处理程序</p>
</li>
<li><p>时间同步程序</p>
</li>
</ol>
<h3 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h3><p>时间同步程序为所有的程序提供一个时间的基本量，中断程序为负责定时读取输入和更新时间同步量，向上提供输入和同步，状态处理模块负责读取输入信息和状态信息进行状态的控制操作。在进入贪吃蛇主体程序之后，程序通过读取外设的输入信息控制贪吃蛇的移动，并通过贪吃蛇的逻辑控制来控制贪吃蛇的状态信息，并且实时的调用led点阵来动态显示贪吃蛇的位置以及使用数码管动态显示贪吃蛇得分信息。</p>
<h2 id="相关技术说明"><a href="#相关技术说明" class="headerlink" title="相关技术说明"></a>相关技术说明</h2><ol>
<li><p>缓冲区<br> 程序的所有所欲信息和状态都存储在缓冲区中，功能之间上下游分别负责存入和读取改变缓冲区，由此来驱动程序的运行。</p>
 <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;红色   颜色是通过列线进行输出的</span></span><br><span class="line">red_buffer   <span class="keyword">byte </span><span class="number">8</span> dup(<span class="number">0</span>)</span><br><span class="line"><span class="comment">;绿色</span></span><br><span class="line">green_buffer <span class="keyword">byte </span><span class="number">8</span> dup(<span class="number">0</span>)</span><br><span class="line"><span class="comment">;infrared_input_buffer  存储红外线输入的缓冲区  每一个bit可以自由定义其含义</span></span><br><span class="line">infrared_input_buffer word <span class="number">0</span></span><br><span class="line"><span class="comment">;keyboard_input_buffer 存储键盘输入的缓冲区  每一个bit可以自由定义其含义</span></span><br><span class="line">keyboard_input_buffer word <span class="number">0</span></span><br><span class="line"><span class="comment">;Status buffer 状态缓冲区，用来存放程序运行的各种状态</span></span><br><span class="line">status_buffer word <span class="number">0</span></span><br><span class="line"><span class="comment">;时间缓冲区，负责提供同步信息 由中断程序每隔10ms加一</span></span><br><span class="line"><span class="keyword">sync_time_buffer </span>word <span class="number">0</span></span><br><span class="line"><span class="comment">;蛇身位置 不包含蛇头 蛇的每一个位置需要两个字节，8*8*2=128B</span></span><br><span class="line">snake_body_buffer <span class="keyword">byte </span><span class="number">128</span> dup(<span class="number">0</span>)</span><br><span class="line"><span class="comment">;蛇身的长度，不包括蛇头，也是当前的分数</span></span><br><span class="line">snake_body_length word <span class="number">0</span></span><br><span class="line"><span class="comment">;蛇头位置</span></span><br><span class="line">snake_head_position_x <span class="keyword">byte </span><span class="number">0</span></span><br><span class="line">snake_head_position_y <span class="keyword">byte </span><span class="number">0</span></span><br><span class="line"><span class="comment">;蛇尾位置</span></span><br><span class="line">snake_tail_position_x <span class="keyword">byte </span><span class="number">0</span></span><br><span class="line">snake_tail_position_y <span class="keyword">byte </span><span class="number">0</span></span><br><span class="line"><span class="comment">;食物位置</span></span><br><span class="line">food_x <span class="keyword">byte </span><span class="number">0</span></span><br><span class="line">food_y <span class="keyword">byte </span><span class="number">0</span></span><br><span class="line"><span class="comment">;是否吃了食物 0:没有 1:吃了</span></span><br><span class="line">food_eaten <span class="keyword">byte </span><span class="number">0</span></span><br><span class="line"><span class="comment">;碰撞与否</span></span><br><span class="line">collision <span class="keyword">byte </span><span class="number">0</span></span><br><span class="line"><span class="comment">;蛇的前近方向 2:上 0：下 2;左 1：右</span></span><br><span class="line">snake_direction <span class="keyword">byte </span><span class="number">0</span></span><br><span class="line"><span class="comment">;保存原中断程序入口</span></span><br><span class="line">int_<span class="symbol">0b</span>_seg word <span class="number">0</span></span><br><span class="line">int_<span class="symbol">0b</span>_off word <span class="number">0</span></span><br><span class="line"><span class="comment">;蛇的时间量，每经过100个全局时间量 加一，即蛇每1s移动一次 </span></span><br><span class="line">snake_time word <span class="number">0</span></span><br><span class="line"><span class="comment">;数码管</span></span><br><span class="line">ledtb <span class="keyword">byte </span><span class="number">3</span>fh,<span class="number">06</span>h,<span class="number">5</span>bh,<span class="number">4</span>fh,<span class="number">66</span>h,<span class="number">6</span>dh,<span class="number">7</span>dh,<span class="number">07</span>h,<span class="number">7</span>fh,<span class="number">6</span>fh</span><br><span class="line"><span class="comment">;得分（当前长度减去初始长度）存储  分别存储四个数码管的数字</span></span><br><span class="line">lednum <span class="keyword">byte </span><span class="number">4</span> dup(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>状态机。<br> 整个程序就是一个巨大的状态机。使用一个缓冲区status来存储当前状态信息，程序利用该内存数据进行状态的转移。</p>
</li>
<li><p>IO输入控制<br> IO输入控制负责定时的读取外设的输入信息，并且将其信息存储到内存中的缓冲区。<br> 使用8253设置定时中断连接在IRQ10上，由此可以实现定时的扫描键盘等外设的输入，键盘输入程序中使用BIOS提供的16号中断获取键盘输入数据。在内存中开辟一个键盘输入的缓冲区，keyboard_input，其为16位的字，低1位到第9位存储了1-9按键是否被按下的信息。10-13存储WASD按键的信息。</p>
</li>
<li><p>led点阵驱动<br> led点阵驱动提供了make_it_red、make_it_green、make_it_dark等底层方法来供上层控制led点阵的缓冲区内容，而led点阵驱动的硬件交互部分又通过读取缓冲区的内容来按照用户设想的方式亮灯。系统存在两个led点阵的缓冲区，分别为ren_buffer和green_buffer，分别用来存储led点阵上灯亮的信息，这两个缓冲区都为8字节的数据，其中每一个比特控制每一个灯的亮的情况，利用这两个缓冲区就可以将led灯亮的信息存储在内存中，led底层控制模块只需要读取这两个内存区就可以将led点阵按预设的点亮了。将led点阵和数码管点亮的过程时分复用，解决了输出端口不够的问题。由于每一次led点阵点亮过后，存在一段时间led点阵的所有列信息为零，所以此时复用使用的8255PA连接数码管的段码显示，就可以利用有限的端口点亮数码管了。</p>
</li>
</ol>
<h2 id="总结和体会"><a href="#总结和体会" class="headerlink" title="总结和体会"></a>总结和体会</h2><p>计算机领域的知识都是相通的，之前在操作系统学到了复用的概念于是在本次实验中就利用复用解决了输出端口不够的问题。还有缓冲区的概念和封装的和概念。程序将分散的功能封装为一个一个小模块，使得程序的调用更加方便了。缓冲区为个模块提供信息交互的通道。</p>
<p>计算机知识博大精深，要好好学习。不要沉迷于上层技术，其实底层原理是更加令人着迷的，只要学好了计算机的底层原理，使用计算机底层原理的方式进行思考问题往往会获得意想不到的结果。</p>
]]></content>
      <categories>
        <category>微机</category>
      </categories>
      <tags>
        <tag>微机</tag>
      </tags>
  </entry>
  <entry>
    <title>微机期末复习之实验源代码</title>
    <url>/2021/06/26/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E5%AE%9E%E9%AA%8C%E6%BA%90%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="微机期末复习之实验源代码"><a href="#微机期末复习之实验源代码" class="headerlink" title="微机期末复习之实验源代码"></a>微机期末复习之实验源代码</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">.model</span> small</span><br><span class="line"><span class="meta">.stack</span></span><br><span class="line"><span class="meta">.data</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0d000h</span><span class="comment">;段地址</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">6000h</span><span class="comment">;偏移地址</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">5fh</span><span class="comment">;字符个数</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">20h</span><span class="comment">;ASCII开始字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;写入ASCII表</span></span><br><span class="line"><span class="symbol">write:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">dx</span>,<span class="number">7fh</span></span><br><span class="line">	<span class="keyword">jnz</span> write</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">6000h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;读出ASCII表</span></span><br><span class="line"><span class="symbol">read:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">es</span>:[<span class="built_in">bx</span>]</span><br><span class="line">	<span class="keyword">call</span> dispc</span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">loop</span> read</span><br><span class="line">	</span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line">	end start</span><br></pre></td></tr></table></figure>

<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line">intmsg <span class="built_in">byte</span> <span class="string">&#x27;TPCA Interrupt No.3!&#x27;</span>,<span class="number">0dh</span>,<span class="number">0ah</span>,<span class="number">0</span></span><br><span class="line">counter <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">350Bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">cli</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">seg</span> new0Bh</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,offset new0Bh</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">250Bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">21h</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0f7h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> counter,<span class="number">0</span></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="symbol">start1:</span></span><br><span class="line">	<span class="keyword">cmp</span> counter,<span class="number">5</span></span><br><span class="line">	<span class="keyword">jb</span> start1</span><br><span class="line">	<span class="comment">;</span></span><br><span class="line">	<span class="keyword">cli</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">250Bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;中断服务程序</span></span><br><span class="line">new0Bh proc</span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">inc</span> counter</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset intmsg</span><br><span class="line">	<span class="keyword">call</span> dpstri</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">20h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">iret</span></span><br><span class="line">new0Bh endp</span><br><span class="line">dpstri proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line"><span class="symbol">dps1:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jz</span> dps2</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0eh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">jmp</span> dps1</span><br><span class="line"><span class="symbol">dps2:</span> <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">dpstri endp</span><br><span class="line">end start	</span><br></pre></td></tr></table></figure>

<h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> 	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line">intmsg <span class="built_in">byte</span> <span class="string">&#x27;TPCA Interrupt No.10!&#x27;</span>,<span class="number">0dh</span>,<span class="number">0ah</span>,<span class="number">0</span></span><br><span class="line">counter <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">3572h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">cli</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">seg</span> new72h</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,offset new72h</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2572h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0a1h</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0fbh</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">0a1h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> counter,<span class="number">0</span></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="symbol">start1:</span></span><br><span class="line">	<span class="keyword">cmp</span> counter,<span class="number">5</span></span><br><span class="line">	<span class="keyword">jb</span> start1</span><br><span class="line">	<span class="comment">;</span></span><br><span class="line">	<span class="keyword">cli</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2572h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"><span class="meta">.exit</span> <span class="number">0</span>	</span><br><span class="line"></span><br><span class="line"><span class="comment">;中断服务程序</span></span><br><span class="line">new72h proc</span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">inc</span> counter</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset intmsg</span><br><span class="line">	<span class="keyword">call</span> dpstri</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">0a0h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">20h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">iret</span></span><br><span class="line">new72h endp</span><br><span class="line">dpstri proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line"><span class="symbol">dps1:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jz</span> dps2</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0eh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">jmp</span> dps1</span><br><span class="line"><span class="symbol">dps2:</span> <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">dpstri endp</span><br><span class="line">end start	</span><br></pre></td></tr></table></figure>

<h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">  	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line">intmsg3 <span class="built_in">byte</span> <span class="string">&#x27;TPCA Interrupt No.3!&#x27;</span>,<span class="number">0dh</span>,<span class="number">0ah</span>,<span class="number">0</span></span><br><span class="line">intmsg10 <span class="built_in">byte</span> <span class="string">&#x27;TPCA Interrupt No.10!&#x27;</span>,<span class="number">0dh</span>,<span class="number">0ah</span>,<span class="number">0</span></span><br><span class="line">counter <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">350Bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">cli</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">seg</span> new0Bh</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,offset new0Bh</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">250Bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">21h</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0f7h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> counter,<span class="number">0</span></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">3572h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">cli</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">seg</span> new72h</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,offset new72h</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2572h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0a1h</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0fbh</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">0a1h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> counter,<span class="number">0</span></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"><span class="symbol">start1:</span></span><br><span class="line">	<span class="keyword">cmp</span> counter,<span class="number">5</span></span><br><span class="line">	<span class="keyword">jb</span> start1</span><br><span class="line">	<span class="comment">;</span></span><br><span class="line">	<span class="keyword">cli</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2572h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line">	<span class="keyword">cli</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">250Bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"><span class="meta">.exit</span> <span class="number">0</span>	</span><br><span class="line"></span><br><span class="line"><span class="comment">;中断服务程序</span></span><br><span class="line">new72h proc</span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">inc</span> counter</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset intmsg10</span><br><span class="line">	<span class="keyword">call</span> dpstri</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">86h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0ffh</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">8480h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">15h</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">0a0h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">20h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">iret</span></span><br><span class="line">new72h endp</span><br><span class="line"><span class="comment">;</span></span><br><span class="line">new0Bh proc</span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">inc</span> counter</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset intmsg3</span><br><span class="line">	<span class="keyword">call</span> dpstri</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">20h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">iret</span></span><br><span class="line">new0Bh endp</span><br><span class="line"><span class="comment">;</span></span><br><span class="line">dpstri proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line"><span class="symbol">dps1:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jz</span> dps2</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0eh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">jmp</span> dps1</span><br><span class="line"><span class="symbol">dps2:</span> </span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">86h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0ffh</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">8480h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">15h</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">dpstri endp</span><br><span class="line">end start	</span><br></pre></td></tr></table></figure>

<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>		</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">283h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>	</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">8</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">280h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">al</span></span><br><span class="line"><span class="symbol">again:</span></span><br><span class="line">       <span class="keyword">call</span> wait</span><br><span class="line">	 <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span>    </span><br><span class="line">	 <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">ah</span>	</span><br><span class="line">	 <span class="keyword">jz</span> again	    </span><br><span class="line">	 <span class="keyword">push</span> <span class="built_in">ax</span>	</span><br><span class="line">	<span class="keyword">call</span> dispuib</span><br><span class="line">      <span class="keyword">call</span> dispcrlf</span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">jnz</span> again	</span><br><span class="line"><span class="meta">      .exit</span> <span class="number">0</span> </span><br><span class="line">wait   proc </span><br><span class="line">       <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">1000</span>     </span><br><span class="line"><span class="symbol">wait1:</span></span><br><span class="line">        <span class="keyword">loop</span> wait1</span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">        <span class="keyword">ret</span> </span><br><span class="line">wait endp 	</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h3 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;设置计数器0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">283h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">36h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">280h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1000</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;设置计数器1</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">283h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">76h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1000</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">281h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line">	end start</span><br></pre></td></tr></table></figure>

<h3 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line">msg <span class="built_in">byte</span> <span class="string">&#x27;Interrupt 1s!&#x27;</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="number">0</span></span><br><span class="line">counter <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line"><span class="comment">;280计数器0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>	</span><br><span class="line">	<span class="comment">;设置计数器0	</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">36h</span>       </span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">283h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="comment">;设置计数初值</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">280h</span>	</span><br><span class="line">   	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1000</span></span><br><span class="line">   	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>	</span><br><span class="line">	<span class="comment">;设置计数器1</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">76h</span>      </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">283h</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">281h</span>		</span><br><span class="line">   	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1000</span>          </span><br><span class="line">   	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>	</span><br><span class="line">	<span class="comment">;获取并设置新的中断程序（0bh)</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">3508h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">cli</span> </span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span>	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">seg</span> new0bh</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,offset new0bh</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2508h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">21h</span> </span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span>	</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0f7h</span>	</span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span>	</span><br><span class="line">	<span class="keyword">mov</span> counter,<span class="number">0</span></span><br><span class="line">	<span class="keyword">sti</span> </span><br><span class="line"><span class="symbol">start1:</span></span><br><span class="line">	<span class="keyword">cmp</span> counter,<span class="number">5</span></span><br><span class="line">	<span class="keyword">jb</span> start1</span><br><span class="line">	<span class="keyword">cli</span>	</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span>	</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2508h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line">new0bh proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">inc</span> counter</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset msg</span><br><span class="line">	<span class="keyword">call</span> dpstri</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">20h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">iret</span></span><br><span class="line">new0bh endp</span><br><span class="line">dpstri proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line"><span class="symbol">dps1:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jz</span> dps2</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0eh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">jmp</span> dps1</span><br><span class="line"><span class="symbol">dps2:</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">dpstri endp	</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><h3 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">	 include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	 .model</span> small</span><br><span class="line"><span class="meta">	 .stack</span></span><br><span class="line"><span class="meta">	 .data</span></span><br><span class="line">msg  <span class="built_in">byte</span> <span class="string">&#x27;Please connext correctly!&#x27;</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="number">0</span></span><br><span class="line"><span class="meta">	 .code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	  <span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	  <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span> </span><br><span class="line">	  <span class="keyword">mov</span> <span class="built_in">ax</span>,offset msg</span><br><span class="line">	  <span class="keyword">call</span> dispmsg</span><br><span class="line"></span><br><span class="line"><span class="symbol">again:</span>  <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28Bh</span></span><br><span class="line">	  <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">89H</span></span><br><span class="line">	  <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">	  <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28Ah</span></span><br><span class="line">	  <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">	  <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">288h</span></span><br><span class="line">	  <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	  <span class="keyword">call</span> readkey</span><br><span class="line">        <span class="keyword">jz</span> again</span><br><span class="line">	 </span><br><span class="line"><span class="meta">	 .exit</span> <span class="number">0</span></span><br><span class="line">	 end start</span><br></pre></td></tr></table></figure>

<h3 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line">counter <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">		 </span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">350bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">cli</span> </span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span>	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">seg</span> new0bh</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,offset new0bh</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">250bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">21h</span> </span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span>	</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0f7h</span>	</span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span>	</span><br><span class="line">	<span class="keyword">mov</span> counter,<span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28bh</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10100000b</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">00001101b</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> counter,<span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28ah</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">sti</span> </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">01h</span></span><br><span class="line">	</span><br><span class="line"><span class="symbol">start1:</span></span><br><span class="line">	<span class="keyword">cmp</span> counter,<span class="number">8</span></span><br><span class="line">	<span class="keyword">jb</span> start1</span><br><span class="line">	<span class="keyword">cli</span>	</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span>	</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">250bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">new0bh proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">288h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">rol</span> <span class="built_in">bl</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">inc</span> counter</span><br><span class="line">	<span class="comment">;EOI</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">20h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">iret</span></span><br><span class="line">new0bh endp</span><br><span class="line"></span><br><span class="line">	end start</span><br></pre></td></tr></table></figure>

<h3 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line">counter <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span>	 </span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">350bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">cli</span> </span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span>	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">seg</span> new0bh</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,offset new0bh</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">250bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">21h</span> </span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span>	</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0f7h</span>	</span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span>	</span><br><span class="line">	<span class="keyword">mov</span> counter,<span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28bh</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10110000b</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">00001001b</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> counter,<span class="number">0</span></span><br><span class="line">	<span class="comment">;</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28ah</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">sti</span> </span><br><span class="line"><span class="symbol">start1:</span></span><br><span class="line">	<span class="keyword">cmp</span> counter,<span class="number">5</span></span><br><span class="line">	<span class="keyword">jb</span> start1</span><br><span class="line">	<span class="keyword">cli</span>	</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span>	</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">250bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">new0bh proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">288h</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">call</span> dispbb</span><br><span class="line">	<span class="keyword">call</span> dispcrlf</span><br><span class="line">	<span class="keyword">inc</span> counter</span><br><span class="line">	<span class="comment">;EOI</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">20h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">iret</span></span><br><span class="line">new0bh endp</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h3 id="6-4"><a href="#6-4" class="headerlink" title="6.4"></a>6.4</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">		 </span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28bh</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10100000b</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">00001101b</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">01h</span></span><br><span class="line">	<span class="keyword">call</span> prints	</span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">prints proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	</span><br><span class="line"><span class="symbol">print1:</span> </span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">288h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">rol</span> <span class="built_in">bl</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">call</span> delay</span><br><span class="line"></span><br><span class="line">	<span class="comment">;读取C端口</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28ah</span></span><br><span class="line"><span class="symbol">print2:</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">test</span> <span class="built_in">al</span>,<span class="number">10000000b</span></span><br><span class="line">	<span class="keyword">jz</span> print2</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">bl</span>,<span class="number">01h</span></span><br><span class="line">	<span class="keyword">jnz</span> print1</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">prints endp</span><br><span class="line"></span><br><span class="line">timer=<span class="number">100</span></span><br><span class="line"><span class="comment">;延时子程序</span></span><br><span class="line">delay proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,timer</span><br><span class="line"><span class="symbol">delay1:</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">cx</span>,<span class="built_in">cx</span></span><br><span class="line"><span class="symbol">delay2:</span></span><br><span class="line">	<span class="keyword">loop</span> delay2</span><br><span class="line">	<span class="keyword">dec</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">jnz</span> delay1</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">delay endp</span><br><span class="line"></span><br><span class="line">	end start</span><br></pre></td></tr></table></figure>

<h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><h3 id="8-1"><a href="#8-1" class="headerlink" title="8.1"></a>8.1</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line">ledtb <span class="built_in">byte</span> <span class="number">3fh</span>,<span class="number">06h</span>,<span class="number">5bh</span>,<span class="number">4fh</span>,<span class="number">66h</span>,<span class="number">6dh</span>,<span class="number">7dh</span>,<span class="number">07h</span>,<span class="number">7fh</span>,<span class="number">6fh</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28bh</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10000001b</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">bx</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="symbol"> f:</span>   <span class="keyword">call</span> readuib</span><br><span class="line">    	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,ledtb[<span class="built_in">bx</span>]</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">288h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">jmp</span> f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line">	end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-2"><a href="#8-2" class="headerlink" title="8.2"></a>8.2</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> 	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line">leddt <span class="built_in">byte</span> <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line">ledtb <span class="built_in">byte</span> <span class="number">3fh</span>,<span class="number">06h</span>,<span class="number">5bh</span>,<span class="number">4fh</span>,<span class="number">66h</span>,<span class="number">6dh</span>,<span class="number">7dh</span>,<span class="number">07h</span>,<span class="number">7fh</span>,<span class="number">6fh</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;8255 method cotrol word</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28bh</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10000000b</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">     </span><br><span class="line"><span class="symbol">again:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset leddt</span><br><span class="line">	<span class="keyword">call</span> displed</span><br><span class="line">	<span class="keyword">jmp</span> again</span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">displed proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">bx</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="comment">;which light </span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">00001000b</span></span><br><span class="line"><span class="symbol">led1:</span></span><br><span class="line">	<span class="comment">;pa</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,ledtb[<span class="built_in">bx</span>]</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">288h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;pb which light to light</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">289h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;delay</span></span><br><span class="line">	<span class="keyword">call</span> delay</span><br><span class="line">	<span class="comment">;next light</span></span><br><span class="line">	<span class="keyword">ror</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">	<span class="comment">;all lights light,exit and begin nest round</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">10000000b</span></span><br><span class="line">	<span class="keyword">jnz</span> led1</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">displed endp</span><br><span class="line">	</span><br><span class="line">time=<span class="number">20</span></span><br><span class="line">delay proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,time</span><br><span class="line"><span class="symbol">delay1:</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">cx</span>,<span class="built_in">cx</span></span><br><span class="line"><span class="symbol">delay2:</span></span><br><span class="line">	<span class="keyword">loop</span> delay2</span><br><span class="line">	<span class="keyword">dec</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">jnz</span> delay1</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">delay endp</span><br><span class="line">	end start</span><br></pre></td></tr></table></figure>

<h3 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">  	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line">leddt <span class="built_in">byte</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">ledtb <span class="built_in">byte</span> <span class="number">3fh</span>,<span class="number">06h</span>,<span class="number">5bh</span>,<span class="number">4fh</span>,<span class="number">66h</span>,<span class="number">6dh</span>,<span class="number">7dh</span>,<span class="number">07h</span>,<span class="number">7fh</span>,<span class="number">6fh</span></span><br><span class="line">num 	<span class="built_in">word</span> <span class="number">1</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;8255 method cotrol word</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28bh</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10000000b</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"><span class="symbol">again:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset leddt</span><br><span class="line">	<span class="keyword">call</span> displed</span><br><span class="line">	<span class="keyword">call</span> numadd</span><br><span class="line">	<span class="keyword">jmp</span> again</span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">displed proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">bx</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="comment">;which light </span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">00001000b</span></span><br><span class="line"><span class="symbol">led1:</span></span><br><span class="line">	<span class="comment">;pa</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,[<span class="built_in">si</span>]</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,ledtb[<span class="built_in">bx</span>]</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">288h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;pb which light to light</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">289h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;delay</span></span><br><span class="line">	<span class="keyword">call</span> delay</span><br><span class="line">	<span class="comment">;next light</span></span><br><span class="line">	<span class="keyword">ror</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">	<span class="comment">;all lights light,exit and begin nest round</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">10000000b</span></span><br><span class="line">	<span class="keyword">jnz</span> led1</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">displed endp</span><br><span class="line">	</span><br><span class="line">time=<span class="number">500</span></span><br><span class="line">delay proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,time</span><br><span class="line"><span class="symbol">delay1:</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">cx</span>,<span class="built_in">cx</span></span><br><span class="line"><span class="symbol">delay2:</span></span><br><span class="line">	<span class="keyword">loop</span> delay2</span><br><span class="line">	<span class="keyword">dec</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">jnz</span> delay1</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">delay endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numadd proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">10</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset leddt</span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">3</span></span><br><span class="line">	<span class="keyword">inc</span> num</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,num</span><br><span class="line"></span><br><span class="line">	<span class="keyword">div</span> <span class="built_in">bl</span></span><br><span class="line">	<span class="comment">;high is yushu</span></span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="number">ah</span></span><br><span class="line">	<span class="keyword">sub</span> <span class="built_in">si</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">call</span> dispbw</span><br><span class="line">	<span class="keyword">call</span> dispcrlf</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">div</span> <span class="built_in">bl</span></span><br><span class="line">	<span class="comment">;high is yushu</span></span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="number">ah</span></span><br><span class="line">	<span class="keyword">sub</span> <span class="built_in">si</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">call</span> dispbw</span><br><span class="line">	<span class="keyword">call</span> dispcrlf</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">div</span> <span class="built_in">bl</span></span><br><span class="line">	<span class="comment">;high is yushu</span></span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="number">ah</span></span><br><span class="line">	<span class="keyword">sub</span> <span class="built_in">si</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">call</span> dispbw</span><br><span class="line">	<span class="keyword">call</span> dispcrlf</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">div</span> <span class="built_in">bl</span></span><br><span class="line">	<span class="comment">;high is yushu</span></span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="number">ah</span></span><br><span class="line">	<span class="keyword">sub</span> <span class="built_in">si</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">call</span> dispbw</span><br><span class="line">	<span class="keyword">call</span> dispcrlf</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">numadd endp</span><br><span class="line">	end start</span><br></pre></td></tr></table></figure>

<h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><h3 id="10-2"><a href="#10-2" class="headerlink" title="10.2"></a>10.2</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> 	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line">msg <span class="built_in">byte</span> <span class="string">&#x27;press any key to exit&#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="symbol">again:</span>	</span><br><span class="line">	<span class="comment">;active DAC	</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">298h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">298h</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">call</span> delay</span><br><span class="line">	<span class="keyword">call</span> dispuib</span><br><span class="line">	<span class="keyword">call</span> dispcrlf</span><br><span class="line">	<span class="keyword">call</span> readkey</span><br><span class="line">	<span class="keyword">jz</span> again</span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">timer=<span class="number">100</span></span><br><span class="line">delay proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,timer</span><br><span class="line"><span class="symbol">delay1:</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">cx</span>,<span class="built_in">cx</span></span><br><span class="line"><span class="symbol">delay2:</span></span><br><span class="line">	<span class="keyword">loop</span> delay2</span><br><span class="line">	<span class="keyword">dec</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">jnz</span> delay1</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">delay endp</span><br><span class="line">	end start</span><br></pre></td></tr></table></figure>

<h3 id="10-3"><a href="#10-3" class="headerlink" title="10.3"></a>10.3</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> 	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="comment">;init 8255</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28bh</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="comment">;pc7=0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line"><span class="symbol">again:</span></span><br><span class="line">	<span class="comment">;active DAC	</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">298h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span> </span><br><span class="line">	<span class="comment">;pc7</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28ah</span></span><br><span class="line"><span class="symbol">start1:</span>	</span><br><span class="line">	<span class="keyword">call</span> delay</span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">test</span> <span class="built_in">al</span>,<span class="number">10000000b</span></span><br><span class="line">	<span class="keyword">jz</span> start1</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">298h</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">call</span> delay</span><br><span class="line">	<span class="keyword">call</span> dispuib</span><br><span class="line">	<span class="keyword">call</span> dispcrlf</span><br><span class="line">	<span class="keyword">call</span> readkey</span><br><span class="line">	<span class="keyword">jz</span> again</span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">timer=<span class="number">1000</span></span><br><span class="line">delay proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,timer</span><br><span class="line"><span class="symbol">delay1:</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">cx</span>,<span class="built_in">cx</span></span><br><span class="line"><span class="symbol">delay2:</span></span><br><span class="line">	<span class="keyword">loop</span> delay2</span><br><span class="line">	<span class="keyword">dec</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">jnz</span> delay1</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">delay endp</span><br><span class="line">	end start</span><br></pre></td></tr></table></figure>

<h3 id="10-4"><a href="#10-4" class="headerlink" title="10.4"></a>10.4</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line">temp		<span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line">intseg	<span class="built_in">word</span> <span class="number">0</span></span><br><span class="line">intoff	<span class="built_in">word</span> <span class="number">0</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="comment">;int</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">350bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">mov</span> intseg,<span class="built_in">es</span></span><br><span class="line">	<span class="keyword">mov</span> intoff,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">cli</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">seg</span> new0Bh</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,offset new0Bh</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">250Bh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="comment">;open IRQ3	</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">21h</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0f7h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"><span class="symbol">again:</span>  </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,temp</span><br><span class="line">	<span class="keyword">call</span> delay</span><br><span class="line">	<span class="keyword">call</span> dispuib</span><br><span class="line">      <span class="keyword">call</span> dispcrlf   </span><br><span class="line">      <span class="keyword">call</span> readkey</span><br><span class="line">      <span class="keyword">jz</span> again</span><br><span class="line"></span><br><span class="line">       <span class="keyword">cli</span></span><br><span class="line">       <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">       <span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ds</span>,intseg</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">dx</span>,intoff</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">250Bh</span></span><br><span class="line">       <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">       <span class="keyword">sti</span></span><br><span class="line"><span class="meta">       .exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">new0Bh proc</span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;active DAC	</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">298h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">298h</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">mov</span> temp,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">call</span> delay</span><br><span class="line">	</span><br><span class="line">	<span class="comment">;EOI</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">20h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">iret</span></span><br><span class="line">new0Bh endp</span><br><span class="line"></span><br><span class="line">timer=<span class="number">100</span></span><br><span class="line">delay proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,timer</span><br><span class="line"><span class="symbol">delay1:</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">cx</span>,<span class="built_in">cx</span></span><br><span class="line"><span class="symbol">delay2:</span></span><br><span class="line">	<span class="keyword">loop</span> delay2</span><br><span class="line">	<span class="keyword">dec</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">jnz</span> delay1</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">delay endp</span><br><span class="line">	end start</span><br></pre></td></tr></table></figure>

<h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p><strong>打印的时候只能打印出一页，这样不好。我们可以这样手动全选打印的区域，右键选择打印就可以了。应该是hexo自己的问题，因为别的网页都可以正常打印全部，不知道这是一个bug还是feature。</strong></p>
]]></content>
      <categories>
        <category>期末复习</category>
        <category>微机</category>
      </categories>
      <tags>
        <tag>微机</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 一 抽象数据类型ADT</title>
    <url>/2021/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BADT/</url>
    <content><![CDATA[<h1 id="抽象数据类型ADT"><a href="#抽象数据类型ADT" class="headerlink" title="抽象数据类型ADT"></a>抽象数据类型ADT</h1><p>计算机科学领域已开发了一种定义新类型的好方法，用 3 个步骤完成从抽象到具体的过程。</p>
<ol>
<li>提供类型属性和相关操作的抽象描述。这些描述既不能依赖特定的实现，也不能依赖特定的编程语言。这种正式的抽象描述被称为抽象数据类型 （ADT）。</li>
<li>开发一个实现 ADT 的编程接口。也就是说，指明如何储存数据和执行所需操作的函数。例如在 C中，可以提供结构定义和操控该结构的函数原型。这些作用于用户定义类型的函数相当于作用于 C 基本类型的内置运算符。需要使用该新类型的程序员可以使用这个接口进行编程。</li>
<li>编写代码实现接口。这一步至关重要，但是使用该新类型的程序员无需了解具体的实现细节。</li>
</ol>
<h2 id="建立ADT的步骤实践-以链表为例"><a href="#建立ADT的步骤实践-以链表为例" class="headerlink" title="建立ADT的步骤实践 以链表为例"></a>建立ADT的步骤实践 以链表为例</h2><h3 id="建立抽象"><a href="#建立抽象" class="headerlink" title="建立抽象"></a>建立抽象</h3><p>链表应该实现以下功能。</p>
<ol>
<li>初始化一个空链表</li>
<li>再链表结尾添加一个新的项</li>
<li>判断链表是否为空</li>
<li>判断链表是否已经满了</li>
<li>确定链表中的元素个数</li>
<li>访问链表中的项 例如数组的 <strong>[]</strong> 运算符和指针的 <strong>-&gt;</strong> 运算符</li>
<li>在链表中的任意位置添加一个项</li>
<li>移除链表中的任意一项</li>
<li>更替链表中的某一项</li>
<li>在链表中搜索一个项 根据某个数据找到对应的项比如最大值</li>
</ol>
<h3 id="建立接口"><a href="#建立接口" class="headerlink" title="建立接口"></a>建立接口</h3><p>数据隐藏是一种从编程的更高层次隐藏数据表示细节的艺术</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TSIZE 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">film</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//电影标题</span></span><br><span class="line">    <span class="keyword">char</span> title[TSIZE];</span><br><span class="line">    <span class="comment">//电影评分</span></span><br><span class="line">    <span class="keyword">int</span> rating;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义 item 为链表中的项的类型 这样只要使用item就可以方便的确定链表的数据类型了，也很容易改变。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">film</span> <span class="title">Item</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在必须确定如何在链表中存储这种数据类型 item</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Item item;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义一个结点数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="comment">//定义一个抽象的链表数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="comment">/*我们也可以这样定义，为链表添加一些信息</span></span><br><span class="line"><span class="comment">typedef struct list</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Node* head;</span></span><br><span class="line"><span class="comment">    Node* tail;</span></span><br><span class="line"><span class="comment">    int size;</span></span><br><span class="line"><span class="comment">    //更多的信息</span></span><br><span class="line"><span class="comment">&#125;List;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 初始化一个链表</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表</span></span><br><span class="line"><span class="comment">//结果： 链表初始化为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeList</span><span class="params">(List *plist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 判断链表是否为空</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表</span></span><br><span class="line"><span class="comment">//结果： 如果为空返回true,反之返回false</span></span><br><span class="line"><span class="comment">//说明： const限定是为了防止恶意修改链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(<span class="keyword">const</span> List *plist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 判断链表是否为满</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表</span></span><br><span class="line"><span class="comment">//结果： 如果为满返回true,反之返回false</span></span><br><span class="line"><span class="comment">//说明： const限定是为了防止恶意修改链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Full</span><span class="params">(<span class="keyword">const</span> List *plist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 确定链表中的项数</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表</span></span><br><span class="line"><span class="comment">//结果： 返回链表中的项数</span></span><br><span class="line"><span class="comment">//说明： const限定是为了防止恶意修改链表</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Count</span><span class="params">(<span class="keyword">const</span> List *plist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 在链表的结尾添加一项</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表</span></span><br><span class="line"><span class="comment">//结果： 若添加成功返回true,失败则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddItem</span><span class="params">(Item item, List *plist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 遍历链表，将函数作用于链表中的每一项</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表，pfun是一个无返回值的函数</span></span><br><span class="line"><span class="comment">//结果： 将函数作用于链表中的每一项</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(List *plist, <span class="keyword">void</span> (*pfun)(Item item))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 清空链表并释放空间</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表</span></span><br><span class="line"><span class="comment">//结果： 若添加成功返回true,失败则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Clear</span><span class="params">(List *plist)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 初始化一个链表</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表</span></span><br><span class="line"><span class="comment">//结果： 链表初始化为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeList</span><span class="params">(List *plist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *plist = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 判断链表是否为空</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表</span></span><br><span class="line"><span class="comment">//结果： 如果为空返回true,反之返回false</span></span><br><span class="line"><span class="comment">//说明： const限定是为了防止恶意修改链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(<span class="keyword">const</span> List *plist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*plist == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 判断链表是否为满</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表</span></span><br><span class="line"><span class="comment">//结果： 如果为满返回true,反之返回false</span></span><br><span class="line"><span class="comment">//说明： const限定是为了防止恶意修改链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Full</span><span class="params">(<span class="keyword">const</span> List *plist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *pt;</span><br><span class="line">    <span class="keyword">bool</span> full;</span><br><span class="line">    pt = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (pt == <span class="literal">NULL</span>)</span><br><span class="line">        full = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        full = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">free</span>(pt);</span><br><span class="line">    <span class="keyword">return</span> full;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 确定链表中的项数</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表</span></span><br><span class="line"><span class="comment">//结果： 返回链表中的项数</span></span><br><span class="line"><span class="comment">//说明： const限定是为了防止恶意修改链表</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Count</span><span class="params">(<span class="keyword">const</span> List *plist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Node *pnode = *plist;</span><br><span class="line">    <span class="keyword">while</span> (pnode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 在链表的结尾添加一项</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表</span></span><br><span class="line"><span class="comment">//结果： 若添加成功返回true,失败则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddItem</span><span class="params">(Item item, List *plist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *pnew;</span><br><span class="line">    Node *scan = *plist;</span><br><span class="line">    pnew = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    pnew-&gt;item = item;</span><br><span class="line">    pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (*plist == <span class="literal">NULL</span>)</span><br><span class="line">        *plist = pnew;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        scan = *plist;</span><br><span class="line">        <span class="keyword">while</span> (scan-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            scan = scan-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        scan-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 遍历链表，将函数作用于链表中的每一项</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表，pfun是一个无返回值的函数</span></span><br><span class="line"><span class="comment">//结果： 将函数作用于链表中的每一项</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(List *plist, <span class="keyword">void</span> (*pfun)(Item item))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *scan = *plist;</span><br><span class="line">    <span class="keyword">while</span> (scan != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pfun(scan-&gt;item);</span><br><span class="line">        scan = scan-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作： 清空链表并释放空间</span></span><br><span class="line"><span class="comment">//条件： plist指向一个链表</span></span><br><span class="line"><span class="comment">//结果： 若添加成功返回true,失败则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(List *plist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *scan = *plist;</span><br><span class="line">    <span class="keyword">while</span> (*plist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *plist = scan-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(scan);</span><br><span class="line">        scan = *plist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfun</span><span class="params">(Item Item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, Item.title, Item.rating);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List mylist;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化链表\n&quot;</span>);</span><br><span class="line">    InitializeList(&amp;mylist);</span><br><span class="line">    Item myitem;</span><br><span class="line">    <span class="built_in">strcpy</span>(myitem.title, <span class="string">&quot;cuiwenyaono.1&quot;</span>);</span><br><span class="line">    myitem.rating = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前链表内的元素数量为%d\n&quot;</span>, Count(&amp;mylist));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;添加项目\n&quot;</span>);</span><br><span class="line">    AddItem(myitem, &amp;mylist);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前链表内的元素数量为%d\n&quot;</span>, Count(&amp;mylist));</span><br><span class="line">    <span class="keyword">if</span> (Empty(&amp;mylist))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前链表为空\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前链表不空\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Full(&amp;mylist))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前链表满了\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前链表不满\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印链表\n&quot;</span>);</span><br><span class="line">    Traverse(&amp;mylist, (*pfun));</span><br><span class="line">    Clear(&amp;mylist);</span><br><span class="line">    <span class="keyword">if</span> (Empty(&amp;mylist))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前链表为空\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前链表不空\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
        <category>ADT</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>ADT</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 三 栈</title>
    <url>/2021/06/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%89-%E6%A0%88/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈，依靠线性表来实现。</p>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><ol>
<li>构造一个空栈</li>
<li>销毁一个栈</li>
<li>清空栈</li>
<li>判断栈是否为空</li>
<li>栈中元素个数</li>
<li>获得栈顶元素</li>
<li>push</li>
<li>pop</li>
<li>遍历栈</li>
</ol>
<h2 id="栈的顺序表实现"><a href="#栈的顺序表实现" class="headerlink" title="栈的顺序表实现"></a>栈的顺序表实现</h2><h3 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../Linear-List/linearlist.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stack 可以直接使用 list 作为基础构建不同的stack  其实list就是所有线性数据结构的基础。</span></span><br><span class="line"><span class="comment">//我觉得之前的list的实现很不优雅，所以决定再重新实现一遍</span></span><br><span class="line"><span class="comment">//要学会抓住事情的主要矛盾，学习栈就是要学习其后进先出的思想，现在不要管其他杂乱的东西。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinearStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//存储数据的区域   这里的block就相当于linearlist 中的List</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinearList</span> *<span class="title">block</span>;</span></span><br><span class="line">    Item *base;</span><br><span class="line">    Item *top;</span><br><span class="line">    <span class="comment">//当前长度</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="comment">//当前分配的存储容量</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; * LinearStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>, <span class="keyword">int</span> initsize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ClearStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EmptyStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTopStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>, Item *itemsave)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PushStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>, Item *item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AutoFillStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>, <span class="keyword">void</span> (*fun)(Item item))</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linearstack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>, <span class="keyword">int</span> initsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*<span class="built_in">stack</span>) = (struct LinearStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LinearStack));</span><br><span class="line">    InitLinearList(&amp;((*<span class="built_in">stack</span>)-&gt;block), initsize);</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;base = (Item *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Item));</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;top = (Item *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Item));</span><br><span class="line">    <span class="comment">//由于这了的base和top只是item*类型的，所以指向特定的item有点累赘，不如直接存储特定的元素值，除非改变其类型为指向一个结点的指针，这样只更更改其指向会更加由必要。</span></span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;length = <span class="number">0</span>;</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;stacksize = initsize;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化成功\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DestroyLinearList(&amp;((*<span class="built_in">stack</span>)-&gt;block));</span><br><span class="line">    <span class="built_in">free</span>((*<span class="built_in">stack</span>)-&gt;base);</span><br><span class="line">    <span class="built_in">free</span>((*<span class="built_in">stack</span>)-&gt;top);</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;base = <span class="literal">NULL</span>;</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;block = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    *<span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;销毁成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;销毁失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ClearStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>((*<span class="built_in">stack</span>)-&gt;base);</span><br><span class="line">    <span class="built_in">free</span>((*<span class="built_in">stack</span>)-&gt;top);</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;base = (Item *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Item));</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;top = (Item *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Item));</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;length = <span class="number">0</span>;</span><br><span class="line">    ClearLinearList(&amp;((*<span class="built_in">stack</span>)-&gt;block));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;清空栈成功\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EmptyStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">stack</span>)-&gt;length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈不空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTopStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>, Item *itemsave)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">stack</span>)-&gt;length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误，栈中没有元素\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *itemsave = *((*<span class="built_in">stack</span>)-&gt;top);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PushStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>, Item *item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前容量为：%d, 可用容量为：%d\n&quot;</span>, (*<span class="built_in">stack</span>)-&gt;stacksize, (*<span class="built_in">stack</span>)-&gt;stacksize - (*<span class="built_in">stack</span>)-&gt;length);</span><br><span class="line">    InsertLinearList(&amp;((*<span class="built_in">stack</span>)-&gt;block), (*<span class="built_in">stack</span>)-&gt;length, item);</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;length++;</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;stacksize = (*<span class="built_in">stack</span>)-&gt;block-&gt;listsize;</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">stack</span>)-&gt;length == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//base只是指针不需要分配内存，也没有内存，所以只能通过改变指向的方式改变base,top也一样。</span></span><br><span class="line">        *((*<span class="built_in">stack</span>)-&gt;base) = ((*<span class="built_in">stack</span>)-&gt;block-&gt;items[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    *((*<span class="built_in">stack</span>)-&gt;top) = ((*<span class="built_in">stack</span>)-&gt;block-&gt;items[(*<span class="built_in">stack</span>)-&gt;length - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">stack</span>)-&gt;length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已经空了，不能pop\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除最后一个元素。</span></span><br><span class="line">    DeleteLinearList(&amp;((*<span class="built_in">stack</span>)-&gt;block), (*<span class="built_in">stack</span>)-&gt;length - <span class="number">1</span>);</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;length--;</span><br><span class="line">    <span class="comment">//更改 top</span></span><br><span class="line">    *((*<span class="built_in">stack</span>)-&gt;top) = (*<span class="built_in">stack</span>)-&gt;block-&gt;items[(*<span class="built_in">stack</span>)-&gt;length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AutoFillStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Item item;</span><br><span class="line">        item.value = i;</span><br><span class="line">        PushStack(<span class="built_in">stack</span>, &amp;item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseStack</span><span class="params">(LinearStack *<span class="built_in">stack</span>, <span class="keyword">void</span> (*fun)(Item item))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Item item;</span><br><span class="line">    <span class="keyword">while</span> (!EmptyStack(<span class="built_in">stack</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        GetTopStack(<span class="built_in">stack</span>, &amp;item);</span><br><span class="line">        PopStack(<span class="built_in">stack</span>);</span><br><span class="line">        fun(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linearstack.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(Item item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;item: %d\n&quot;</span>, item.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinearStack <span class="built_in">stack</span>;</span><br><span class="line">    InitStack(&amp;<span class="built_in">stack</span>, <span class="number">5</span>);</span><br><span class="line">    AutoFillStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    TraverseStack(&amp;<span class="built_in">stack</span>, (*fun2));</span><br><span class="line">    ClearStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    DestroyStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈的链表实现"><a href="#栈的链表实现" class="headerlink" title="栈的链表实现"></a>栈的链表实现</h2><h3 id="接口说明-1"><a href="#接口说明-1" class="headerlink" title="接口说明"></a>接口说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../Link-List/linklist.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//存储数据的区域   这里的block就相当于LinkList 中的List</span></span><br><span class="line">    LinkList block;</span><br><span class="line">    Item *base;</span><br><span class="line">    Item *top;</span><br><span class="line">    <span class="comment">//当前长度</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; * LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ClearStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EmptyStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTopStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>, Item *itemsave)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PushStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>, Item *item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AutoFillStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>, <span class="keyword">void</span> (*fun)(Item item))</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口实现-1"><a href="#接口实现-1" class="headerlink" title="接口实现"></a>接口实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linkstack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*<span class="built_in">stack</span>) = (LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LinkStack));</span><br><span class="line">    InitLinkList(&amp;((*<span class="built_in">stack</span>)-&gt;block));</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;length = <span class="number">0</span>;</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;base = (Item *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Item));</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;top = (Item *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Item));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化LinkStack成功\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DestroyLinkList(&amp;((*<span class="built_in">stack</span>)-&gt;block));</span><br><span class="line">    <span class="built_in">free</span>((*<span class="built_in">stack</span>));</span><br><span class="line">    (*<span class="built_in">stack</span>) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;销毁LinkStack成功\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ClearStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ClearLinkList(&amp;((*<span class="built_in">stack</span>)-&gt;block));</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;length = <span class="number">0</span>;</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;base = <span class="literal">NULL</span>;</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;清空LinkStack成功\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EmptyStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">stack</span>)-&gt;length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LinkStack空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LinkStack不空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTopStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>, Item *itemsave)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">stack</span>)-&gt;length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误，栈中没有元素\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *itemsave = *((*<span class="built_in">stack</span>)-&gt;top);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PushStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>, Item *item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InsertLinkList(&amp;((*<span class="built_in">stack</span>)-&gt;block), (*<span class="built_in">stack</span>)-&gt;length, item);</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;length++;</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">stack</span>)-&gt;length == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GetItemLinkList(&amp;((*<span class="built_in">stack</span>)-&gt;block), <span class="number">0</span>, (*<span class="built_in">stack</span>)-&gt;base);</span><br><span class="line">    &#125;</span><br><span class="line">    GetItemLinkList(&amp;((*<span class="built_in">stack</span>)-&gt;block), (*<span class="built_in">stack</span>)-&gt;length - <span class="number">1</span>, (*<span class="built_in">stack</span>)-&gt;top);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">stack</span>)-&gt;length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已经空了，不能pop\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除top</span></span><br><span class="line">    DeleteLinkList(&amp;((*<span class="built_in">stack</span>)-&gt;block), (*<span class="built_in">stack</span>)-&gt;length - <span class="number">1</span>);</span><br><span class="line">    (*<span class="built_in">stack</span>)-&gt;length--;</span><br><span class="line">    <span class="comment">//更改top</span></span><br><span class="line">    GetItemLinkList(&amp;((*<span class="built_in">stack</span>)-&gt;block), (*<span class="built_in">stack</span>)-&gt;length - <span class="number">1</span>, (*<span class="built_in">stack</span>)-&gt;top);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AutoFillStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= AUTOFILLSIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Item item;</span><br><span class="line">        item.value = i;</span><br><span class="line">        PushStack(<span class="built_in">stack</span>, &amp;item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseStack</span><span class="params">(LinkStack *<span class="built_in">stack</span>, <span class="keyword">void</span> (*fun)(Item item))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TraverseStack\n&quot;</span>);</span><br><span class="line">    Item item;</span><br><span class="line">    <span class="keyword">while</span> (!EmptyStack(<span class="built_in">stack</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        GetTopStack(<span class="built_in">stack</span>, &amp;item);</span><br><span class="line">        fun(item);</span><br><span class="line">        PopStack(<span class="built_in">stack</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口使用-1"><a href="#接口使用-1" class="headerlink" title="接口使用"></a>接口使用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linkstack.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Item item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;item: %d\n&quot;</span>, item.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack <span class="built_in">stack</span>;</span><br><span class="line">    InitStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    AutoFillStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    TraverseStack(&amp;<span class="built_in">stack</span>, (*fun));</span><br><span class="line">    ClearStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    DestroyStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习C</title>
    <url>/2021/07/01/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0C/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理函数"><a href="#内存管理函数" class="headerlink" title="内存管理函数"></a>内存管理函数</h3><blockquote>
<ol>
<li><pre><code>void *malloc(int num);
</code></pre>
在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><pre><code>void *calloc(int num, int size);
</code></pre>
在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><pre><code>void *realloc(void *address, int newsize);
</code></pre>
该函数重新分配内存，把内存扩展到 newsize。</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li><pre><code>void free(void *address);
</code></pre>
该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</li>
</ol>
</blockquote>
<h4 id="关于-realloc-的坑"><a href="#关于-realloc-的坑" class="headerlink" title="关于 realloc 的坑"></a>关于 realloc 的坑</h4><p>1、realloc失败的时候，返回NULL</p>
<p>2、realloc失败的时候，原来的内存不改变，不会释放也不会移动</p>
<p>3、假如原来的内存后面还有足够多剩余内存的话，realloc的内存=原来的内存+剩余内存,realloc还是返回原来内存的地址; 假如原来的内存后面没有足够多剩余内存的话，realloc将申请新的内存，然后把原来的内存数据拷贝到新内存里，原来的内存将被free掉, realloc返回新内存的地址。</p>
<p>4、如果size为0，效果等同于free()。</p>
<p>5、传递给realloc的指针必须是先前通过malloc(), calloc(), 或realloc()分配的,或者是NULL</p>
<p>6、传递给realloc的指针可以为空，等同于malloc。</p>
<p><strong>如果在连续的realloc中，有一次的size==0,则相当于free了目标指针，则这个指针就变成了野指针，继而在下一次realloc中，就会报错</strong></p>
<p><strong>记住，内存分配一定不要忘记size是 num*sizeof(type)</strong></p>
<h3 id="QUS"><a href="#QUS" class="headerlink" title="QUS"></a>QUS</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><strong><a href="https://blog.csdn.net/u011727691/article/details/66981143">什么情况下指针需要使用malloc分配内存，什么时候不需要</a></strong></p>
<p>1.在c语言中，内存模型分为栈和堆。</p>
<p>2，这两种模型内存的方式是不同的，在栈中存放的变量是由系统自动管理的，在函数结束后系统会自动释放，不需要人为的进行任何操作。</p>
<p>3，而在堆中存放的是用户自己管理的内存，手动分配的，malloc建立，系统不会在函数体执行结束后自动释放，需要用户手动释放通过free函数。</p>
<p>当你对分配的空间进行自己的管理和释放需要使用malloc，或者当你的分配的空间在函数结束后还需要存在。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//此时在堆中建立了存放int的空间。</span></span><br><span class="line"></span><br><span class="line">    *p=<span class="number">2</span>;</span><br><span class="line">    returen p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = create();<span class="comment">//此时执行完后 刚刚在函数体内用malloc分配的空间还在，还存着2。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*a);<span class="comment">//输出2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p><strong><a href="https://zhidao.baidu.com/question/872413254876148412.html">为什么可以对 malloc函数声明 的*p直接赋值 而 对 int *p声明中的*p不能直接赋值</a></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));                   </span><br><span class="line">此时p是一个<span class="keyword">int</span>指针，它指向<span class="built_in">malloc</span>分配给他的一个地址，此地址已经有意义，只是这个地址内部的值还是随机的，比如我们认为p=<span class="number">0x1234</span>              </span><br><span class="line">*p = <span class="number">20</span>;                </span><br><span class="line">此时往<span class="number">0x1234</span>这个地址内部放入一个<span class="keyword">int</span>数，完全OK的操作         </span><br><span class="line">但是<span class="keyword">int</span> * q， 仅仅定义了q是一个<span class="keyword">int</span>型的地址，但是q此时是随机值（windows下一般为<span class="number">0xcccc</span>），也就是俗称的野指针          </span><br><span class="line">那么*p = <span class="number">20</span>; 的操作就是极度危险的，因为没人能预测你到底把这个<span class="number">20</span>放到了系统的哪里，很可能会造成不可预测的破坏。           </span><br></pre></td></tr></table></figure>

<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p><strong>紧紧抓住c语言形参与实参的关系，这样才能更好的使用指针</strong></p>
<p>由于是值传递，所以传入指针的值，在函数中进行更改不会改变实参的数据。<br>eg:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Item itemsave;</span><br><span class="line">GetItemLinkList(&amp;list, <span class="number">2</span>, &amp;itemsave);</span><br><span class="line"><span class="regexp">//</span>这个函数这样实现</span><br><span class="line"><span class="regexp">//</span>直接改变itemsave时改变形参，对外面的实参没有任何影响。  只有 *itemsave=    才会有作用。</span><br><span class="line">itemsave = &amp;(p-&gt;item);</span><br><span class="line"><span class="regexp">//</span>这样是不对的，以为函数中的itemsave只是一个形参，其指向的内存和传入的实参是一样的，但是这行代码又修改了itemsave的指向，对实参无法造成任何影响。</span><br><span class="line"><span class="regexp">//</span>必须改为这样</span><br><span class="line">*itemsave=p-&gt;item;</span><br><span class="line"><span class="regexp">//</span>这样，直接修改 *itemsave就是在修改实参的值<span class="regexp">//</span></span><br><span class="line">这也就是为什么说指针传入的值可以修改，不是说可以直接对指针进行修改，而是拿着传入的指针的值，由此得到指向的内存地址（实参的内存地址）然后就可以直接修改这块内存的值了，即修改实参。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-小心野针"><a href="#4-小心野针" class="headerlink" title="4 小心野针"></a>4 小心野针</h4><blockquote>
<p>初始化一个指针的时候，切记要令其指向NULL;<br>在使用完成一个指针后，切记要进行free.<br>在free一个指针过后，切记要令其指向NULL</p>
</blockquote>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络期末复习</title>
    <url>/2021/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="计算机网络期末复习"><a href="#计算机网络期末复习" class="headerlink" title="计算机网络期末复习"></a>计算机网络期末复习</h1><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><p>电路交换：整个报文的比特流连续地从源点直达终点，就好像在一个管道中传送。<br>报文交换：整个报文先传送到相邻结点，全部存储下来之后，查找转发表，转发到下一个结点。<br>分组交换：单个分组（整个报文的一部分）传送到相邻结点，存储下来后查找转发表转发到下一个结点。        </p>
<p>广域网：WAN<br>城域网：MAN<br>局域网：LAN<br>个人区域网：PAN</p>
<p>计算机网络的性能指标：      </p>
<ol>
<li>速率<ol>
<li>比特率</li>
</ol>
</li>
<li>带宽<ol>
<li>信号具有的频带宽度（频域）</li>
<li>单位时间内网络通道可以通过的最高数据率</li>
</ol>
</li>
<li>吞吐量<ol>
<li>单位时间内通过某个网络的实际数据量。</li>
</ol>
</li>
<li>时延 总时延=以下四种时延相加<ol>
<li>发送时延=数据帧长度/发送速率</li>
<li>传播时延=信道长度/电磁波在信道上的传输速率</li>
<li>处理时延</li>
<li>排队时延</li>
</ol>
</li>
<li>时延带宽积<ol>
<li>时延带宽积=传播时延*带宽 表示传输管道的体积，链路可以容纳的比特数量。又称为以比特为单位的链路长度</li>
</ol>
</li>
<li>RTT<ol>
<li>双向交互一次需要的时间</li>
</ol>
</li>
<li>利用率<ol>
<li>d=D/(1-U) d代表网络当前时延，D代表网络空闲时的时延，U是网络的利用率</li>
</ol>
</li>
</ol>
<p>计算机网络体系结构：            </p>
<ol>
<li>应用层<ol>
<li>应用层是体系结构中的最高层，其任务是通过应用进程之间的交互来完成特定网络应用。</li>
<li>应用层协议定义的是应用进程间通信和交互的规则。</li>
<li>应用层交互的数据单元称为报文。</li>
<li>应用层举例： DNS,HTTP,SMTP</li>
</ol>
</li>
<li>运输层<ol>
<li>运输层的主要任务就是负责向两台主机中进程的通信提供通用的数据传输服务。</li>
<li>运输层使用下面两种协议：<ol>
<li>传输控制协议TCP  提供面向连接的可靠的数据传输服务，其数据传输的单位是报文段。</li>
<li>用户数据报协议UDP  提供无连接的，尽最大努力交付的数据传输服务，其数据传输的单位是用户数据报。</li>
</ol>
</li>
</ol>
</li>
<li>网络层<ol>
<li>网络层负责为分组交换网上的不同主机提供通信服务。</li>
<li>发送数据的时候，网络层吧运输层产生的报文段或者用户数据报封装成分组或者包进行传送。在TCP/IP协议中由于使用IP协议，所以分组也叫做IP数据报。</li>
<li>网络层还有一个任务就是选择合适的路由，使得源主机运输层传下来的IP数据报能够通过网络中的路由器找到目的主机。</li>
<li>互联网是由大量的异构网络通过路由器相互连接而成的，互联网使用的网络层协议是无连接的网际协议IP和许多种路由选择协议。</li>
</ol>
</li>
<li>数据链路层<ol>
<li>简称链路层，在相邻两个结点之间传送数据时，将网络层交下来的IP数据报封装成帧，在相邻两个结点间的链路上传输帧，每一帧包含数据和必要的控制信息。</li>
<li>在接收数据时，控制信息使得接收端能够知道一个帧从哪个比特开始到哪个比特结束，收到帧之后，提取出数据部分上交给网络层。</li>
<li>控制信息使得接收端能够检测收到的帧中有没有差错，若有差错则丢弃这个帧。</li>
<li>如果需要改正数据中在数据链路层传输时出现的差错就要采用可靠传输协议来纠正出现的差错。</li>
</ol>
</li>
<li>物理层<ol>
<li>物理层传输的数据单位是比特。</li>
</ol>
</li>
</ol>
<h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><ol>
<li><p>物理层的特性</p>
<ol>
<li>机械特性</li>
<li>电气特性</li>
<li>功能特性</li>
<li>过程特性</li>
</ol>
</li>
<li><p>数据通信系统</p>
<ol>
<li>源系统<ol>
<li>源点，产生要传输的数据。</li>
<li>发送器，将要发送的数据进行编码。</li>
</ol>
</li>
<li>传输系统</li>
<li>目的系统<ol>
<li>接收器，将收到的信号进行解码。</li>
<li>终点，从接收器获取收到的数据。</li>
</ol>
</li>
</ol>
</li>
<li><p>信号的分类</p>
<ol>
<li>模拟信号 （连续信号）</li>
<li>数字信号 （离散信号）<ol>
<li>代表不同离散数值的基本波形称为码元。</li>
</ol>
</li>
</ol>
</li>
<li><p>信道的交互方式</p>
<ol>
<li>单向通信。比如广播。</li>
<li>双向交替通信（半双工）</li>
<li>双向同时通信（全双工）</li>
</ol>
</li>
<li><p>常用的编码方式</p>
<ol>
<li>不归零制。 正电平代表1，负电平代表0.</li>
<li>归零制。 正电平代表1，负电平代表0.</li>
<li>曼彻斯特编码。 位于周期中心的向上跳变代表0，位于周期中心的向下跳变代表1，也可以反过来定义。</li>
<li>差分曼彻斯特编码。 在每一位的中心处始终有跳变。位边界开始有跳变代表0，位开始边界没有跳变为1.</li>
</ol>
</li>
<li><p>基本的带通调制方法</p>
<ol>
<li>调幅</li>
<li>调频</li>
<li>调相</li>
</ol>
</li>
<li><p>信道复用技术</p>
<ol>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用（码分多址） CDMA<ol>
<li>CDMA中，每个站被指派一个唯一的m比特码片序列。发送m代表1，发送其反码代表0.</li>
<li>不同的站的码片序列正交内积为0. （这里将0写为-1）</li>
<li>收到</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ol>
<li>数据链路层使用的信道主要有以下两种类型<ol>
<li>点对点信道</li>
<li>广播信道</li>
</ol>
</li>
</ol>
<h3 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h3><p>点对点信道的数据链路层在进行通信时的主要步骤有：            </p>
<ol>
<li>结点A的数据链路层吧网络层交下来的IP数据包添加首部和尾部封装成帧。</li>
<li>结点A把封装好的帧发从给结点B的数据链路层。</li>
<li>结点B的数据链路层收到的帧无差错则从收到的帧中提取出IP数据报交给上面的网络层，否则丢弃这个帧。</li>
</ol>
<h4 id="使用点对点信道通信的三个基本问题"><a href="#使用点对点信道通信的三个基本问题" class="headerlink" title="使用点对点信道通信的三个基本问题"></a>使用点对点信道通信的三个基本问题</h4><ol>
<li>封装成帧</li>
<li>透明传输</li>
<li>差错检测</li>
</ol>
<h5 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h5><p>网络层的IP数据报传到数据链路层成为数据链路层的数据部分，添加首部和尾部构成完整的帧。每种数据链路层协议都规定了所能栓送的帧的数据部分长度上限–最大传送单元MTU。即IP数据包&lt;=MTU.<br>在帧的头部添加SOH（0x01)<br>在帧的尾部田间EOT（0x04)</p>
<h5 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h5><p>在数据链路层透明传输数据的意思是：无论怎样的比特组合的数据，都能够按照原样没有差错的通过数据链路层。<br>具体解决方法为在发送前：</p>
<ol>
<li>在数据部分出现的一个SOH前面添加一个转义字符ESE（0x1B)</li>
<li>在数据部分出现的一个EOT前面添加一个转义字符ESE（0x1B)</li>
<li>在数据部分出现的一个EOT前面添加一个转义字符ESE（0x1B)<br>在接受到数据之后删除即可。（看见一个转义字符就直接删除，如果有两个转移字符连在一起则只删除前一个）。</li>
</ol>
<h5 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h5><p>在数据链路层使用了循环冗余检验CRC进行检错。<br>假设要传输的数据为M=101101，其长度k=6，要获得的冗余码为n位，事先确定的除数P（n+1位）。运算过程为：          </p>
<ol>
<li>将M左移n位。</li>
<li>M除以P得到余数R。</li>
<li>将R作为冗余码拼接到M的后面。</li>
</ol>
<p>这种为了进行检错而添加的冗余码称为帧检验序列。FCS</p>
<p>接收端收到数据M（此时已经变为k+n位）后：        </p>
<ol>
<li>用M除以P得到余数R</li>
<li>若R为零，则传输没有差错（又很小的概率即使出错了仍然为零）。</li>
<li>R不为零，则丢弃这个帧。</li>
</ol>
<h3 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h3><p>PPP协议的帧格式：</p>
<table>
<thead>
<tr>
<th>首部</th>
<th>首部</th>
<th>首部</th>
<th>首部</th>
<th>数据部分</th>
<th>尾部</th>
<th>尾部</th>
</tr>
</thead>
<tbody><tr>
<td>F=0x7E</td>
<td>A=0xFF</td>
<td>C=0x03</td>
<td>协议</td>
<td>IP数据报</td>
<td>FCS</td>
<td>F=0x7E</td>
</tr>
</tbody></table>
<p>F=0x7E为帧定界符，每两个F之间为一个帧。</p>
<p>透明传输的两种方法：</p>
<ol>
<li><p>字节填充：              </p>
<ol>
<li>转移字符定义为0x7D</li>
<li>将0x7E变为两字节0x7D,0x5E</li>
<li>将0x7D变为0x7D,0x5D</li>
<li>若有ASCII控制字符（数值上小于0x20），则加上0x20并前面插入一个0x7D  例如0x03 –&gt; 0x7D,0x23</li>
</ol>
</li>
<li><p>零比特填充</p>
<ol>
<li>PPP在使用SONET/SDH链路时，采用同步传输，使用零比特填充来实现透明传输。</li>
<li>发送端只要发现有5个连续的1则立刻插入一个0</li>
<li>接收端接收端先找到标志字段F确定一个帧的边界。</li>
<li>每发现5个连续地1则删除其后面的0.</li>
</ol>
</li>
</ol>
<h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h3><p>以太网使用面向无连接的工作方式，不必先建立连接，采用尽最大努力的交付，即不可靠的交付。<br>以太网发送的数据帧都是用曼彻斯特编码。          </p>
<p>CSMA/CD协议的要点是：       </p>
<ol>
<li>多点接入：许多计算机连在同一根总线上。</li>
<li>载波监听：发送前和发送中都必须不停地检测信道是否空闲。</li>
<li>碰撞检测：也就是便发送边监听。</li>
</ol>
<p>几个重要的概念：</p>
<ol>
<li>争用期：以太网端到端的往返时间称为争用期，又称为碰撞窗口一个站在发送完数据之后只有通过争用期的考验还没有检测到碰撞才能说明这次发送没有发生碰撞。         </li>
<li>电磁波在1km的电缆的传播时延约为5us,</li>
</ol>
<p>以太网使用截断二进制指数退避来确定碰撞后重传的额时机。      </p>
<ol>
<li>基本的退避时间是争用期（51.2us),对于10Mbit/s的以太网，争用期可以发送512b数据，所以也可以称为512比特时间。</li>
<li>从离散的整数集合[0,1,…,(2^k-1)]中随机选取一个数，记为r,重传应该推迟的时间就是r倍的争用期。其中k=min[重传次数，10]；</li>
<li>当重传16此仍然失败，则丢弃这个帧并向高层汇报。</li>
</ol>
<p>强化碰撞：当发送数据的站发现了碰撞后，除了立刻停止发送数据之外，继续发送32b,或者48b的人为干扰信号，以便让所有用户都知道现在发生了碰撞。     </p>
<p>以太网规定帧间最小间隔为9.6us.</p>
<h4 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h4><ol>
<li>t=单程端到端的时延。</li>
<li>T=帧的发送时间。</li>
<li>α=t/T</li>
<li>信道的极限利用率=T/(t+T)=1/(1+α)；</li>
</ol>
<h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</p>
]]></content>
      <categories>
        <category>期末复习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>零碎的技术</title>
    <url>/2021/04/21/%E9%9B%B6%E7%A2%8E%E7%9A%84%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="零碎的技术"><a href="#零碎的技术" class="headerlink" title="零碎的技术"></a>零碎的技术</h1><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><blockquote>
<p>记录类型:<br>A记录：将域名指向一个IPv4地址（例如：10.10.10.10），需要增加A记录<br>CNAME记录：如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录<br>主机记录：<br>www ：将域名解析为<a href="http://www.example.com,填写www;/">www.example.com，填写www；</a><br>@ ：将域名解析为example.com（不带www），填写@或者不填写；</p>
</blockquote>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL</title>
    <url>/2021/06/15/C-STL/</url>
    <content><![CDATA[<h1 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h1><p><a href="http://c.biancheng.net/stl/">c语言中文网的STL教程</a></p>
<p>stl 是一个将算法与底层抽象实现相分离的库，通过它我们可以很轻松地，高效地实现很多复杂的算法。但是学习stl不仅仅要学习其使用方式，更重要的是学习其底层实现，若是掌握了其底层实现逻辑，则不仅拥有了扎实的数据结构的基本功，更是在c++修仙之路上修炼了一本武林秘籍。</p>
<p>c++ stl 的头文件有：   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;iterator&gt;      </span><br><span class="line">&lt;functional&gt;    </span><br><span class="line">&lt;vector&gt;    </span><br><span class="line">&lt;deque&gt;     </span><br><span class="line">&lt;list&gt;      </span><br><span class="line">&lt;queue&gt;     </span><br><span class="line">&lt;stack&gt;     </span><br><span class="line">&lt;set&gt;       </span><br><span class="line">&lt;map&gt;       </span><br><span class="line">&lt;algorithm&gt;     </span><br><span class="line">&lt;numeric&gt;       </span><br><span class="line">&lt;memory&gt;        </span><br><span class="line">&lt;utility&gt;      </span><br></pre></td></tr></table></figure>

<p>stl提供三种标准容器，分别为序列容器，排序容器，哈希容器。后两种也称为关联容器。     </p>
<table>
<thead>
<tr>
<th>容器种类</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>序列容器</td>
<td>主要包括vector，list，deque。元素在容器中的位置和元素的值没有关系，容器是非排序的。将元素插入时，指定在什么位置，元素就会在什么位置</td>
</tr>
<tr>
<td>排序容器</td>
<td>包含set,multiset,map,multimap.元素默认是从大到小排好的，插入元素时元素会自动插入到适当的位置。关联容器在查找时有着很好的性能。</td>
</tr>
<tr>
<td>哈希容器</td>
<td>unordered_set,unordered_map,unordered_multiset,unordered_multimap。和排序容器不同，哈希容器中元素的位置是未排序的，元素的位置有哈希函数确定。</td>
</tr>
</tbody></table>
<p><strong>迭代器</strong></p>
<p>stl标准库为每一种容器定义了一种迭代器，不同的容器迭代器不同，其功能强弱也不同。</p>
<ol>
<li>前向迭代器(forward iterator)<br>假设p是一个前向迭代器，则p支持p++,++p,*p操作，可以用相互赋值，可以使用==与!=进行比较。</li>
<li>双向迭代器(bidirectional iterator)<br>相比于前向迭代器，可以进行–p和p–操作。</li>
<li>随机访问迭代器(random acccess iterator)<br>除了双向迭代器的所有操作还支持以下操作：<ol>
<li>p+=i</li>
<li>p-=i</li>
<li>p+i</li>
<li>p-i</li>
<li>p[i]</li>
</ol>
</li>
</ol>
<p><strong>不同容器的迭代器</strong></p>
<table>
<thead>
<tr>
<th>容器</th>
<th>迭代器</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>随机</td>
</tr>
<tr>
<td>vector</td>
<td>随机</td>
</tr>
<tr>
<td>deque</td>
<td>随机</td>
</tr>
<tr>
<td>list</td>
<td>双向</td>
</tr>
<tr>
<td>set/multiset</td>
<td>双向</td>
</tr>
<tr>
<td>map/multimap</td>
<td>双向</td>
</tr>
<tr>
<td>forward_list</td>
<td>前向</td>
</tr>
<tr>
<td>unordered_set/unordered_multiset</td>
<td>前向</td>
</tr>
<tr>
<td>unordered_map/unordered_multimap</td>
<td>前向</td>
</tr>
<tr>
<td>stack</td>
<td>不支持</td>
</tr>
<tr>
<td>queue</td>
<td>不支持</td>
</tr>
</tbody></table>
<p><strong>迭代器的定义方式</strong></p>
<table>
<thead>
<tr>
<th>迭代器类型</th>
<th>具体格式</th>
</tr>
</thead>
<tbody><tr>
<td>正向迭代器</td>
<td>容器类名::iterator  迭代器名</td>
</tr>
<tr>
<td>常量正向迭代器</td>
<td>容器类名::const_iterator  迭代器名;</td>
</tr>
<tr>
<td>反向迭代器</td>
<td>容器类名::reverse_iterator  迭代器名</td>
</tr>
<tr>
<td>常量反向迭代器</td>
<td>容器类名::const_reverse_iterator  迭代器名</td>
</tr>
</tbody></table>
<h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 4&gt; myarray&#123;&#125;;</span><br><span class="line">    <span class="comment">//初始化 myarray 容器为 &#123;0,1,2,3&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myarray.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        myarray.<span class="built_in">at</span>(i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用 get() 重载函数输出指定位置元素</span></span><br><span class="line">    cout &lt;&lt; get&lt;<span class="number">3</span>&gt;(myarray) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myarray[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正向迭代器</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 4&gt;::iterator it;</span><br><span class="line">    <span class="keyword">if</span> (!myarray.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = myarray.<span class="built_in">begin</span>(); it &lt;= myarray.<span class="built_in">end</span>() - <span class="number">1</span>; it++)</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//反向迭代器</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 4&gt;::reverse_iterator it_r;</span><br><span class="line">    <span class="keyword">if</span> (!myarray.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it_r = myarray.<span class="built_in">rend</span>() - <span class="number">1</span>; it_r &gt;= myarray.<span class="built_in">rbegin</span>(); it_r--)</span><br><span class="line">            cout &lt;&lt; *it_r &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机访问</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; myarray[index] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; myarray[index + <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</span></span><br><span class="line">    cout &lt;&lt; myarray.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</span></span><br><span class="line">    cout &lt;&lt; myarray.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。</span></span><br><span class="line">    <span class="keyword">int</span> *p = myarray.<span class="built_in">data</span>();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将值赋值给容器中的每个元素。</span></span><br><span class="line">    myarray.<span class="built_in">fill</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span> (!myarray.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = myarray.<span class="built_in">begin</span>(); it &lt;= myarray.<span class="built_in">end</span>() - <span class="number">1</span>; it++)</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 10&gt; array1;</span><br><span class="line">    array1.<span class="built_in">fill</span>(<span class="number">1</span>);</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 10&gt; array2;</span><br><span class="line">    array2.<span class="built_in">fill</span>(<span class="number">2</span>);</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 10&gt;::iterator it_10;</span><br><span class="line">    <span class="keyword">if</span> (!array1.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it_10 = array1.<span class="built_in">begin</span>(); it_10 &lt;= array1.<span class="built_in">end</span>() - <span class="number">1</span>; it_10++)</span><br><span class="line">            cout &lt;&lt; *it_10 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!array2.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it_10 = array2.<span class="built_in">begin</span>(); it_10 &lt;= array2.<span class="built_in">end</span>() - <span class="number">1</span>; it_10++)</span><br><span class="line">            cout &lt;&lt; *it_10 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    array1.<span class="built_in">swap</span>(array2);</span><br><span class="line">    <span class="keyword">if</span> (!array1.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it_10 = array1.<span class="built_in">begin</span>(); it_10 &lt;= array1.<span class="built_in">end</span>() - <span class="number">1</span>; it_10++)</span><br><span class="line">            cout &lt;&lt; *it_10 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!array2.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it_10 = array2.<span class="built_in">begin</span>(); it_10 &lt;= array2.<span class="built_in">end</span>() - <span class="number">1</span>; it_10++)</span><br><span class="line">            cout &lt;&lt; *it_10 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>vector 容器是 STL 中最常用的容器之一，它和 array 容器非常类似，都可以看做是对 C++ 普通数组的“升级版”。不同之处在于，array 实现的是静态数组（容量固定的数组），而 vector 实现的是一个动态数组，即可以进行元素的插入和删除，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。vector 常被称为向量容器，因为该容器擅长在尾部插入或删除元素，在常量时间内就可以完成，时间复杂度为O(1)；而对于在容器头部或者中部插入或删除元素，则花费时间要长一些（移动元素需要耗费时间），时间复杂度为线性阶O(n)。</p>
<p>还需注意的是，如果调用 reserve() 来增加容器容量，之前创建好的任何迭代器（例如开始迭代器和结束迭代器）都可能会失效，这是因为，为了增加容器的容量，vector<T> 容器的元素可能已经被复制或移到了新的内存地址。所以后续再使用这些迭代器时，最好重新生成一下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">double</span>&gt; v0&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br><span class="line">    <span class="comment">//获取当前容量</span></span><br><span class="line">    cout &lt;&lt; v0.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//申请100个元素空间，增加容器的容量。</span></span><br><span class="line">    <span class="comment">//如果vector的容量在执行此语句之前，已经大于或等于100个元素，那么这条语句什么也不做；</span></span><br><span class="line">    v0.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; v0.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//减少内存到当前元素实际使用的的大小</span></span><br><span class="line">    v0.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    cout &lt;&lt; v0.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//实际使用元素个数</span></span><br><span class="line">    cout &lt;&lt; v0.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    vector&lt;<span class="keyword">double</span>&gt;::iterator it1;</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//反向迭代器在array中示范过，不再赘述。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定元素个数，其默认值都为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v1.<span class="built_in">begin</span>(); it1 &lt;= v1.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//指定默认值为10</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">100</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v2.<span class="built_in">begin</span>(); it1 &lt;= v2.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用已经存在的vector创建新的vector</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">v3</span><span class="params">(v2)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v3.<span class="built_in">begin</span>(); it1 &lt;= v3.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//也可以只取一部分</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">v4</span><span class="params">(v2.data(), v2.data() + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v4.<span class="built_in">begin</span>(); it1 &lt;= v4.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用下标访问</span></span><br><span class="line">    cout &lt;&lt; v0[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; v0.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回第一个元素的引用</span></span><br><span class="line">    cout &lt;&lt; v0.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//返回最后一个元素的引用</span></span><br><span class="line">    cout &lt;&lt; v0.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换原有的元素</span></span><br><span class="line">    v0.<span class="built_in">assign</span>(v1.<span class="built_in">data</span>(), v1.<span class="built_in">data</span>() + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在尾部插入元素</span></span><br><span class="line">    v0.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//从尾部移除元素</span></span><br><span class="line">    v0.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在指定位置插入一个或者多个元素</span></span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//在指定位置插入元素，返回指向该元素的迭代器</span></span><br><span class="line">    cout &lt;&lt; *it1 &lt;&lt; endl;</span><br><span class="line">    it1 = v0.<span class="built_in">insert</span>(it1, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; *it1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//在指定位置前插入多个元素 插入两个4</span></span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    v0.<span class="built_in">insert</span>(it1, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//在指定为之前插入指定元素，同assign</span></span><br><span class="line">    <span class="comment">//事实证明，是先将源内存区域的数据复制下来再插入进入。</span></span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    v0.<span class="built_in">insert</span>(it1, v0.<span class="built_in">data</span>(), v0.<span class="built_in">data</span>() + <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定的元素</span></span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    v0.<span class="built_in">erase</span>(it1);</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//依次删除所有元素 注意这里，删除迭代器指向的元素之后，后面的元素会自动前移，所以不需要更新迭代器。</span></span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (it1 != v0.<span class="built_in">end</span>())</span><br><span class="line">        v0.<span class="built_in">erase</span>(it1);</span><br><span class="line">    <span class="keyword">if</span> (v0.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;空了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//删除指定区间的元素 前闭后开</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        v0.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    v0.<span class="built_in">erase</span>(it1, it1 + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理元素 元素没有了，但是容量还在 事实证明擦除的内存被写入了-4.8367e-26</span></span><br><span class="line">    <span class="keyword">int</span> re_size = v0.<span class="built_in">size</span>();</span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= re_size; i++)</span><br><span class="line">        cout &lt;&lt; *(it1 + i) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; v0.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; v0.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    v0.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; v0.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; v0.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (v0.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;空了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    v0.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= re_size; i++)</span><br><span class="line">        cout &lt;&lt; *(it1 + i) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换元素</span></span><br><span class="line">    v0.<span class="built_in">clear</span>();</span><br><span class="line">    v1.<span class="built_in">clear</span>();</span><br><span class="line">    v0.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    it1 = v1.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!v1.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v1.<span class="built_in">begin</span>(); it1 &lt;= v1.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    v0.<span class="built_in">swap</span>(v1);</span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    it1 = v1.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!v1.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v1.<span class="built_in">begin</span>(); it1 &lt;= v1.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再指定位置直接生成一个元素 emplace 一次只可以插入一个元素，效率比insert高</span></span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    v0.<span class="built_in">emplace</span>(it1, <span class="number">2</span>);</span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//相当于 push_back</span></span><br><span class="line">    v0.<span class="built_in">emplace_back</span>(<span class="number">3</span>);</span><br><span class="line">    it1 = v0.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!v0.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it1 = v0.<span class="built_in">begin</span>(); it1 &lt;= v0.<span class="built_in">end</span>() - <span class="number">1</span>; it1++)</span><br><span class="line">            cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="deque-双队列容器"><a href="#deque-双队列容器" class="headerlink" title="deque 双队列容器"></a>deque 双队列容器</h4><p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数，同时删除了 capacity()、reserve() 和 data() 成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; dq&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    it = dq.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!dq.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = dq.<span class="built_in">begin</span>(); it &lt;= dq.<span class="built_in">end</span>() - <span class="number">1</span>; it++)</span><br><span class="line">            cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//相vector额外怎增加了从头删除与加入元素的额方法。</span></span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    it = dq.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!dq.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = dq.<span class="built_in">begin</span>(); it &lt;= dq.<span class="built_in">end</span>() - <span class="number">1</span>; it++)</span><br><span class="line">            cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">    it = dq.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!dq.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = dq.<span class="built_in">begin</span>(); it &lt;= dq.<span class="built_in">end</span>() - <span class="number">1</span>; it++)</span><br><span class="line">            cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="list-双链表容器"><a href="#list-双链表容器" class="headerlink" title="list 双链表容器"></a>list 双链表容器</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">demo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt;= b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    it = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!l.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//好多和vector重复的函数就不再赘述。</span></span><br><span class="line">    <span class="comment">//由于是双向链表，故前后都可以插入删除，和deque一样。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除所有指定大小的元素</span></span><br><span class="line">    l.<span class="built_in">remove</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (l.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;你把0都删除了，我空了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">l2</span><span class="params">(<span class="number">5</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个 list 容器中的元素插入到另一个容器的指定位置。</span></span><br><span class="line">    <span class="comment">//当begin==end 时，为空，所以下面也可以换成 l.end()</span></span><br><span class="line">    l.<span class="built_in">splice</span>(l.<span class="built_in">begin</span>(), l2);</span><br><span class="line">    it = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!l.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    l = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    it = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!l.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//删除容器中相邻的重复元素，只保留一个。 可见只比较相邻的，若要实现真正的unique需要结合sort()进行排序</span></span><br><span class="line">    l.<span class="built_in">unique</span>();</span><br><span class="line">    it = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!l.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用一个二元谓语函数作为参数删除 此函数的作用是自定义前后两个元素的关系。</span></span><br><span class="line">    <span class="comment">//此例时若前一个元素值比后一个小则删除掉前一个</span></span><br><span class="line">    l.<span class="built_in">unique</span>(demo);</span><br><span class="line">    it = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!l.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    l.<span class="built_in">sort</span>();</span><br><span class="line">    l.<span class="built_in">unique</span>();</span><br><span class="line">    it = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!l.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。 事实证明合并前的list必须都排好序。</span></span><br><span class="line">    l2 = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">31</span>, <span class="number">54</span>, <span class="number">234</span>, <span class="number">2</span>, <span class="number">523</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    l.<span class="built_in">merge</span>(l2);</span><br><span class="line">    it = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!l.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    l.<span class="built_in">sort</span>();</span><br><span class="line">    l2.<span class="built_in">sort</span>();</span><br><span class="line">    l.<span class="built_in">merge</span>(l2);</span><br><span class="line">    l.<span class="built_in">unique</span>();</span><br><span class="line">    it = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!l.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转容器内元素的顺序</span></span><br><span class="line">    l.<span class="built_in">reverse</span>();</span><br><span class="line">    it = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!l.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件删除 remove_if</span></span><br><span class="line">    <span class="comment">//现在我对泛型不太了解，明日有精力了再写。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h4><p>其实就是单链表，相比于双向链表list,forward_list 更加有效率，但是不能进行逆向遍历的操作。当一个操作list与forward_list都可以做的时候，应该优先选用forward_list.</p>
<h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><p>关联式容器再存储元素的时候还会给每一个元素配备一个键，整体以键值相配对的方式进行存储，可以通过键值直接索引到元素无需遍历整个容器，再存储元素的时候会默认按照各个元素的大小做升序排列。关联式容器在更删改查的效率更高。关联式容器在底层使用红黑树进行实现。</p>
<p>关联式容器包括：    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map</span><br><span class="line">multimap</span><br><span class="line">set</span><br><span class="line">multiset</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>容器</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>map</td>
<td>元素的键是唯一的，根据各元素键的大小进行升序排序</td>
</tr>
<tr>
<td>set</td>
<td>元素的键是唯一的,根据各元素键的大小进行升序排序</td>
</tr>
<tr>
<td>multimap</td>
<td>和map的区别在于键可以重复</td>
</tr>
<tr>
<td>multiset</td>
<td>和set的区别在于键可以重复</td>
</tr>
</tbody></table>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map容器存储的都是pair对象。</p>
<p><strong>pair&lt;const K, T&gt;</strong></p>
<p>键是不可以修改的。值是可以修改的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//声明</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mymap&#123;&#123;<span class="number">3</span>, <span class="string">&quot;三&quot;</span>&#125;, &#123;<span class="number">4</span>, <span class="string">&quot;四&quot;</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//插入元素 可以像数组一样进行 [] 运算</span></span><br><span class="line">    mymap[<span class="number">1</span>] = <span class="string">&quot;一&quot;</span>;</span><br><span class="line">    mymap[<span class="number">2</span>] = <span class="string">&quot;二&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator it;</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!mymap.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//试着插入一个重复的键值 事实证明重复插入就取代了之前的</span></span><br><span class="line">    mymap[<span class="number">1</span>] = <span class="string">&quot;新一&quot;</span>;</span><br><span class="line">    it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!mymap.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面介绍相比与vector特有的成员函数。</span></span><br><span class="line">    <span class="comment">//根据键查找元素，返回一个指向结果元素的迭代器。</span></span><br><span class="line">    it = mymap.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器.</span></span><br><span class="line">    it = mymap.<span class="built_in">lower_bound</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器</span></span><br><span class="line">    it = mymap.<span class="built_in">upper_bound</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//返回一个范围 两个it组成的一个pair,该范围中包含的键为 key 的键值对.</span></span><br><span class="line">    <span class="comment">//因为map中元素的唯一性，所以该范围最多包含一个键值对。前闭后开。</span></span><br><span class="line">    pair&lt;map&lt;<span class="keyword">int</span>, string&gt;::iterator, map&lt;<span class="keyword">int</span>, string&gt;::iterator&gt; pair;</span><br><span class="line">    pair = mymap.<span class="built_in">equal_range</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;范围low: &quot;</span> &lt;&lt; pair.first-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair.first-&gt;second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;范围high: &quot;</span> &lt;&lt; pair.second-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair.second-&gt;second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以像数组一样进行 [] 运算 若不存在的话就插入一个key,其value为空。</span></span><br><span class="line">    cout &lt;&lt; mymap[<span class="number">8</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; mymap[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//at找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。</span></span><br><span class="line">    cout &lt;&lt; mymap.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!mymap.<span class="built_in">at</span>(<span class="number">8</span>).<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; mymap.<span class="built_in">at</span>(<span class="number">8</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//else cout&lt;&lt;&quot;该key没有对应&quot;&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入 若插入的元素已经存在的话则会插入失败，所以需要删除在插入或者修改。</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(&#123;<span class="number">5</span>, <span class="string">&quot;五&quot;</span>&#125;);</span><br><span class="line">    mymap.<span class="built_in">insert</span>(&#123;<span class="number">5</span>, <span class="string">&quot;肆虐五&quot;</span>&#125;);</span><br><span class="line">    it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!mymap.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    mymap.<span class="built_in">erase</span>(<span class="number">8</span>);</span><br><span class="line">    it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!mymap.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span> (it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); it++)</span><br><span class="line">            cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个容器的内容 swap() 不在赘述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计key出现的次数</span></span><br><span class="line">    cout &lt;&lt; mymap.<span class="built_in">count</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h4><p>multimap 比 map 除了可以拥有重复的额值之外，没有什么不同的。略过。</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。</p>
<p>其余和map没啥不同，set就是集合，所以也不可以重复。</p>
<h4 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h4><p>multiset 比 set 除了可以拥有重复的额值之外，没有什么不同的。略过。</p>
<h2 id="无序关联式容器"><a href="#无序关联式容器" class="headerlink" title="无序关联式容器"></a>无序关联式容器</h2><p>无序关联式容器，又称哈希容器。和关联式容器一样，此类容器存储的也是键值对元素；不同之处在于，关联式容器默认情况下会对存储的元素做升序排序，而无序关联式容器不会。和其它类容器相比，无序关联式容器擅长通过指定键查找对应的值，而遍历容器中存储元素的效率不如关联式容器。</p>
<p>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；<br>无序容器的底层实现采用的是哈希表的存储结构。</p>
<p>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，<br>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</p>
<p>包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。</p>
<h2 id="c-的常用算法"><a href="#c-的常用算法" class="headerlink" title="c++ 的常用算法"></a>c++ 的常用算法</h2>]]></content>
      <categories>
        <category>c++</category>
        <category>stl</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>leedcode 初级算法 字符串</title>
    <url>/2021/06/17/leedcode-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="leedcode-初级算法-字符串"><a href="#leedcode-初级算法-字符串" class="headerlink" title="leedcode 初级算法 字符串"></a>leedcode 初级算法 字符串</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2uudv/">链接</a></p>
<h4 id="反转字符转"><a href="#反转字符转" class="headerlink" title="反转字符转"></a>反转字符转</h4><h6 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h6><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<h6 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h6><p>懒得解析了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt; &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i++], s[j--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h4><h6 id="题目说明-1"><a href="#题目说明-1" class="headerlink" title="题目说明"></a>题目说明</h6><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p>
<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
<h6 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h6><p>将整数的每一位存在一个vector<int>中，倒序再存入一个数字中。或者就不用这样麻烦，直接从最后一位拿出来放在前面就行。</p>
<p>因为只能使用32位整数，所以需要使用下面的方法进行判断是否超界。</p>
<p>我们需要在「推入」数字之前，判断是否满足</p>
<p><strong>INT_MIN=&lt;ans*10+i&lt;=INT_MAX</strong></p>
<p><strong>INT_MAX=2^31-1=2147483647=[INT_MAX]/10*10+7</strong><br>所以可以变为<br><strong>ans*10+i&lt;=[INT_MAX]/10*10+7</strong><br>所以：<br><strong>[ans-[INT_MAX]/10]*10&lt;=7-i</strong><br>当</p>
<ol>
<li>ans&gt;[INT_MAX]/10 左边大于10，绝对大于右边。所以不行。</li>
<li>ans=[INT_MAX]/10 由于原数字符合条件，所以其最高位=1或者2，即7-i&gt;0 左边为零，满足。</li>
<li>ans&lt;[INT_MAX]/10 显然满足</li>
</ol>
<p>综上只需判断<br><strong>ans&lt;=[INT_MAX]/10**即可<br>对于负数同理存在<br>**ans&gt;=[INT_MIN]/10</strong><br>所以判别条件可变为<br><strong>[INT_MIN]&lt;=ans&lt;=[INT_MAX]/10</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">int</span> a = x;</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(a % <span class="number">10</span>);</span><br><span class="line">            a /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &lt; INT32_MIN / <span class="number">10</span> || ans &gt; INT32_MAX)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ans *= <span class="number">10</span>;</span><br><span class="line">            ans += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; INT32_MAX)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="字符串中的第一个唯一字符"><a href="#字符串中的第一个唯一字符" class="headerlink" title="字符串中的第一个唯一字符"></a>字符串中的第一个唯一字符</h4><h6 id="题目说明-2"><a href="#题目说明-2" class="headerlink" title="题目说明"></a>题目说明</h6><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<h6 id="题目解析-方法一"><a href="#题目解析-方法一" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>依次存入unordered_multimap&lt;char,int&gt; 第一个是字符，第二个是索引.遍历字符串，设当前字符为，c，则count(c)==1?，相等则返回直至最后没有相等的返回-1；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_multimap&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=s.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map.<span class="built_in">insert</span>(&#123;s[i],i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">if</span> (map.<span class="built_in">count</span>(s[i]) == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二"><a href="#题目解析-方法二" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>或者放入unordered_map&lt;char,int&gt;  第一个是字符，第二个是该字符出现的次数。全部插入后，遍历string,寻找map[s[i]]==1;并返回i;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//字符，出现的次数</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//若不存在的话默认为零</span></span><br><span class="line">            map[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[s[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h6 id="题目解析-方法三"><a href="#题目解析-方法三" class="headerlink" title="题目解析 方法三"></a>题目解析 方法三</h6><p>依次存入unordered_map&lt;char,int&gt; 第一个是字符，第二个是索引.遍历字符串插入，若存在则索引变为-1。遍历map,寻找索引不为-1的最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//字符，索引值</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            it = map.<span class="built_in">find</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (it == map.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                map.<span class="built_in">insert</span>(&#123;s[i], i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                map[s[i]] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">int</span> min = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;second &lt; min)</span><br><span class="line">                    min = it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法四"><a href="#题目解析-方法四" class="headerlink" title="题目解析 方法四"></a>题目解析 方法四</h6><p>unordered_map&lt;char,int&gt; map;    //字符和索引值<br>deque&lt;pair&lt;char,int&gt;&gt; dq;       //字符和索引值</p>
<p>使用一个额外的队列来查找最前面的为一个那个字符。遍历字符串，若当前字符再map中未出现的话，就插入map并且从后面插入队列。反之，则令该key在map中的值为-1，将队列中从头开始的所有字符在map对应的value==-1的元素全部弹出。则遍历完字符串之后剩下的队列的front就是所求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        deque&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; dq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">if</span> (map.<span class="built_in">count</span>(s[i]) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                map[s[i]] = i;</span><br><span class="line">                dq.<span class="built_in">push_back</span>(&#123;s[i], i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                map[s[i]] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; map[dq.<span class="built_in">front</span>().first] == <span class="number">-1</span>)</span><br><span class="line">                    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dq.<span class="built_in">empty</span>() ? <span class="number">-1</span> : dq.<span class="built_in">front</span>().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h4><h6 id="题目说明-3"><a href="#题目说明-3" class="headerlink" title="题目说明"></a>题目说明</h6><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。（两个字符串排序后相等）</p>
<h6 id="题目解析-方法一-1"><a href="#题目解析-方法一-1" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>先判断两个字符串的长度是否相等，若不想等则返回false,使用两个哈希表&lt;char,int&gt;存储字符和出现的次数，在遍历一个哈希表，查找其对应的字符在两个哈希表中出现的次数是否一样？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map1;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map2;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map1[s[i]]++;</span><br><span class="line">            map2[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (it = map1.<span class="built_in">begin</span>(); it != map1.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second != map2[it-&gt;first])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这么简单的问题使用哈希表就有些小题大做了，直接使用一个数组 vector<int> v(26,0),即可，如下：         </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s)</span><br><span class="line">            v[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t)</span><br><span class="line">            <span class="keyword">if</span> (--v[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二-1"><a href="#题目解析-方法二-1" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>对两个字符串排序之后判断是否相等即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> (s == t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h4><h6 id="题目说明-4"><a href="#题目说明-4" class="headerlink" title="题目说明"></a>题目说明</h6><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<h6 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h6><p>先将串中的无关字符舍去并处理相关字符，再使用双指针从前后遍历判断即可。</p>
<p>直接使用双指针在遍历的时候处理也行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        vector&lt;<span class="keyword">char</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &lt;= <span class="string">&#x27;Z&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                v.<span class="built_in">push_back</span>(c + <span class="number">32</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= <span class="string">&#x27;z&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                v.<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                v.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">            <span class="keyword">if</span> (v[i++] != v[j--])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a>字符串转换整数 (atoi)</h4><h6 id="题目说明-5"><a href="#题目说明-5" class="headerlink" title="题目说明"></a>题目说明</h6><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p>
<p>函数 myAtoi(string s) 的算法如下：</p>
<p>读入字符串并丢弃无用的前导空格<br>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。<br>返回整数作为最终结果。<br>注意：</p>
<p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</p>
<h6 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">读入字符串并丢弃无用的前导空格</span></span><br><span class="line"><span class="comment">检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</span></span><br><span class="line"><span class="comment">读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</span></span><br><span class="line"><span class="comment">将前面步骤读入的这些数字转换为整数（即，&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</span></span><br><span class="line"><span class="comment">如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。</span></span><br><span class="line"><span class="comment">返回整数作为最终结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>;     <span class="comment">//正数</span></span><br><span class="line">        <span class="keyword">bool</span> finish_0 = <span class="number">0</span>; <span class="comment">//前导0是否已经处理完</span></span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[++a] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">//a指向第一个不是空格的地方</span></span><br><span class="line">        <span class="keyword">if</span> (s[a] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[a] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//a指向符号位后一位，若没有符号位则指向第一个可能是数字的那一位。</span></span><br><span class="line">        <span class="keyword">int</span> b = a;</span><br><span class="line">        <span class="keyword">for</span> (b = a; b &lt;= s.<span class="built_in">size</span>() - <span class="number">1</span>; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[b];</span><br><span class="line">            <span class="keyword">if</span> (c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b--;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//b指向最后一个数字。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt;= b; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ans = ans * <span class="number">10</span> + digit;</span><br><span class="line">            cout &lt;&lt; digit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; INT32_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = INT32_MAX;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//负数</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = -ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; INT32_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = INT32_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; INT32_MIN)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = INT32_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h4><h6 id="题目说明-6"><a href="#题目说明-6" class="headerlink" title="题目说明"></a>题目说明</h6><p>实现 strStr() 函数。</p>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p>
<h6 id="题目解析-方法一-2"><a href="#题目解析-方法一-2" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>暴力判断即可，不过还是要节省一点时间的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">//mississippi sipp</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">if</span> (m - i &lt; n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i] != needle[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (haystack[i + n - <span class="number">1</span>] != needle[n - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m - i &lt; n)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> a = i; <span class="comment">//m</span></span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>; <span class="comment">//n</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (b == n)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                <span class="keyword">if</span> (haystack[a++] != needle[b++])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没找到</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二-2"><a href="#题目解析-方法二-2" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p><strong>KMP</strong></p>
<p>kmp算法的简单介绍：<br>两个字符串s1,s2,指针t1,t2分别指向两个字符串中的字符。现在要从s1中寻找s2出现的最早的一次，没有出现的话就返回-1.          </p>
<p>普通暴力算法是一个字符一个字符的去匹配，匹配失败了就从头开始并后移一位。<br>kmp的思想是可不可以在匹配失败之后向后多移动几位呢？<br>假设在第n位匹配失败，即s1[n]!=s2[n]则t2前移几位，前移的程度要最大，即移动过后t2之前的字符仍然要保持匹配，再比较t2当前和t1是否对应字符相等即可，重复t2==0仍然匹配失败的话说明此处t1指向的字符是不可能正确的，必须略过，所以t1++，之后又开始了新一轮的比较。知道最后匹配成功则返回 t1-s2.size(),失败的条件不在赘述。<br>前面提到了需要再字符匹配失败之后t2向前移动，但是需要移动几位合适呢？现在t2前面a个字符都是匹配成功的，现在看这a个字符组成字符串a，如果a存在两个<strong>真子串</strong>相等的话(设为a1,a2)，显然a2已经是匹配成功的了，如果此时将a1移动到a2所在的地方那么自然也是匹配成功的了，所以上面提到的将t2前移几位的程度也呼之欲出，即t2要指向子串a1紧紧后面的那一位，这样就最大程度的利用了已知的信息。而这里提到的a1,a2就是a的最长相等真前缀和真后缀，所以问题的重点有落在了怎样求出s2的最长真前缀的长度呢？？？<br>我们用数组 <strong>kmp&lt;int&gt;</strong> 来表示s2每一位对应的最长真前缀的长度。怎么求呢？<br>明显kmp[0]=0,因为只有一个字符并没有真前缀和真后缀。我们这里使用两个指针now和x分别指向a1,a2要进行匹配的字符。<br>如果s2[x]==s2[now]则显然可以匹配的字符数量要加1，即kmp[x]==kmp[x-1]+1;<br>如果不相等的话，就需要查看前面的就要像上面s2和s1进行你匹配是那样指针前移，这里又要移动几位呢？和上面的分析一样，显然kmp[now-1]个字符已经匹配成功，所以需要将**now=kmp[now-1]**在进行s2[x]==s2[now]是否相等的比较了，不成立的话再进行now=kmp[now-1];若now==0,则判断s2[0]==s2[x]，不等的话说明连开头和结尾的字符都不想等，则显然kmp[x]=0;好了，算出了kmp[x]，x++,进行下一论循环即可。<br>哈哈哈，终于写明白了。          </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (haystack.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">string <span class="title">s1</span><span class="params">(haystack)</span></span>;</span><br><span class="line">        <span class="function">string <span class="title">s2</span><span class="params">(needle)</span></span>;</span><br><span class="line">        cout &lt;&lt; s1 &lt;&lt; endl</span><br><span class="line">             &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//kmp:</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">kmp</span><span class="params">(s2.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        kmp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s2.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2[kmp[i - <span class="number">1</span>]] == s2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                kmp[i] = kmp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">int</span> now = kmp[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//aabaaac</span></span><br><span class="line">                    cout &lt;&lt; now &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">if</span> (s2[now] == s2[x])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (now &gt;= <span class="number">1</span>)</span><br><span class="line">                        now = kmp[now - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (now &lt;= <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        now = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (s2[<span class="number">0</span>] == s2[x])</span><br><span class="line">                            now = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                kmp[i] = now + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : kmp)</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//匹配</span></span><br><span class="line">        <span class="keyword">int</span> t1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;t1: &quot;</span> &lt;&lt; t1 &lt;&lt; <span class="string">&quot; t2: &quot;</span> &lt;&lt; t2 &lt;&lt; endl;</span><br><span class="line">            <span class="comment">//成功</span></span><br><span class="line">            <span class="keyword">if</span> (t2 == s2.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> t1 - s2.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//失败</span></span><br><span class="line">            <span class="keyword">if</span> (t1 == s1.<span class="built_in">size</span>() &amp;&amp; t2 != s2.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//匹配该字符失败</span></span><br><span class="line">            <span class="keyword">if</span> (s1[t1] != s2[t2])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (t2 != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    t2 = kmp[t2 - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    t1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//匹配该字符成功</span></span><br><span class="line">            &#123;</span><br><span class="line">                t1++;</span><br><span class="line">                t2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法三-1"><a href="#题目解析-方法三-1" class="headerlink" title="题目解析 方法三"></a>题目解析 方法三</h6><p>还有一个基于kmp算法的改进版。我们将两个字符串拼接起来为s，并使用一个两串中都不存在的字符’#’作为分隔符（如 s1=”aaa” s2=”aa” 的情况，如果中间没有#的话就不行，因为这种情况无论如何算kmp的时候都会算上两个子串的公共部分）。s=s2+’#’+s1; 别加反了。。。<br>遍历s,根据上面的算法求解s的kmp数组，若kmp[n]==s2.size()且n&gt;=2*s2.size(),这样保证是s1的子串和s2匹配，而不是s2的或者s1和s2中间共有的。结果返回i - 2 * s2.size()即可。        </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (haystack.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">string <span class="title">s1</span><span class="params">(haystack)</span></span>;</span><br><span class="line">        <span class="function">string <span class="title">s2</span><span class="params">(needle)</span></span>;</span><br><span class="line">        string s = s2 + <span class="string">&quot;#&quot;</span> + s1;</span><br><span class="line">        cout &lt;&lt; s1 &lt;&lt; endl</span><br><span class="line">             &lt;&lt; s2 &lt;&lt; endl</span><br><span class="line">             &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//kmp:</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">kmp</span><span class="params">(s.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        kmp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[kmp[i - <span class="number">1</span>]] == s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                kmp[i] = kmp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">int</span> now = kmp[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//aabaaac</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; now &lt;&lt;&quot; &quot;&lt;&lt; x &lt;&lt;s[now]&lt;&lt;&quot; &quot;&lt;&lt;s[x]&lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">if</span> (s[now] == s[x])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (now &gt;= <span class="number">1</span>)</span><br><span class="line">                        now = kmp[now - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (now &lt;= <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        now = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (s[<span class="number">0</span>] == s[x])</span><br><span class="line">                            now = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                kmp[i] = now + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (kmp[i] == s2.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;&quot;相等&quot;&lt;&lt;kmp[i]&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">2</span> * s2.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;&quot;匹配&quot;&lt;&lt;kmp[i]&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">                    <span class="keyword">return</span> (i - <span class="number">2</span> * s2.<span class="built_in">size</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h4><h6 id="题目说明-7"><a href="#题目说明-7" class="headerlink" title="题目说明"></a>题目说明</h6><p> 给定一个正整数 n ，输出外观数列的第 n 项。</p>
<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p>
<p>你可以将其视作是由递归公式定义的数字字符串序列：</p>
<p>countAndSay(1) = “1”<br>countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。</p>
<ol>
<li><pre><code>1
</code></pre>
</li>
<li><pre><code>11
</code></pre>
</li>
<li><pre><code>21
</code></pre>
</li>
<li><pre><code>1211
</code></pre>
</li>
<li><pre><code>111221
</code></pre>
第一项是数字 1<br>描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 “11”<br>描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 “21”<br>描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 “1211”<br>描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 “111221”        </li>
</ol>
<h6 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h6><p>很好理解题意，就是遍历并且判断数量即可。<br>使用一个数组vector&lt;vector<int>&gt; v来保存结果。       </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        v[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//每一轮循环pushback进去一个temp来申请内存空间。v[i]</span></span><br><span class="line">            v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="comment">//遍历v[i-1] 并得到结果</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= v[i - <span class="number">1</span>].<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> num = v[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">int</span> k = j;</span><br><span class="line">                <span class="keyword">while</span> (k &lt;= v[i - <span class="number">1</span>].<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v[i - <span class="number">1</span>][k] == num)</span><br><span class="line">                    &#123;</span><br><span class="line">                        k++;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j = k;</span><br><span class="line">                v[i].<span class="built_in">push_back</span>(count);</span><br><span class="line">                v[i].<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= v[i].<span class="built_in">size</span>() - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> c = v[i][j] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; s&lt;&lt;endl;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h4><h6 id="题目说明-8"><a href="#题目说明-8" class="headerlink" title="题目说明"></a>题目说明</h6><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<h6 id="题目解析-方法一-3"><a href="#题目解析-方法一-3" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>纵向扫描，若不符合条件则退出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt; &amp;strs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> min = INT32_MAX; <span class="comment">//记录最短的长度</span></span><br><span class="line">        <span class="keyword">int</span> strnum = strs.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt;::iterator it;</span><br><span class="line">        <span class="comment">//就一个串 或者没有串</span></span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//判断是否存在空字符串</span></span><br><span class="line">        <span class="keyword">for</span> (it = strs.<span class="built_in">begin</span>(); it != strs.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            min = (min &lt; it-&gt;<span class="built_in">size</span>()) ? min : it-&gt;<span class="built_in">size</span>();</span><br><span class="line">            cout &lt;&lt; min &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;至少两个字符串，而且没有空串&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt;= min - <span class="number">1</span>; index++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记录当前要比较的字符</span></span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>][index];</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//不存在不相等的。</span></span><br><span class="line">            <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt;= strnum - <span class="number">1</span>; v++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[v][index] != c)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前字符串通过考核</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//未通过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二-3"><a href="#题目解析-方法二-3" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>横向扫描，遍历字符串数组，得到相邻字符串的公共前缀，在用这个公共前缀与下一个字符串进行比较。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt; &amp;strs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string s = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> strnum = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= strnum - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s = <span class="built_in">CommonPrefix</span>(s, strs[i]);</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">CommonPrefix</span><span class="params">(string &amp;s1, string &amp;s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> len = (s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>()) ? s2.<span class="built_in">size</span>() : s1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[i])</span><br><span class="line">                s.<span class="built_in">push_back</span>(s1[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法三-2"><a href="#题目解析-方法三-2" class="headerlink" title="题目解析 方法三"></a>题目解析 方法三</h6><p>分治</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt; &amp;strs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        s = <span class="built_in">Prefix</span>(strs, <span class="number">0</span>, strs.<span class="built_in">size</span>()); <span class="comment">//前闭后开</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">Prefix</span><span class="params">(vector&lt;string&gt; strs, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//就一个字符串</span></span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> strs[begin];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (end - begin == <span class="number">2</span>) <span class="comment">//正好两个串</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">CommonPrefix</span>(strs[begin], strs[begin + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">CommonPrefix</span>(<span class="built_in">Prefix</span>(strs, begin, mid), <span class="built_in">Prefix</span>(strs, mid, end));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">CommonPrefix</span><span class="params">(string s1, string s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> len = (s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>()) ? s2.<span class="built_in">size</span>() : s1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[i])</span><br><span class="line">                s.<span class="built_in">push_back</span>(s1[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
        <category>leedcode</category>
      </categories>
      <tags>
        <tag>leedcode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leedcode 初级算法 数组</title>
    <url>/2021/06/13/leedcode-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="leedcode-初级算法-数组"><a href="#leedcode-初级算法-数组" class="headerlink" title="leedcode 初级算法 数组"></a>leedcode 初级算法 数组</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2i30g/">链接</a></p>
<h4 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h4><h6 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h6><p>给你一个<strong>有序数组</strong>nums请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<h6 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h6><p>使用两个索引，i和j<br>i指向基元素<br>j指向比较元素<br>若两个元素不相等的话就说明中间与元素i相等的元素全部略过了，之后只要将元素j的值赋予元素i的下一个元素就行。<br>别忘了更新索引的值。<br>最后结果就是i的值加一。<br>本题不需要删除多余重复的额元素。<br>由0到i就是得到新的数组。            </p>
<h6 id="ac代码"><a href="#ac代码" class="headerlink" title="ac代码"></a>ac代码</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++i]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h4><h6 id="题目说明-1"><a href="#题目说明-1" class="headerlink" title="题目说明"></a>题目说明</h6><p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h6 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h6><p>贪心，就和骑自行车上坡一样，怎样最费力，就是抓住每一个上坡的机会去上坡。当然也可以倒着来就是从后往前抓住每一个可以下坡的机会进行下坡。</p>
<h6 id="ac代码-1"><a href="#ac代码-1" class="headerlink" title="ac代码"></a>ac代码</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=prices.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i<span class="number">-1</span>]&lt;prices[i])<span class="comment">//买入</span></span><br><span class="line">                count+=prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h4><h6 id="题目说明-2"><a href="#题目说明-2" class="headerlink" title="题目说明"></a>题目说明</h6><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<h6 id="题目解析-方法一"><a href="#题目解析-方法一" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>将k mod n 变为实际需要移动的次数，然后循环右移k次即可。<br>但是这样时间复杂度太高了。<br>代码：  </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int <span class="attribute">n</span>=nums.size();</span><br><span class="line">        <span class="attribute">k</span>=k%n;</span><br><span class="line">        <span class="keyword">if</span>(<span class="attribute">k</span>==0)</span><br><span class="line">            return;</span><br><span class="line">        int <span class="attribute">temp</span>=0;</span><br><span class="line">        <span class="keyword">for</span>(int <span class="attribute">i</span>=1;i&lt;=k;i++)//右移k个单位</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int <span class="attribute">j</span>=n-1;j&gt;=0;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="attribute">j</span>==n-1)</span><br><span class="line">                    <span class="attribute">temp</span>=nums[j];</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    nums[j+1]=nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[0]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二"><a href="#题目解析-方法二" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>和方法一类似都是移动元素，只不过这个是一步到位的移动，时间复杂度相比来讲小了不少，但是怎样保证不重复移动是一问题。设n与k的最大公约数为m，<br>则只移动前m个元素就不会重复移动了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        k=k%n;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//找到k与n的最大公约数m</span></span><br><span class="line">        <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(m=k;m&gt;=<span class="number">1</span>;m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k%m==<span class="number">0</span>&amp;&amp;n%m==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对于这些元素开头的元素序列进行轮换。</span></span><br><span class="line">            <span class="keyword">int</span> prev=i;</span><br><span class="line">            <span class="keyword">int</span> next=(prev+k)%n;</span><br><span class="line">            <span class="keyword">int</span> temp1=nums[i];</span><br><span class="line">            <span class="keyword">int</span> temp2=temp1;</span><br><span class="line">            <span class="keyword">do</span>&#123;            </span><br><span class="line">                temp2=nums[next];</span><br><span class="line">                nums[next]=temp1;</span><br><span class="line">                <span class="comment">//nums[prev]=temp1;</span></span><br><span class="line">                temp1=temp2;</span><br><span class="line">                prev=next;</span><br><span class="line">                next=(prev+k)%n;</span><br><span class="line">            &#125;<span class="keyword">while</span>(prev!=i);<span class="comment">//这轮元素又回到头了</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法三"><a href="#题目解析-方法三" class="headerlink" title="题目解析 方法三"></a>题目解析 方法三</h6><p>该方法基于如下的事实：当我们将数组的元素向右移动 kk 次后，尾部 k\bmod nkmodn 个元素会移动至数组头部，其余元素向后移动 k\bmod nkmodn 个位置。该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 k\bmod nkmodn 个元素就被移至数组头部，然后我们再翻转 [0, (k mod n) -1]区间的元素和 [(k mod n), n-1]区间的元素即能得到最后的答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        k=k%n;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">rotate1</span>(nums,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">rotate1</span>(nums,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">rotate1</span>(nums,k,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;=(begin+end)/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum=begin+end;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">            nums[i]=nums[sum-i];</span><br><span class="line">            nums[sum-i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h4><h6 id="题目说明-3"><a href="#题目说明-3" class="headerlink" title="题目说明"></a>题目说明</h6><p>给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<h6 id="题目解析-方法一-1"><a href="#题目解析-方法一-1" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>排序后遍历数组如果存在某一个数与其后面的数相等则说明重复的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二-1"><a href="#题目解析-方法二-1" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>使用哈希表一个一个寻找和插入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; s;  <span class="comment">//#include &lt;unordered_set&gt;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(x)!=s.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h4><h6 id="题目说明-4"><a href="#题目说明-4" class="headerlink" title="题目说明"></a>题目说明</h6><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<h6 id="题目解析-方法一-2"><a href="#题目解析-方法一-2" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>排序数组，遍历数组依次加减，所得就是答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                sum+=x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                sum-=x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二-2"><a href="#题目解析-方法二-2" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>遍历数组，使用集合存储数字，若由则删除，没有则存储。最后剩下的就是所要。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(x)!=s.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                s.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:s)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法三-1"><a href="#题目解析-方法三-1" class="headerlink" title="题目解析 方法三"></a>题目解析 方法三</h6><p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(x)!=s.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(x);</span><br><span class="line">                s.<span class="built_in">insert</span>(x,<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(x,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator x;</span><br><span class="line">        <span class="keyword">for</span>(x=s.<span class="built_in">begin</span>();x!=s.<span class="built_in">end</span>();x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x-&gt;second==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num=x-&gt;second;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法四"><a href="#题目解析-方法四" class="headerlink" title="题目解析 方法四"></a>题目解析 方法四</h6><p>异或运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;  <span class="comment">//任何数与0异或不表，与1异或取反</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)</span><br><span class="line">            ans^=x;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h4><h6 id="题目说明-5"><a href="#题目说明-5" class="headerlink" title="题目说明"></a>题目说明</h6><p>给定两个数组，编写一个函数来计算它们的交集。<br>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。<br>我们可以不考虑输出结果的顺序。</p>
<h6 id="题目解析-方法一-3"><a href="#题目解析-方法一-3" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>先对像个数组进行排序，之后遍历两个数组，找到相同的数则判断这个数再两个数组中出现的次数的最小值，再结果中插入该最小值次数的该数，两个数组都跳过同样的数，继续遍历。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=nums1.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=last;j&lt;=nums2.<span class="built_in">size</span>()<span class="number">-1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i]==nums2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//计算个数</span></span><br><span class="line">                    <span class="keyword">int</span> n1=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> n2=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> x=i;x&lt;=nums1.<span class="built_in">size</span>()<span class="number">-1</span>;x++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums1[x]==nums1[i])</span><br><span class="line">                            n1++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> x=j;x&lt;=nums2.<span class="built_in">size</span>()<span class="number">-1</span>;x++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums2[x]==nums2[j])</span><br><span class="line">                            n2++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(n1&gt;n2)</span><br><span class="line">                        n1=n2;</span><br><span class="line">                    <span class="keyword">else</span> n2=n1;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n1;x++)</span><br><span class="line">                        num.<span class="built_in">push_back</span>(nums1[i]);</span><br><span class="line"></span><br><span class="line">                    i+=n1<span class="number">-1</span>;</span><br><span class="line">                    last=j+n2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样实现有些繁琐，逻辑上也有点幼稚，其实想一想就是双指针。<br>从头遍历两个数组直至结尾，若相等则两个指针都向后移动一位，否则移动对应值较小的哪一个指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=nums1.<span class="built_in">size</span>()&amp;&amp;j!=nums2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]==nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                num.<span class="built_in">push_back</span>(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i]&lt;nums2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二-3"><a href="#题目解析-方法二-3" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>使用hash_map记录数据与其出现的次数,先将nums1数组中的数据全部存入到hashmap中，遍历nums2,并查找hashmap中的元素，若没有则舍去，若有，则看其value是否为零，不为零的话则value-1,并且将这个数加入结果数组中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums1, vector&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">empty</span>() || nums2.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator x;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() &lt; nums2.<span class="built_in">size</span>())</span><br><span class="line">            nums1.<span class="built_in">swap</span>(nums2);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        it = nums1.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (it = nums1.<span class="built_in">begin</span>(); it != nums1.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            x = map.<span class="built_in">find</span>(*it);</span><br><span class="line">            <span class="comment">//找到了</span></span><br><span class="line">            <span class="keyword">if</span> (x != map.<span class="built_in">end</span>())</span><br><span class="line">                count = x-&gt;second;</span><br><span class="line">            count++;</span><br><span class="line">            map.<span class="built_in">erase</span>(*it);</span><br><span class="line">            map.<span class="built_in">insert</span>(&#123;*it, count&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (it = nums2.<span class="built_in">begin</span>(); it != nums2.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            x = map.<span class="built_in">find</span>(*it);</span><br><span class="line">            <span class="keyword">if</span> (x != map.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (x-&gt;second != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    x-&gt;second--;</span><br><span class="line">                    num.<span class="built_in">push_back</span>(*it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="大数加一"><a href="#大数加一" class="headerlink" title="大数加一"></a>大数加一</h4><h6 id="题目说明-6"><a href="#题目说明-6" class="headerlink" title="题目说明"></a>题目说明</h6><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<h6 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h6><p>从后往前遍历判断是否进位即可，就是加法器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;digits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (it = digits.<span class="built_in">end</span>() - <span class="number">1</span>; it &gt;= digits.<span class="built_in">begin</span>(); it--)</span><br><span class="line">        &#123;</span><br><span class="line">            *it += carry;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (*it == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *it = <span class="number">0</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (it = digits.<span class="built_in">end</span>() - <span class="number">1</span>; it &gt;= digits.<span class="built_in">begin</span>() + <span class="number">1</span>; it--)</span><br><span class="line">            &#123;</span><br><span class="line">                *it = *(it - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            *it = <span class="number">1</span>;</span><br><span class="line">            digits.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h4><h6 id="题目说明-7"><a href="#题目说明-7" class="headerlink" title="题目说明"></a>题目说明</h6><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<h6 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h6><p>使用双指针i,j<br>i永远指向第一个零，j指向i后面第一个非零。交换ij对应元素的值，直到j超出数组范围。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//指向第一个等零的元素</span></span><br><span class="line">        j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == <span class="number">0</span>)</span><br><span class="line">                    j++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == nums.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            nums[i++] = nums[j];</span><br><span class="line">            nums[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样代码略显臃肿，可以简化为：<br>ij从0开始遍历直到j超限。若j对应元素不等零则则交换ij对应元素的值，i++;j++;<br>若等零，j++；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//交换位置，但是这里可能都不为零。</span></span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><h6 id="题目说明-8"><a href="#题目说明-8" class="headerlink" title="题目说明"></a>题目说明</h6><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<h6 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h6><p>按照&lt;index,nums[index]&gt;放进一个unordered_multimap中。遍历数组，对于每一个元素，遍历unordered_multimap，查找匹配元素。因为数组中可能存在两个相同的数恰好是解的情况所以要使用unordered_multimap，并且额外判断有两个相等的值的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sec = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将数组插入一个图里。</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        unordered_multimap&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        unordered_multimap&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        pair&lt;unordered_multimap&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator, unordered_multimap&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator&gt; pair;</span><br><span class="line">        <span class="comment">//放进去之前先查表，看是否由匹配的，这样不仅节省时间还避免出现nums=[3,3],target=6 这种情况造成多值无法检索。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有两个相等的值</span></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">count</span>(target / <span class="number">2</span>) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pair = map.<span class="built_in">equal_range</span>(target / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (it = pair.first; it != pair.second; it++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有两个相等的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            it = map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != map.<span class="built_in">end</span>() &amp;&amp; it-&gt;second != i)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这样很复杂，能不能不用判断是否存在两个相等的数的情况恰好是解的情况呢？而且全部插入之后再对数组进行遍历确实很冗余，所以可以一边插入一边寻找答案，这样即使是两数相等的情况也可以解决了，而且不需要使用unordered_multimap，使用unordered_map即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//将数组插入一个图里。</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        unordered_multimap&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        unordered_multimap&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="comment">//放进去之前先查表，看是否由匹配的，这样不仅节省时间还避免出现nums=[3,3],target=6 这种情况造成多值无法检索。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            it = map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != map.<span class="built_in">end</span>()) <span class="comment">//找到解了</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样就简单多了。</p>
<h4 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h4><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示</p>
<h6 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h6><p>使用unordered_map进行映射即可，映射之前判断是否满足条件即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; set;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt;::iterator it;</span><br><span class="line">        <span class="comment">//遍历每一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            set.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">8</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.<span class="built_in">find</span>(board[i][j]) == set.<span class="built_in">end</span>() || board[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    set.<span class="built_in">insert</span>(board[i][j]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            set.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">8</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.<span class="built_in">find</span>(board[j][i]) == set.<span class="built_in">end</span>() || board[j][i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    set.<span class="built_in">insert</span>(board[j][i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历每一个小正方形</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;= <span class="number">2</span>; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt;= <span class="number">2</span>; n++)</span><br><span class="line">            &#123;</span><br><span class="line">                set.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span> * m; i &lt;= <span class="number">3</span> * m + <span class="number">2</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span> * n; j &lt;= <span class="number">3</span> * n + <span class="number">2</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (set.<span class="built_in">find</span>(board[i][j]) == set.<span class="built_in">end</span>() || board[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                            set.<span class="built_in">insert</span>(board[i][j]);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h4><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<h4 id="题目解析-方法一-4"><a href="#题目解析-方法一-4" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h4><p>元素 i,j 顺时针旋转90°后变为 j,n-i-1<br>将矩阵分为 n/2圈 即可。<br>每一圈(第q圈，圈数从0开始)遍历圈内第一行的n-2q-1个元素，元素起始为 q,q</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        元素 i,j 顺时针旋转90°后变为 j,n-i-1            </span></span><br><span class="line"><span class="comment">        将矩阵分为 n/2圈 即可。     </span></span><br><span class="line"><span class="comment">        每一圈(第q圈，圈数从0开始)遍历圈内第一行的n-2q-1个元素，元素起始为 q,q</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt;= n / <span class="number">2</span> - <span class="number">1</span>; q++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">0</span>; time &lt;= n - <span class="number">2</span> * q - <span class="number">2</span>; time++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = q;</span><br><span class="line">                <span class="keyword">int</span> y = q + time;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[x][y];</span><br><span class="line">                <span class="keyword">int</span> next_x = y;</span><br><span class="line">                <span class="keyword">int</span> next_y = n - x - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//对每一个起始的元素进行四次循环</span></span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;&quot;x: &quot;&lt;&lt;x&lt;&lt;&quot; y &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;matrix[x][y]&lt;&lt;endl;</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; &quot;next_x: &quot; &lt;&lt; next_x &lt;&lt; &quot; next_y &quot; &lt;&lt; next_y &lt;&lt; &quot; &quot; &lt;&lt; matrix[next_x][next_y] &lt;&lt; endl;</span></span><br><span class="line">                    <span class="built_in">swap</span>(matrix[next_x][next_y], temp);</span><br><span class="line">                    x = next_x;</span><br><span class="line">                    y = next_y;</span><br><span class="line">                    next_x = y;</span><br><span class="line">                    next_y = n - x - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (x != q || y != q + time);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="题目解析-方法二-4"><a href="#题目解析-方法二-4" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h4><p>元素 i,j 顺时针旋转90°后变为 j,n-i-1<br>由于：    </p>
<ol>
<li>matrix[i][j]  水平轴反转 –&gt; matrix[n-i-1][j]</li>
<li>matrix[n-i-1][j]  主对角线反转 –&gt; matrix[j][n-i-1]</li>
</ol>
<p>正好得到结果，所以两次反转即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//水平轴反转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span> - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[i].<span class="built_in">swap</span>(matrix[n - <span class="number">1</span> - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对角线反转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>leedcode</category>
      </categories>
      <tags>
        <tag>leedcode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>os 003 protected mode</title>
    <url>/2021/05/14/os-003-protected-mode/</url>
    <content><![CDATA[<h1 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected mode"></a>protected mode</h1><h4 id="保护模式简介"><a href="#保护模式简介" class="headerlink" title="保护模式简介"></a>保护模式简介</h4><h6 id="实模式的缺陷"><a href="#实模式的缺陷" class="headerlink" title="实模式的缺陷"></a>实模式的缺陷</h6><ol>
<li><p>实模式下操作系统与用户程序属于听一个特权级，容易引起系统崩溃。</p>
</li>
<li><p>程序引用的地址指向真实的物理地址，即逻辑地址等于物理地址，不利于内存分片管理，容易造成内存碎片化。</p>
</li>
<li><p>用户程序可以随意访问任意内存。</p>
</li>
<li><p>一个短只能访问64KB地址，太小了，操作不方便。</p>
</li>
<li><p>一次只能运行一个程序。</p>
</li>
<li><p>只有20根地址线，只能寻址1M的空间，太小啦。   </p>
</li>
</ol>
<blockquote>
<p>为了克服实模式低劣的内存管理方式，开发出了保护模式。  </p>
</blockquote>
<h6 id="保护模式的特点"><a href="#保护模式的特点" class="headerlink" title="保护模式的特点"></a>保护模式的特点</h6><ol>
<li>寄存器扩展。</li>
<li>寻址空间扩展为4GB。</li>
<li>对内存分段并进行描述。全局描述符表，全局描述符表寄存器，段描述符缓冲寄存器。</li>
<li></li>
</ol>
<h6 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h6><p>进入保护模式的步骤为：</p>
<ol>
<li>打开A20</li>
<li>加载gdt</li>
<li>将cr0的pe位置1</li>
<li>jmp 刷新流水线</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;-----------------  打开A20  ----------------</span></span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0x92</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0000_0010B</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">0x92</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------  加载GDT  ----------------</span></span><br><span class="line"><span class="keyword">lgdt</span> [gdt_ptr]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------  cr0第0位置1  ----------------</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x00000001</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<h4 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h4><h6 id="段描述符的结构"><a href="#段描述符的结构" class="headerlink" title="段描述符的结构"></a>段描述符的结构</h6><table>
<thead>
<tr>
<th>位</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>高32位</td>
<td></td>
</tr>
<tr>
<td>31-24</td>
<td>段基址31-24</td>
</tr>
<tr>
<td>23</td>
<td>G</td>
</tr>
<tr>
<td>22</td>
<td>D/B</td>
</tr>
<tr>
<td>21</td>
<td>L</td>
</tr>
<tr>
<td>20</td>
<td>AVL</td>
</tr>
<tr>
<td>19-16</td>
<td>段界限19-16</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
</tr>
<tr>
<td>14-13</td>
<td>DPL</td>
</tr>
<tr>
<td>12</td>
<td>S</td>
</tr>
<tr>
<td>11-8</td>
<td>TYPE</td>
</tr>
<tr>
<td>7-0</td>
<td>段基址23-16</td>
</tr>
<tr>
<td>低32位</td>
<td></td>
</tr>
<tr>
<td>31-16</td>
<td>段基址15-0</td>
</tr>
<tr>
<td>15-0</td>
<td>段界限15-0</td>
</tr>
</tbody></table>
<ol>
<li>实际的段界限值=（描述符中的段界限值+1）*（段界限的粒度，1B 或者 4KB) - 1</li>
<li>G=0，粒度为1B，G=1，粒度为4KB.<br>3、E=0，向上扩展，常用于代码段与数据段。E=1，向下扩展，常用于栈段。</li>
</ol>
<h6 id="全局描述符表-GDT"><a href="#全局描述符表-GDT" class="headerlink" title="全局描述符表 GDT"></a>全局描述符表 GDT</h6><p>全局描述符表相当于描述符的数组，每一个元素是8字节的描述符，使用选择子进行索引。GDT中的第0个描述符是不可用的。</p>
<h6 id="全局描述符表寄存器-GDTR"><a href="#全局描述符表寄存器-GDTR" class="headerlink" title="全局描述符表寄存器 GDTR"></a>全局描述符表寄存器 GDTR</h6><p>GDT存在于内存中，GDTR是一个专门指向全局描述符表的寄存器。结构如下：</p>
<table>
<thead>
<tr>
<th>47-15</th>
<th>15-0</th>
</tr>
</thead>
<tbody><tr>
<td>GDT初始地址</td>
<td>GDT界限</td>
</tr>
</tbody></table>
<p>在实模式先使用lgdt加载描述符表，但是由于实模式的限制，此时的GTD只能处于1M地址空间以内，所以到了保护模式可以再次进行lgdt更改GDT的位置。</p>
<p>lgdt [48位内存数据]<br>按小端字节序，前16位用于舒适化GDT界限，后32位，用于指定GDT的初始地址。</p>
<h6 id="选择子"><a href="#选择子" class="headerlink" title="选择子"></a>选择子</h6><p>在实模式下，段寄存器选择的是段基址，在开启内存分段后，段寄存器存储的是对应段描述符表的索引和相关数据。选择子的结构如下：</p>
<table>
<thead>
<tr>
<th>15-4</th>
<th>3</th>
<th>2-0</th>
</tr>
</thead>
<tbody><tr>
<td>描述符索引值</td>
<td>TI</td>
<td>RPL</td>
</tr>
</tbody></table>
<p>描述符索引值正好为12位，刚好和GDTR界限所确定的最大描述符数量相匹配。</p>
<h4 id="获得内存信息"><a href="#获得内存信息" class="headerlink" title="获得内存信息"></a>获得内存信息</h4><p>eg:</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;-------  int 15h eax = 0000E820h ,edx = 534D4150h (&#x27;SMAP&#x27;) 获取内存布局  -------</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ebx</span>, <span class="built_in">ebx</span>		      <span class="comment">;第一次调用时，ebx值要为0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="number">0x534d4150</span>	      <span class="comment">;edx只赋值一次，循环体中不会改变</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">di</span>, ards_buf	      <span class="comment">;ards结构缓冲区</span></span><br><span class="line"><span class="symbol">.e820_mem_get_loop:</span>	      <span class="comment">;循环获取每个ARDS内存范围描述结构</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0x0000e820</span>	      <span class="comment">;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">20</span>		      <span class="comment">;ARDS地址范围描述符结构大小是20字节</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .e820_failed_so_try_e801   <span class="comment">;若cf位为1则有错误发生，尝试0xe801子功能</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">di</span>, <span class="built_in">cx</span>		      <span class="comment">;使di增加20字节指向缓冲区中新的ARDS结构位置</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">word</span> [ards_nr]	      <span class="comment">;记录ARDS数量</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">ebx</span>, <span class="number">0</span>		      <span class="comment">;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span></span><br><span class="line">   <span class="keyword">jnz</span> .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line"><span class="comment">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, [ards_nr]	      <span class="comment">;遍历每一个ARDS结构体,循环次数是ARDS的数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, ards_buf </span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span>		      <span class="comment">;edx为最大的内存容量,在此先清0</span></span><br><span class="line"><span class="symbol">.find_max_mem_area:</span>	      <span class="comment">;无须判断type是否为1,最大的内存块一定是可被使用</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>]	      <span class="comment">;base_add_low</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>+<span class="number">8</span>]	      <span class="comment">;length_low</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">20</span>		      <span class="comment">;指向缓冲区中下一个ARDS结构</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>		      <span class="comment">;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span></span><br><span class="line">   <span class="keyword">jge</span> .next_ards</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>		      <span class="comment">;edx为总内存大小</span></span><br><span class="line"><span class="symbol">.next_ards:</span></span><br><span class="line">   <span class="keyword">loop</span> .find_max_mem_area</span><br><span class="line">   <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="comment">;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------</span></span><br><span class="line"><span class="comment">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span></span><br><span class="line"><span class="comment">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span></span><br><span class="line"><span class="symbol">.e820_failed_so_try_e801:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0xe801</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .e801_failed_so_try88   <span class="comment">;若当前e801方法失败,就尝试0x88方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0x400</span>	     <span class="comment">;cx和ax值一样,cx用做乘数</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">cx</span> </span><br><span class="line">   <span class="keyword">shl</span> <span class="built_in">edx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x0000FFFF</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>, <span class="number">0x100000</span> <span class="comment">;ax只是15MB,故要加1MB</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">edx</span>	     <span class="comment">;先把低15MB的内存容量存入esi寄存器备份</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span>		</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">0x10000</span>	<span class="comment">;0x10000十进制为64KB</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">ecx</span>		<span class="comment">;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>		<span class="comment">;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">esi</span>		<span class="comment">;edx为总内存大小</span></span><br><span class="line">   <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span></span><br><span class="line"><span class="symbol">.e801_failed_so_try88:</span> </span><br><span class="line">   <span class="comment">;int 15后，ax存入的是以kb为单位的内存容量</span></span><br><span class="line">   <span class="keyword">mov</span>  <span class="number">ah</span>, <span class="number">0x88</span></span><br><span class="line">   <span class="keyword">int</span>  <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .error_hlt</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x0000FFFF</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0x400</span>     <span class="comment">;0x400等于1024,将ax中的内存容量换为以byte为单位</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">cx</span></span><br><span class="line">   <span class="keyword">shl</span> <span class="built_in">edx</span>, <span class="number">16</span>	     <span class="comment">;把dx移到高16位</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>	     <span class="comment">;把积的低16位组合到edx,为32位的积</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">0x100000</span>  <span class="comment">;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.mem_get_ok:</span></span><br><span class="line">   <span class="keyword">mov</span> [total_mem_bytes], <span class="built_in">edx</span>	 <span class="comment">;将内存换为byte单位后存入total_mem_bytes处。</span></span><br></pre></td></tr></table></figure>

<h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p><strong>分段是分页的前提</strong></p>
<h6 id="内存分段模式下的问题"><a href="#内存分段模式下的问题" class="headerlink" title="内存分段模式下的问题"></a>内存分段模式下的问题</h6><ol>
<li>物理内存不足时怎么把？</li>
<li>内存碎片化问题怎么解决。</li>
</ol>
<blockquote>
<p>在保护模式下，段描述符是内存段的身份证，cpu根据一个段描述符来引用一个段。很多时候，段描述符对应的段并不在内存中。如果一个描述符的P位为1，则表示该段在内存中存在。访问过一个段后，cpu将该描述符中的A为置1。如果P位为0，则说明内存中不存在这个段，则cpu抛出np异常，操作系统将对应的段加载到内存中。</p>
</blockquote>
<blockquote>
<p>分页机制的思想是，通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的额线性地址在物理上可以不连续。分页机制将大小不不等的段分解为大小相等的页，再将页映射到物理页。分页机制的作用有：将线性地址转化为物理地址，用大小相等的页代替大小不等的段。有了页表的映射关系，经过段部件的处理输出的则为虚拟地址。在分页机制下，每个进程都认为自己独享整个4GB空间。即程序以为自己身处于段式存储下并拥有4GB空间，但是他的地址经由页部件处理之后才是真正的物理地址。</p>
</blockquote>
<h6 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h6><blockquote>
<p>页表用于存储线性地址与物理地址之间的映射。页表中的每一项为大小为4字节的页表项，用来记录4GB空间的物理地址。当访问一个线性地址的时候，实际上就是在访问页表项中对应的物理地址。</p>
</blockquote>
<blockquote>
<p>每个页大小为4KB，一个页表可以存储1M个页表项，加起来一个页表可以表示整个4GB物理空间。</p>
</blockquote>
<blockquote>
<p>一级页表的地址转换过程为：用线性地址的高20位作为页表项的索引，每个页表项占用4字节的大小，索引值乘上4就可以得到该页表项在页表中的偏移量。用cr3寄存器中的页表物理地址加上此偏移量就可以得到该页表项的物理地址，从该页表项中得到映射的物理地址，再与低12位的线性地址相加就可以得到最终要访问的物理地址。</p>
</blockquote>
<blockquote>
<p>假设咱们是在平坦模型下工作，不管段选择子值是多少，其所指向的段基址都是 0，指令 mov ax，<br>[0x1234]中的 0x1234 称为有效地址，它作为“段基址：段内偏移地址”中的段内偏移地址。这样段基址<br>为 0，段内偏移地址为 0x1234，经过段部件处理后，输出的线性地址是 0x1234。由于咱们是演示分页机制，必须假定系统已经打开了分页机制，所以线性地址 0x1234 被送入了页部件。页部件分析 0x1234 的高20 位，用十六进制表示高 20 位是 0x00001。将此项作为页表项索引，再将该索引乘以 4 后加上 cr3 寄存器中页表的物理地址，这样便得到索引所指代的页表项的物理地址，从该物理地址处（页表项中）读取所映射的物理页地址：0x9000。线性地址的低 12 位是 0x234，它作为物理页的页内偏移地址与物理页地址0x9000 相加，和为 0x9234，这就是线性地址 0x1234 最终转换成的物理地址。     </p>
</blockquote>
<h6 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h6><blockquote>
<p>二级页表将4GB空间按每一个标准页大小4KB分为1M个页，将这1M个页分1K*1K个页，每1K个页表项又正好可以组成一个新的页（1K*4B=4KB），将这个新产生的页记录为一个页表项，则总共会产生1K个新的页表项，再将这1K个页表项组成一个标准页，则最后产生的这个标准页为页目录表，其中每一项为页目录项PDE。</p>
</blockquote>
<blockquote>
<p>二级页表地址转换原理是将 32 位虚拟地址拆分成高 10 位、中间 10 位、低 12 位三部分，它们<br>的作用是：高 10 位作为页表的索引，用于在页目录表中定位一个页目录项 PDE，页目录项中有页表物理地址，也就是定位到了某个页表。中间 10 位作为物理页的索引，用于在页表内定位到某个页表项 PTE，页表项中有分配的物理页地址，也就是定位到了某个物理页。低 12 位作为页内偏移量用于在已经定位到的物理页内寻址。</p>
</blockquote>
<blockquote>
<p>转换过程背后的具体步骤如下。<br>（1）用虚拟地址的高 10 位乘以 4，作为页目录表内的偏移地址，加上页目录表的物理地址，所得的<br>和，便是页目录项的物理地址。读取该页目录项，从中获取到页表的物理地址。<br>（2）用虚拟地址的中间 10 位乘以 4，作为页表内的偏移地址，加上在第 1 步中得到的页表物理地址，<br>所得的和，便是页表项的物理地址。读取该页表项，从中获取到分配的物理页地址。<br>（3）虚拟地址的高 10 位和中间 10 位分别是 PDE 和 PTE 的索引值，所以它们需要乘以 4。但低 12 位就不是索引值啦，其表示的范围是 0～0xfff，作为页内偏移最合适，所以虚拟地址的低 12 位加上第 2 步中得到的物理页地址，所得的和便是最终转换的物理地址。 </p>
</blockquote>
<h6 id="页目录项和页表项的结构"><a href="#页目录项和页表项的结构" class="headerlink" title="页目录项和页表项的结构"></a>页目录项和页表项的结构</h6><p><strong>页目录项</strong>    </p>
<table>
<thead>
<tr>
<th>31-12</th>
<th>11-9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>页表物理页地址31-12位</td>
<td>AVL</td>
<td>G</td>
<td>0</td>
<td>D</td>
<td>A</td>
<td>PCD</td>
<td>PWT</td>
<td>US</td>
<td>RW</td>
<td>P</td>
</tr>
</tbody></table>
<p><strong>页表项</strong>    </p>
<table>
<thead>
<tr>
<th>31-12</th>
<th>11-9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>物理页地址31-12位</td>
<td>AVL</td>
<td>G</td>
<td>PAT</td>
<td>D</td>
<td>A</td>
<td>PCD</td>
<td>PWT</td>
<td>US</td>
<td>RW</td>
<td>P</td>
</tr>
</tbody></table>
<blockquote>
<p>页表目录项和页表项中的都是物理页地址，标准页大小就是4KB，所以地址都是4K的倍数，即低12位全为零，所以只需要记录高20位就可以了。省下来的12位可以用于其他属性。</p>
</blockquote>
<blockquote>
<p>P，Present，意为存在位。若为 1 表示该页存在于物理内存中，若为 0 表示该表不在物理内存中。操<br>作系统的页式虚拟内存管理便是通过 P 位和相应的 pagefault 异常来实现的。</p>
</blockquote>
<blockquote>
<p>RW，Read/Write，意为读写位。若为 1 表示可读可写，若为 0 表示可读不可写。</p>
</blockquote>
<blockquote>
<p>US，User/Supervisor，意为普通用户/超级用户位。若为 1 时，表示处于 User 级，任意级别（0、1、2、 3）特权的程序都可以访问该页。若为 0，表示处于 Supervisor 级，特权级别为 3 的程序不允许访问该页，该页只允许特权级别为 0、1、2 的程序可以访问。</p>
</blockquote>
<blockquote>
<p>PWT，Page-level Write-Through，意为页级通写位，也称页级写透位。若为 1 表示此项采用通写方式，表示该页不仅是普通内存，还是高速缓存。此项和高速缓存有关，“通写”是高速缓存的一种工作方式，本位用来间接决定是否用此方式改善该页的访问效率。这里咱们直接置为 0 就可以啦。</p>
</blockquote>
<blockquote>
<p>PCD，Page-level Cache Disable，意为页级高速缓存禁止位。若为 1 表示该页启用高速缓存，为 0 表示禁止将该页缓存。这里咱们将其置为 0。 A，Accessed，意为访问位。若为 1 表示该页被 CPU 访问过啦，所以该位是由 CPU 设置的。还记得段描述符中的 A 位和 P 位吗？这两位在一起可以实现段式虚拟内存管理。和它们一样，这里页目录项和页表项中的 A 位也可以用来记录某一内存页的使用频率（操作系统定期将该位清 0，统计一段时间内变成 1 的次数），从而当内存不足时，可以将使用频率较低的页面换出到外存（如硬盘），同时将页目录项或页表项的 P位置 0，下次访问该页引起 pagefault 异常时，中断处理程序将硬盘上的页再次换入，同时将 P 位置 1。 D，Dirty，意为脏页位。当 CPU 对一个页面执行写操作时，就会设置对应页表项的 D 位为 1。此项仅针对页表项有效，并不会修改页目录项中的 D 位。</p>
</blockquote>
<blockquote>
<p>PAT，Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。比较复杂，将此位置 0 即可。</p>
</blockquote>
<blockquote>
<p>G,Global，意为全局位。由于内存地址转换也是颇费周折，先得拆分虚拟地址，然后又要查页目录，又要查页表的，所以为了提高获取物理地址的速度，将虚拟地址与物理地址转换结果存储在 TLB（Translation Lookaside Buffer）中，TLB 以后咱们会细说。在此先知道 TLB 是用来缓存地址转换结果的高速缓存就 ok 啦。此 G 位用来指定该页是否为全局页，为 1 表示是全局页，为 0 表示不是全局页。若为全局页，该页将在高速缓存 TLB 中一直保存，给出虚拟地址直接就出物理地址啦，无需那三步骤转换。由于 TLB 容量比较小（一般速度较快的存储设备容量都比较小），所以这里面就存放使用频率较高的页面。顺便说一句，清空 TLB 有两种方式，一是用 invlpg 指令针对单独虚拟地址条目清理，或者是重新加载 cr3 寄存器，这将直接清空 TLB。</p>
</blockquote>
<blockquote>
<p>AVL，意为 Available 位，表示可用，谁可以用？当然是软件，操作系统可用该位，CPU 不理会该位<br>的值，那咱们也不理会吧。</p>
</blockquote>
<h6 id="开启分页"><a href="#开启分页" class="headerlink" title="开启分页"></a>开启分页</h6><p>开启分页需要顺序做以下三件事情。</p>
<ol>
<li>准备好页目录表和页表。</li>
<li>将页表地址写入控制寄存器cr3。</li>
<li>寄存器的PG位置1.</li>
</ol>
<h4 id="elf-executable-and-linkable-format"><a href="#elf-executable-and-linkable-format" class="headerlink" title="elf (executable and linkable format)"></a>elf (executable and linkable format)</h4><h6 id="elf中的数据类型"><a href="#elf中的数据类型" class="headerlink" title="elf中的数据类型"></a>elf中的数据类型</h6><table>
<thead>
<tr>
<th>数据类型名称</th>
<th>字节大小</th>
<th>对齐</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>Elf_Half</td>
<td>2</td>
<td>2</td>
<td>无符号中等大小的整数</td>
</tr>
<tr>
<td>Elf_Word</td>
<td>4</td>
<td>4</td>
<td>无符号大整数</td>
</tr>
<tr>
<td>Elf_Addr</td>
<td>4</td>
<td>4</td>
<td>无符号程序运行地址</td>
</tr>
<tr>
<td>Elf_Off</td>
<td>4</td>
<td>4</td>
<td>无符号文件偏移量</td>
</tr>
</tbody></table>
<h4 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h4><blockquote>
<p>RPL:请求特权级指令请求访问其他资源的能力成为请求特权级，指令存放在代码段中，所所以使用CS中选择子的RPL位表示代码请求别人资源的能力。    </p>
</blockquote>
<blockquote>
<p>CPL：表示处理器当亲的特权级。指令最终是由处理器执行的，执行到不同特权的代码，处理器的特权级就切换到不同的等级。代码段描述符中的DPL便是当前处理器所处的特权级。    </p>
</blockquote>
<blockquote>
<p>对于数据段来讲，只有访问者的权限大于或等于段描述符中的DPL表示的最低权限时才能够访问。</p>
</blockquote>
<blockquote>
<p>对于代码段来讲，只有访问者的权限<strong>等于</strong>段描述符中的DPL才能访问。即只能平级访问。访问一个代码段实质上就是跳转到这个段进行执行。唯一一种处理器从高特权级降到低特权级执行的情况是处理器从中断处理程序中返回到用户态。</p>
</blockquote>
<blockquote>
<p>一致性代码段：一致性代码段也成为依从代码段，用来实现从低特权级的代码向高特权级代码的转移。一致性代码段是指如果自己是转移后的目标段，则自己的特权级一定能要大于等于转移前的CPL，也就是说一致性代码段的DPL是特权的上限。处理器遇到目标端位一致性代码段的时候并不会将CPL用该段的DPL来替换。代码段可以有一致性与不一致性的段，但是数据段只能有非一致性，即数据段不允许比自己特权级低的代码段访问。</p>
</blockquote>
<h4 id="函数调约定"><a href="#函数调约定" class="headerlink" title="函数调约定"></a>函数调约定</h4><h6 id="cdecl-c-declaration-即c声明"><a href="#cdecl-c-declaration-即c声明" class="headerlink" title="cdecl (c declaration 即c声明)"></a>cdecl (c declaration 即c声明)</h6><p>函数参数从右到左顺序入栈，EAX,ECX,EDX,寄存器由<strong>调用者</strong>保存，其余的寄存器由<strong>被调用者</strong>保存。函数的返回值存储在EAX寄存器中。由<strong>调用者</strong>清理栈空间。</p>
<p>示例：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> subtract(<span class="keyword">int</span> a, <span class="keyword">int</span> b)<span class="comment">; //被调用者</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">sub</span> = subtract (<span class="number">3</span>,<span class="number">2</span>)<span class="comment">; // 主调用者</span></span><br><span class="line">主调用者：</span><br><span class="line"><span class="comment">; 从右到左将参数入栈</span></span><br><span class="line"><span class="keyword">push</span> <span class="number">2</span> <span class="comment">;压入参数 b </span></span><br><span class="line"><span class="keyword">push</span> <span class="number">3</span> <span class="comment">;压入参数 a </span></span><br><span class="line"><span class="keyword">call</span> subtract <span class="comment">;调用函数 subtract </span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">8</span> <span class="comment">;回收（清理）栈空间</span></span><br><span class="line">被调用者：</span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ebp</span> <span class="comment">;压入 ebp 备份</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span> <span class="comment">;将 esp 赋值给 ebp </span></span><br><span class="line"> <span class="comment">;用 ebp 作为基址来访问栈中参数</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,[<span class="built_in">ebp</span>+<span class="number">0x8</span>] <span class="comment">;偏移 8 字节处为第 1 个参数 a </span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">eax</span>,[<span class="built_in">ebp</span>+<span class="number">0xc</span>] <span class="comment">;偏移 0xc 字节处是第 2 个参数 b </span></span><br><span class="line"> <span class="comment">;参数 a 和 b 相加后存入 eax </span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">esp</span>,<span class="built_in">ebp</span> <span class="comment">;为防止中间有入栈操作，用 ebp 恢复 esp </span></span><br><span class="line"> <span class="comment">;本句在此例子中可有可无,属于通用代码</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ebp</span> <span class="comment">;将 ebp 恢复</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>


<h4 id="C与汇编混合编程"><a href="#C与汇编混合编程" class="headerlink" title="C与汇编混合编程"></a>C与汇编混合编程</h4><p>c语言和汇编语言混合编程分为两种：</p>
<ol>
<li>单独的汇编代码文件与单独的c语言文件分别编译成目标文件后，再进行连接成可执行程序。</li>
<li>再c语言中嵌入汇编语言，直接编译成生可执行程序。这种也叫做内联汇编。</li>
</ol>
<h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><h6 id="基本内联汇编"><a href="#基本内联汇编" class="headerlink" title="基本内联汇编"></a>基本内联汇编</h6><p>格式：<br>asm [volatile](“asm code”)       </p>
<ol>
<li>指令必须要用双引号括起来</li>
<li>一对双引号不可以跨行，如果跨行需要在结尾使用’\‘转义。</li>
<li>指令之间使用’;’,’\n’,’\t’分隔开。</li>
<li>即使指令分隔在多个双引号中也要使用分隔符。</li>
</ol>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"> char* str=<span class="string">&quot;hello,world\n&quot;</span>; </span><br><span class="line"> <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line"> void main()&#123; </span><br><span class="line"> asm(<span class="string">&quot;pusha; \ </span></span><br><span class="line"><span class="string"> movl $4,%eax; \ </span></span><br><span class="line"><span class="string"> movl $1,%ebx; \ </span></span><br><span class="line"><span class="string"> movl str,%ecx; \ </span></span><br><span class="line"><span class="string"> movl $12,%edx; \ </span></span><br><span class="line"><span class="string"> int $0x80; \ </span></span><br><span class="line"><span class="string">mov %eax,count;\ </span></span><br><span class="line"><span class="string">popa \ </span></span><br><span class="line"><span class="string">&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h6 id="扩展内联汇编"><a href="#扩展内联汇编" class="headerlink" title="扩展内联汇编"></a>扩展内联汇编</h6><p>格式：<br>asm [volatile] (“assembly code”:output : input : clobber/modify)</p>
<ol>
<li><p>assembly code：还是用户写入的汇编指令，和基本内联汇编一样。</p>
</li>
<li><p>output:output 用来指定汇编代码的数据如何输出给 C 代码使用。内嵌的汇编指令运行结束后，如果想将运行结果存储到 c 变量中，就用此项指定输出的位置。</p>
</li>
<li><p>input：input 用来指定 C 中数据如何输入给汇编使用。要想让汇编使用 C 中的变量作为参数，就要在此指定。</p>
</li>
<li><p>clobber/modify：汇编代码执行后会破坏一些内存或寄存器资源，通过此项通知编译器，可能造成寄<br>存器或内存数据的破坏，这样 gcc 就知道哪些寄存器或内存需要提前保护起来。</p>
</li>
</ol>
<p><strong>约束</strong></p>
<ol>
<li>寄存器约束  </li>
</ol>
<p>寄存器约束就是要求 gcc 使用哪个寄存器，将 input 或 output 中变量约束在某个寄存器中。常见的寄存器约束有：<br>a：表示寄存器 eax/ax/al<br>b：表示寄存器 ebx/bx/bl<br>c：表示寄存器 ecx/cx/cl<br>d：表示寄存器 edx/dx/dl<br>D：表示寄存器 edi/di<br>S：表示寄存器 esi/si<br>q：表示任意这 4 个通用寄存器之一：eax/ebx/ecx/edx<br>r：表示任意这 6 个通用寄存器之一：eax/ebx/ecx/edx/esi/edi<br>g：表示可以存放到任意地点（寄存器和内存）。相当于除了同 q 一样外，还可以让 gcc 安排在内存中<br>A：把 eax 和 edx 组合成 64 位整数<br>f：表示浮点寄存器<br>t：表示第 1 个浮点寄存器<br>u：表示第 2 个浮点寄存器      </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> in_a = <span class="number">1</span>, in_b = <span class="number">2</span>, out_sum; </span><br><span class="line"><span class="built_in"><span class="keyword">asm</span></span>(<span class="string">&quot;addl %%ebx, %%eax&quot;</span>:<span class="string">&quot;=a&quot;</span>(out_sum):<span class="string">&quot;a&quot;</span>(in_a),<span class="string">&quot;b&quot;</span>(in_b)); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sum is %d\n&quot;</span>,out_sum); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>内存约束</li>
</ol>
<p>内存约束是要求 gcc 直接将位于 input 和 output 中的 C 变量的内存地址作为内联汇编代码的操作数，不需要寄存器做中转，直接进行内存读写，也就是汇编代码的操作数是 C 变量的指针。    </p>
<p>m：表示操作数可以使用任意一种内存形式。<br>o：操作数为内存变量，但访问它是通过偏移量的形式访问，即包含 offset_address 的格式。       </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> in_a = <span class="number">1</span>, in_b = <span class="number">2</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in_b is %d\n&quot;</span>, in_b); </span><br><span class="line"><span class="built_in"><span class="keyword">asm</span></span>(<span class="string">&quot;movb %b0, %1;&quot;</span>::<span class="string">&quot;a&quot;</span>(in_a),<span class="string">&quot;m&quot;</span>(in_b)); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in_b now is %d\n&quot;</span>, in_b); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>立即数约束</li>
</ol>
<p>i：表示操作数为整数立即数<br>F：表示操作数为浮点数立即数<br>I：表示操作数为 0～31 之间的立即数<br>J：表示操作数为 0～63 之间的立即数<br>N：表示操作数为 0～255 之间的立即数<br>O：表示操作数为 0～32 之间的立即数<br>X：表示操作数为任何类型立即数    </p>
<ol start="4">
<li>通用约束</li>
</ol>
<p>0～9：此约束只用在 input 部分，但表示可与 output 和 input 中第 n 个操作数用相同的寄存器或内存。</p>
<h4 id="AT-amp-T汇编"><a href="#AT-amp-T汇编" class="headerlink" title="AT&amp;T汇编"></a>AT&amp;T汇编</h4><p>intel 与 AT&amp;T 语法风格对比</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>intel</th>
<th>AT&amp;T</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>寄存器没有钱追你</td>
<td>寄存器有前缀%</td>
<td></td>
</tr>
<tr>
<td>操作数顺序</td>
<td>目的操作数在左边，源操作数在右边</td>
<td>相反</td>
<td></td>
</tr>
<tr>
<td>操作数指定大小</td>
<td>有关内存的操作数要加数据类型指定大小，byte：8位，word:16位，dword:32位</td>
<td>指令的最后一个字母代表指令操作数大小，b:8位，w:16位，l:32位。</td>
<td></td>
</tr>
<tr>
<td>立即数</td>
<td>没有前缀</td>
<td>有前缀$</td>
<td></td>
</tr>
<tr>
<td>远跳转</td>
<td>jmp far segment:offset</td>
<td>ljmp $segment:$offset</td>
<td></td>
</tr>
<tr>
<td>远调用</td>
<td>call far segment:offset</td>
<td>lcall $segment:$offset</td>
<td></td>
</tr>
<tr>
<td>远返回</td>
<td>ret far n</td>
<td>lret $n</td>
<td></td>
</tr>
</tbody></table>
<p>内存寻址格式：<br>segreg(段基址):base_address(offset,index,size)        </p>
<p>segreg:base_address+offset+index*size</p>
<h4 id="打印-printf-的实现"><a href="#打印-printf-的实现" class="headerlink" title="打印 printf 的实现"></a>打印 printf 的实现</h4><h6 id="打印字符"><a href="#打印字符" class="headerlink" title="打印字符"></a>打印字符</h6><p>在printf.h中声明函数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void put<span class="constructor">_char(<span class="params">uint8_t</span> <span class="params">char_asci</span>)</span></span><br></pre></td></tr></table></figure>

<p>在print.s中完成函数的定义</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">global</span> put_char</span><br><span class="line"><span class="comment">;外部符号声明 </span></span><br><span class="line"><span class="keyword">pushad</span>   <span class="comment">;备份8个32位寄存器</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,SELECTOR_VIDEO</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">gs</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;获取光标位置</span></span><br><span class="line"><span class="comment">;高8位</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x03d4</span>  <span class="comment">;索引寄存器</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0x0e</span>    <span class="comment">;光标位置高8位</span></span><br><span class="line"><span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>      </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x03d5</span>     </span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">al</span></span><br><span class="line"><span class="comment">;低8位</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x03d4</span>  <span class="comment">;索引寄存器</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0x0f</span>   <span class="comment">;光标位置高8位</span></span><br><span class="line"><span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>      </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x03d5</span>     </span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;光标为值存放在bx中</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="comment">;取得要打印的字符</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>,[<span class="built_in">esp</span>+<span class="number">36</span>]</span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">cl</span>,<span class="number">0xd</span></span><br><span class="line"><span class="keyword">jz</span> .is_carriage_return</span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">cl</span>,<span class="number">0xa</span></span><br><span class="line"><span class="keyword">jz</span> .is_line_feed</span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">cl</span>,<span class="number">0x8</span></span><br><span class="line"><span class="keyword">jz</span> .is_backspace</span><br><span class="line"><span class="keyword">jmp</span> .put_other</span><br><span class="line"></span><br><span class="line"><span class="symbol">.is_backspace:</span></span><br><span class="line"><span class="keyword">dec</span> <span class="built_in">bx</span>   <span class="comment">;光标位置减一</span></span><br><span class="line"><span class="keyword">shl</span> <span class="built_in">bx</span>,<span class="number">1</span>    <span class="comment">;左移一位，bx乘二得到光标处字符所在为内存地址。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> [<span class="built_in">gs</span>:<span class="built_in">bx</span>],<span class="number">0</span>   <span class="comment">;将这一个字符为位置清零包括颜色属性</span></span><br><span class="line"><span class="keyword">shr</span> <span class="built_in">bx</span>,<span class="number">1</span>    <span class="comment">;bx恢复原状</span></span><br><span class="line"><span class="keyword">jmp</span> .set_cursor</span><br><span class="line"></span><br><span class="line"><span class="symbol">.put_other:</span></span><br><span class="line"><span class="keyword">shl</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">gs</span>:<span class="built_in">bx</span>],<span class="built_in">cl</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="built_in">bx</span>],<span class="number">0x07</span></span><br><span class="line"><span class="keyword">shr</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line"><span class="comment">;若光标值小于2000，则表示该页现存没有写完，若超出2000，则回车换行处理</span></span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">bx</span>,<span class="number">2000</span></span><br><span class="line"><span class="keyword">jl</span> .set_cursor</span><br><span class="line"></span><br><span class="line"><span class="symbol">.is_line_feed:</span></span><br><span class="line"><span class="symbol">.is_carriage_return:</span></span><br><span class="line"><span class="keyword">xor</span> <span class="built_in">dx</span>,<span class="built_in">dx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">80</span></span><br><span class="line"><span class="keyword">div</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">bx</span>,<span class="built_in">dx</span></span><br><span class="line"><span class="comment">;先让光标回到行首再下一行，判断是否超出。</span></span><br><span class="line"><span class="symbol">.is_carriage_return_end:</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">80</span></span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">bx</span>,<span class="number">2000</span></span><br><span class="line"><span class="symbol">.is_line_feed_end:</span></span><br><span class="line"><span class="keyword">jl</span> .set_cursor</span><br><span class="line"></span><br><span class="line"><span class="comment">;超出屏幕大小开始滚屏</span></span><br><span class="line"><span class="symbol">.roll_screen:</span></span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="number">960</span> <span class="comment">;共搬运 2000-80=1920个字符</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="number">0xb80a0</span>   <span class="comment">;第一行行首</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">edi</span>,<span class="number">0xb8000</span>   <span class="comment">;第零行行首</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">movsd</span></span><br><span class="line"><span class="comment">;将最后一行填充为空白</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebx</span>,<span class="number">3840</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="number">80</span></span><br><span class="line"><span class="symbol">.cls:</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> [<span class="built_in">gs</span>:<span class="built_in">ebx</span>],<span class="number">0</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ebx</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> .cls</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1920</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;设置光标值</span></span><br><span class="line"><span class="symbol">.set_cursor:</span></span><br><span class="line"><span class="comment">;将光标设为bx值</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x03d4</span>			  <span class="comment">;索引寄存器</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0x0e</span>				  <span class="comment">;用于提供光标位置的高8位</span></span><br><span class="line">   <span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x03d5</span>			  <span class="comment">;通过读写数据端口0x3d5来获得或设置光标位置 </span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">bh</span></span><br><span class="line">   <span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x03d4</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0x0f</span></span><br><span class="line">   <span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x03d5</span> </span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="built_in">bl</span></span><br><span class="line">   <span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.put_char_done:</span></span><br><span class="line">   <span class="keyword">popad</span></span><br><span class="line">   <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<h6 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h6><p>在printf.h中声明函数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void put<span class="constructor">_str(<span class="params">char</span><span class="operator">*</span> <span class="params">message</span>)</span></span><br></pre></td></tr></table></figure>

<p>在print.s中完成函数的定义</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">global</span> put_str</span><br><span class="line"><span class="symbol">put_str:</span></span><br><span class="line"><span class="comment">;由于本函数中只用到了ebx和ecx,只备份这两个寄存器</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ebx</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ecx</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ecx</span>, <span class="built_in">ecx</span>		      <span class="comment">; 准备用ecx存储参数,清空</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, [<span class="built_in">esp</span> + <span class="number">12</span>]	      <span class="comment">; 从栈中得到待打印的字符串地址 </span></span><br><span class="line"><span class="symbol">.goon:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cl</span>, [<span class="built_in">ebx</span>]</span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">cl</span>, <span class="number">0</span>		      <span class="comment">; 如果处理到了字符串尾,跳到结束处返回</span></span><br><span class="line">   <span class="keyword">jz</span> .str_over</span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ecx</span>		      <span class="comment">; 为put_char函数传递参数</span></span><br><span class="line">   <span class="keyword">call</span> put_char</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">4</span>		      <span class="comment">; 回收参数所占的栈空间</span></span><br><span class="line">                        <span class="comment">;由调用者回收栈空间，C语言调用的话编译器会自动完成但是汇编语言不会，需要我们手动回收。</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">ebx</span>		      <span class="comment">; 使ebx指向下一个字符</span></span><br><span class="line">   <span class="keyword">jmp</span> .goon</span><br><span class="line"><span class="symbol">.str_over:</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">ecx</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">ebx</span></span><br><span class="line">   <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<h6 id="打印整数"><a href="#打印整数" class="headerlink" title="打印整数"></a>打印整数</h6><p>在printf.h中声明函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_int</span><span class="params">(<span class="keyword">uint32_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在print.s中完成函数的定义</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">global</span> put_int</span><br><span class="line"><span class="symbol">put_int:</span></span><br><span class="line"><span class="keyword">pushad</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,[<span class="built_in">ebp</span>+<span class="number">36</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">edi</span>,<span class="number">7</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="number">8</span>   <span class="comment">;32位数字共分为8块</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebx</span>,put_int_buffer</span><br><span class="line"></span><br><span class="line"><span class="symbol">.16based_4bits:</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">edx</span>,<span class="number">0x0000000F</span></span><br><span class="line"><span class="keyword">cmp</span>,<span class="number">9</span></span><br><span class="line"><span class="keyword">jg</span> .isA2F</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">edx</span>,<span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">jmp</span> .store</span><br><span class="line"><span class="symbol">.is_A2F:</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">edx</span>,<span class="number">10</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">edx</span>,<span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="comment">;从大往小存储在缓冲区内，最后一个数字放在最高位</span></span><br><span class="line"><span class="symbol">.store:</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">edi</span>],<span class="built_in">dl</span></span><br><span class="line"><span class="keyword">dec</span> <span class="built_in">edi</span></span><br><span class="line"><span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="number">4</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="number">4</span></span><br><span class="line"><span class="keyword">loop</span> .16based_4bits</span><br><span class="line"></span><br><span class="line"><span class="symbol">.ready_to_print:</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">edi</span></span><br><span class="line"><span class="meta">.skip_prefix_0</span>    <span class="comment">;判断是不是8位全零</span></span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">edi</span>,<span class="number">8</span></span><br><span class="line"><span class="keyword">je</span> .full0</span><br><span class="line"><span class="symbol">.go_on_skip:</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>,[put_int_buffer+<span class="built_in">edi</span>]</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">edi</span></span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">cl</span>,<span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">je</span> .skip_prefix_0</span><br><span class="line"><span class="keyword">dec</span> <span class="built_in">edi</span></span><br><span class="line"><span class="keyword">jmp</span> .put_each_num</span><br><span class="line"></span><br><span class="line"><span class="symbol">.full0:</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="symbol">.put_each_num:</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ecx</span></span><br><span class="line"><span class="keyword">call</span> put_char</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">4</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">edi</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>,[put_int_buffer+<span class="built_in">edi</span>]</span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">edi</span>,<span class="number">8</span></span><br><span class="line"><span class="keyword">jl</span> .put_each_num</span><br><span class="line"><span class="keyword">popad</span></span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h4 id="杂项问题"><a href="#杂项问题" class="headerlink" title="杂项问题"></a>杂项问题</h4><ol>
<li>对于push指令，处于对齐的要求，操作数要么是16位要么是32位，所以8位操作数会被扩展为运行模式下的默认操作数宽度。实模式为16位，保护模式为32位。</li>
<li>使用伪指令 [bits 16] [bits 32] 指定编译器进行模式指定。 </li>
<li>操作数反转前缀 0x66 寻址方式反转前缀 0x67</li>
</ol>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>微机与汇编接口实验</title>
    <url>/2021/07/05/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%B1%87%E7%BC%96%E6%8E%A5%E5%8F%A3%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="微机与汇编接口实验"><a href="#微机与汇编接口实验" class="headerlink" title="微机与汇编接口实验"></a>微机与汇编接口实验</h1><p>暑假小学期让做一个有关微机的小项目，看来也是为以后做嵌入式开发做准备。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>设想的是使用led点阵做一个小型的贪吃蛇游戏，并且可以使用红外遥控器进行操控，并且配合实时的灯光和音效展现出一种复古的街机氛围。<br>设计项目要抓住项目的主要矛盾，做贪吃蛇就是做贪吃蛇，专心地先做出来贪吃蛇再想别的。          </p>
<p>首先必须可以实时的控制led点阵，led点阵可以显示红绿两种颜色，将led点阵存放在red_buffer、green_buffer中，他们都是一个8字节地缓冲区，每一个字节存放了每一列中各行地明亮情况。下面说明一下程序的生命周期：程序开始运行，主菜单显示退出程序和开始贪吃蛇游戏，选择退出程序则退出程序，选择开始贪吃蛇游戏则开始贪吃蛇游戏。进入贪吃蛇游戏之后在led点阵上显示出图像，使用遥控器控制贪吃蛇进行移动吃食物，若撞到墙则从另一边出来，若撞到自己则失败回到主菜单。在游戏过程中实时播放音效和数码管计分。</p>
<h3 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h3><ol>
<li>程序开始时展现出一个菜单，菜单分为：<ol>
<li>退出程序</li>
<li>开始贪吃蛇游戏</li>
</ol>
</li>
<li>贪吃蛇程序开始运行，在led点阵上面实时地显示。</li>
<li>使用数码管显示当前得分</li>
<li>在游戏中播放音乐</li>
<li>在游戏中根据贪吃蛇地状态进行灯光、音乐、文字等方面地提示。</li>
<li>游戏失败后返回主菜单。</li>
</ol>
<h3 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h3><ol>
<li>show_led<ol>
<li>负责根据led点阵缓冲区中地数据向上提供可靠的led点阵显示程序。   </li>
<li>入口：led点阵缓冲区</li>
<li>出口：led点阵进行刷新一次</li>
</ol>
</li>
<li>delay<ol>
<li>根据bx地值进行时长不等的延时。</li>
<li>入口：bx</li>
<li>出口：延时一定时间</li>
</ol>
</li>
<li>dispmenu<ol>
<li>显示程序初始的菜单</li>
<li>入口：程序启动</li>
<li>出口：显示程序初始的菜单</li>
</ol>
</li>
<li>show_digital_tube<ol>
<li>把bx中的10进制数据显示出来（0&lt;=bx&lt;=9999)</li>
<li>入口：bx</li>
<li>出口：数码管显示bx中的十进制数据</li>
</ol>
</li>
<li>buzzer_sound<ol>
<li>根据bx中的频率，蜂鸣器响</li>
<li>入口：bx</li>
<li>出口：蜂鸣器响特定的频率</li>
</ol>
</li>
<li>infrared_input<ol>
<li>红外线输入，接受红外线的输入并将红外线输入的信息存储到infrared_input_buffer中。</li>
<li>入口：红外线输入</li>
<li>出口：更新infrared_input_buffer</li>
</ol>
</li>
<li>keyboard_input<ol>
<li>键盘输入，接受键盘的输入并将键盘输入的信息存储到keyboard_input_buffer中。</li>
<li>入口：键盘输入</li>
<li>出口：更新keyboard_input_buffer</li>
</ol>
</li>
<li>process_input<ol>
<li>处理输入，根据infrared_input_buffer和keyboard_input_buffer和status_buffer更新程序的数据。相当于游戏逻辑控制。</li>
<li>入口：以上三个缓冲区</li>
<li>出口：根据游戏状态和逻辑更新游戏状态</li>
</ol>
</li>
<li>run<ol>
<li>程序的状态机，程序的声明周期控制</li>
<li>入口：status_buffer</li>
<li>出口：status_buffer</li>
</ol>
</li>
</ol>
<h3 id="详细模块设计"><a href="#详细模块设计" class="headerlink" title="详细模块设计"></a>详细模块设计</h3><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;点亮数码管  ********</span></span><br><span class="line"><span class="comment">;删除simple_input</span></span><br><span class="line"><span class="comment">;删除红外输入的有关内容</span></span><br><span class="line"><span class="comment">;键盘的BIOS调用 int 16h  入口: ah=0 出口 al=ascii     先使用 ah=01判断是否有输入</span></span><br><span class="line"><span class="comment">;注释掉 process_input中的 call keyboard_input 和snake_count_time 中的 call keyboard_input 并删除中断程序中对call keyboard_input的注释，验证使用中断输入是否可行</span></span><br><span class="line"><span class="comment">;删除snake中jmp snake_flush </span></span><br><span class="line"><span class="comment">;新增 delay_short</span></span><br><span class="line"><span class="comment">;尝试可不可以在任何时候按下9回到主菜单，做不到的话就删除主菜单中的这句话</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;支持子程序库的简化段源程序格式</span></span><br><span class="line">    include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small	<span class="comment">; 定义程序的存储模式</span></span><br><span class="line"><span class="meta">	.stack</span>	<span class="comment">; 定义堆栈段（默认是1KB空间）</span></span><br><span class="line"><span class="meta">	.data</span>	<span class="comment">;数据段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;存放每一列的信息 1为亮 两种颜色交替进行闪亮 要把每一个字节的信息传送给行，来控制某一行的亮  </span></span><br><span class="line"><span class="comment">;比如 某一个字节为 1000_0010b 则最上面一行和倒数第二行的灯亮，此时只需要对应列全为1即可控制该列的8个灯的亮暗。</span></span><br><span class="line"><span class="comment">;红色   颜色是通过列线进行输出的</span></span><br><span class="line">red_buffer   <span class="built_in">byte</span> <span class="number">8</span> dup(<span class="number">0</span>)</span><br><span class="line"><span class="comment">;绿色</span></span><br><span class="line">green_buffer <span class="built_in">byte</span> <span class="number">8</span> dup(<span class="number">0</span>)</span><br><span class="line"><span class="comment">;infrared_input_buffer  存储红外线输入的缓冲区  每一个bit可以自由定义其含义</span></span><br><span class="line">infrared_input_buffer <span class="built_in">word</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;keyboard_input_buffer 存储键盘输入的缓冲区  每一个bit可以自由定义其含义</span></span><br><span class="line">keyboard_input_buffer <span class="built_in">word</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;Status buffer 状态缓冲区，用来存放程序运行的各种状态</span></span><br><span class="line">status_buffer <span class="built_in">word</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;时间缓冲区，负责提供同步信息 由中断程序每隔10ms加一</span></span><br><span class="line">sync_time_buffer <span class="built_in">word</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;蛇身位置 不包含蛇头 蛇的每一个位置需要两个字节，8*8*2=128B</span></span><br><span class="line">snake_body_buffer <span class="built_in">byte</span> <span class="number">128</span> dup(<span class="number">0</span>)</span><br><span class="line"><span class="comment">;蛇身的长度，不包括蛇头，也是当前的分数</span></span><br><span class="line">snake_body_length <span class="built_in">word</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;蛇头位置</span></span><br><span class="line">snake_head_position_x <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line">snake_head_position_y <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;蛇尾位置</span></span><br><span class="line">snake_tail_position_x <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line">snake_tail_position_y <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;食物位置</span></span><br><span class="line">food_x <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line">food_y <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;是否吃了食物 0:没有 1:吃了</span></span><br><span class="line">food_eaten <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;碰撞与否</span></span><br><span class="line">collision <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;蛇的前近方向 2:上 0：下 2;左 1：右</span></span><br><span class="line">snake_direction <span class="built_in">byte</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;保存原中断程序入口</span></span><br><span class="line">int_0b_seg <span class="built_in">word</span> <span class="number">0</span></span><br><span class="line">int_0b_off <span class="built_in">word</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;蛇的时间量，每经过100个全局时间量 加一，即蛇每1s移动一次 </span></span><br><span class="line">snake_time <span class="built_in">word</span> <span class="number">0</span></span><br><span class="line"><span class="comment">;数码管</span></span><br><span class="line">ledtb <span class="built_in">byte</span> <span class="number">3fh</span>,<span class="number">06h</span>,<span class="number">5bh</span>,<span class="number">4fh</span>,<span class="number">66h</span>,<span class="number">6dh</span>,<span class="number">7dh</span>,<span class="number">07h</span>,<span class="number">7fh</span>,<span class="number">6fh</span></span><br><span class="line"><span class="comment">;得分（当前长度减去初始长度）存储  分别存储四个数码管的数字</span></span><br><span class="line">lednum <span class="built_in">byte</span> <span class="number">4</span> dup(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">byte</span> <span class="number">128</span> dup(<span class="number">0</span>)</span><br><span class="line"><span class="comment">;main_menu 主菜单</span></span><br><span class="line">main_menu <span class="built_in">byte</span> <span class="string">&#x27;---------------main menu---------------&#x27;</span>,<span class="number">10</span>,<span class="number">13</span></span><br><span class="line"><span class="built_in">byte</span> <span class="string">&#x27;----press corrsepnding key to continue----&#x27;</span>,<span class="number">10</span>,<span class="number">13</span></span><br><span class="line"><span class="built_in">byte</span> <span class="string">&#x27;1. exit&#x27;</span>,<span class="number">10</span>,<span class="number">13</span></span><br><span class="line"><span class="built_in">byte</span> <span class="string">&#x27;2. play snake_gluttony &#x27;</span>,<span class="number">10</span>,<span class="number">13</span></span><br><span class="line"><span class="built_in">byte</span> <span class="string">&#x27;*********************************************&#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span>									</span><br><span class="line">			   							  </span><br><span class="line">			  															  </span><br><span class="line"><span class="comment">;退出语句</span></span><br><span class="line">abort_msg <span class="built_in">byte</span> <span class="string">&#x27;exit,thanks&#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">msgstatus0 <span class="built_in">byte</span> <span class="string">&#x27;msgstatus0&#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">msgstatus1 <span class="built_in">byte</span> <span class="string">&#x27;msgstatus1&#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">msgsetint <span class="built_in">byte</span> <span class="string">&#x27;msgsetint&#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">msgscankeyboard <span class="built_in">byte</span> <span class="string">&#x27;msgscankeyboard&#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">msgintirq10 <span class="built_in">byte</span> <span class="string">&#x27;msgintirq10&#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">snake_gluttony_running <span class="built_in">byte</span> <span class="string">&#x27;snake_gluttony is running&#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">msg_direction <span class="built_in">byte</span> <span class="string">&#x27;now, the direction is &#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">msg_snake_head_position <span class="built_in">byte</span> <span class="string">&#x27;msg_snake_head_position is &#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">msg_snake_tail_position <span class="built_in">byte</span> <span class="string">&#x27;msg_snake_tail_position is &#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">msg_snake_body_position <span class="built_in">byte</span> <span class="string">&#x27;msg_snake_body_position is &#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">msg_snake_gluttony_game_over <span class="built_in">byte</span> <span class="string">&#x27;game over!!!&#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">msg_snake_gluttony_game_start <span class="built_in">byte</span> <span class="string">&#x27;snake gluttony game start, have fun!!!&#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">msg_int_test <span class="built_in">byte</span> <span class="string">&#x27;msg_int_test&#x27;</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">	.code</span>	<span class="comment">;代码段</span></span><br><span class="line"><span class="symbol">start:</span>	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;设置中断</span></span><br><span class="line">	<span class="keyword">call</span> set_int</span><br><span class="line">	<span class="keyword">call</span> run</span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;状态机 负责处理所有的状态 程序的所有状态全部由status_buffer所体现</span></span><br><span class="line">run proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;程序开始运行，清空程序的所有缓冲区</span></span><br><span class="line"><span class="symbol">run_begin:</span></span><br><span class="line">	<span class="keyword">call</span> clear_digital_buffer</span><br><span class="line">	<span class="keyword">call</span> clear_screen</span><br><span class="line">	<span class="keyword">call</span> disp_main_menu</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">;清空缓冲区的数据</span></span><br><span class="line">	<span class="keyword">mov</span> red_buffer,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> green_buffer,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> status_buffer,<span class="number">1</span>   <span class="comment">;初始状态为1 主菜单</span></span><br><span class="line">	<span class="keyword">mov</span> infrared_input_buffer,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="number">0</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">;显示主菜单 没有收到遥控器的命令就一直进行查询</span></span><br><span class="line"><span class="symbol">show_main_menu:</span></span><br><span class="line">	<span class="comment">;所有的输入已经通过每10ms的中断传入到输入缓冲区了</span></span><br><span class="line">	<span class="keyword">call</span> process_input		<span class="comment">;改变程序状态 下面判断当前程序状态 000为退出</span></span><br><span class="line">	<span class="comment">;判断是否有有效输入进行下一步</span></span><br><span class="line">	<span class="comment">;状态0 退出</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,status_buffer</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00000111B</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jz</span> run_abort</span><br><span class="line">	<span class="comment">;状态1 </span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,status_buffer </span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00000111B</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">jz</span> show_main_menu</span><br><span class="line">	<span class="comment">;判断是否要进入贪吃蛇游戏 就是判断当前主状态为2</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,status_buffer </span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00000111B</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">2</span></span><br><span class="line">	<span class="keyword">jz</span> run_snake_gluttony</span><br><span class="line">	<span class="comment">;判断是否退出</span></span><br><span class="line">	<span class="keyword">jz</span> run_abort</span><br><span class="line">	<span class="keyword">jmp</span> show_main_menu</span><br><span class="line"><span class="comment">;运行贪吃蛇</span></span><br><span class="line"><span class="symbol">run_snake_gluttony:</span></span><br><span class="line"><span class="symbol">	snake_gluttony_game_start:</span></span><br><span class="line">	<span class="comment">;每一个主状态都是一个自循环，除非中断迫使其退出</span></span><br><span class="line">	<span class="keyword">call</span> snake_gluttony</span><br><span class="line">	<span class="comment">;贪吃蛇由于某种原因运行完成退出 回到主菜单</span></span><br><span class="line"><span class="symbol">snake_gluttony_game_over:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset msg_snake_gluttony_game_over</span><br><span class="line">	<span class="keyword">call</span> dispstr</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1000</span></span><br><span class="line">	<span class="keyword">call</span> delay</span><br><span class="line">	<span class="keyword">jmp</span> run_begin</span><br><span class="line"></span><br><span class="line"><span class="comment">;这里可以有很多程序和贪吃蛇并列，但是我并不想要。</span></span><br><span class="line"><span class="symbol">run_abort:</span></span><br><span class="line">	<span class="comment">;打印出一段退出程序的语句</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset abort_msg</span><br><span class="line">	<span class="keyword">call</span> dispstr </span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">run endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;显示主菜单</span></span><br><span class="line">disp_main_menu proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset main_menu</span><br><span class="line">	<span class="keyword">call</span> dispstr </span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">disp_main_menu endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;处理输入结果 逻辑控制</span></span><br><span class="line">process_input proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;判断主状态	</span></span><br><span class="line"><span class="symbol">judge_main_status:</span></span><br><span class="line">	<span class="comment">;状态0 ，退出</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,status_buffer </span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00000111B</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jz</span> main_status_0	<span class="comment">;跳转到主状态0 退出</span></span><br><span class="line">	<span class="comment">;判断是否为主状态1，即在主菜单</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,status_buffer </span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00000111B</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">jz</span> main_status_1	<span class="comment">;跳转到主状态1来执行</span></span><br><span class="line">	<span class="comment">;判断是否为主状态2，即贪吃蛇游戏</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,status_buffer</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00000111B</span>	<span class="comment">;只留下低三位</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">2</span>			<span class="comment">;状态1</span></span><br><span class="line">	<span class="keyword">jz</span> main_status_2	<span class="comment">;跳转到主状态1，即执行贪吃蛇</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;还要依次遍历很多别的状态</span></span><br><span class="line">	<span class="keyword">jmp</span> process_input_done</span><br><span class="line"></span><br><span class="line"><span class="comment">;状态0 ，退出</span></span><br><span class="line"><span class="symbol">main_status_0:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,status_buffer</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">bl</span>,<span class="number">11111000B</span></span><br><span class="line">	<span class="keyword">mov</span> status_buffer,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">jmp</span> process_input_done</span><br><span class="line"></span><br><span class="line"><span class="comment">;主状态1 主菜单</span></span><br><span class="line"><span class="symbol">main_status_1:</span></span><br><span class="line">	<span class="comment">;将程序状态变为1</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">00000001B</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,status_buffer</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">bl</span>,<span class="number">11111000B</span></span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">bl</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> status_buffer,<span class="built_in">bx</span></span><br><span class="line">	<span class="comment">;主菜单一件事情，等待输入，将红外和键盘输入的对于处于主菜单的程序有效的输入存储在缓冲区内</span></span><br><span class="line">	<span class="comment">;判断红外输入。 1:退出 2：开始贪吃蛇	9：回到主菜单</span></span><br><span class="line">	<span class="comment">;键盘输入，1-9位对应输入</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,keyboard_input_buffer</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00000010B</span> 	<span class="comment">;判断第一位 退出</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">00000010B</span>	</span><br><span class="line">	<span class="keyword">jz</span> main_status_0</span><br><span class="line">	<span class="comment">;键盘输入，1-9位对应输入</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,keyboard_input_buffer</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00000100B</span> 	<span class="comment">;判断第二位 贪吃蛇</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">00000100B</span>	</span><br><span class="line">	<span class="keyword">jz</span> main_status_2</span><br><span class="line">	<span class="keyword">jmp</span> process_input_done</span><br><span class="line"></span><br><span class="line"><span class="comment">;主状态2 贪吃蛇</span></span><br><span class="line"><span class="symbol">main_status_2:</span></span><br><span class="line">	<span class="comment">;将程序状态变为2</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">00000010B</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,status_buffer</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">bl</span>,<span class="number">11111000B</span></span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">bl</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> status_buffer,<span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;没有符合条件的状态，直接退出</span></span><br><span class="line">	<span class="keyword">jmp</span> process_input_done</span><br><span class="line"></span><br><span class="line"><span class="symbol">process_input_done:</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">process_input endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;Infrared input 红外线输入</span></span><br><span class="line">infrared_input proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">infrared_input endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;simple_input</span></span><br><span class="line">simple_input proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">282h</span>		<span class="comment">;读入 pc</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jz</span> simple_input_end</span><br><span class="line"></span><br><span class="line"><span class="symbol">simple_input_1:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00000010B</span></span><br><span class="line">	<span class="keyword">jz</span> simple_input_2</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,keyboard_input_buffer</span><br><span class="line">	<span class="comment">;or ax,0000 0000 0000 0010b</span></span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">bx</span>,<span class="number">0002h</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">bx</span></span><br><span class="line"><span class="symbol">simple_input_2:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00000100B</span></span><br><span class="line">	<span class="keyword">jz</span> simple_input_w</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,keyboard_input_buffer</span><br><span class="line">	<span class="comment">;or ax,0000 0000 0000 0100b</span></span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">bx</span>,<span class="number">0004h</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">bx</span></span><br><span class="line"><span class="symbol">simple_input_w:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00001000B</span></span><br><span class="line">	<span class="keyword">jz</span> simple_input_a</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,keyboard_input_buffer</span><br><span class="line">	<span class="comment">;or ax,0000 0100 0000 0000b</span></span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">bx</span>,<span class="number">0400h</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">bx</span></span><br><span class="line"><span class="symbol">simple_input_a:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00010000B</span></span><br><span class="line">	<span class="keyword">jz</span> simple_input_s</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,keyboard_input_buffer</span><br><span class="line">	<span class="comment">;or ax,0000 0100 0000 0000b</span></span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">bx</span>,<span class="number">0800h</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">bx</span></span><br><span class="line"><span class="symbol">simple_input_s:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00100000B</span></span><br><span class="line">	<span class="keyword">jz</span> simple_input_d</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,keyboard_input_buffer</span><br><span class="line">	<span class="comment">;or ax,0000 0100 0000 0000b</span></span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">bx</span>,<span class="number">1000h</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">bx</span></span><br><span class="line"><span class="symbol">simple_input_d:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">01000000B</span></span><br><span class="line">	<span class="keyword">jz</span> simple_input_end</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,keyboard_input_buffer</span><br><span class="line">	<span class="comment">;or ax,0000 0100 0000 0000b</span></span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">bx</span>,<span class="number">2000h</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">simple_input_end:</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">simple_input endp</span><br><span class="line"><span class="comment">;键盘输入</span></span><br><span class="line">keyboard_input proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">	<span class="comment">;mov si,offset msgscankeyboard </span></span><br><span class="line">	<span class="comment">;call dispstr </span></span><br><span class="line"><span class="comment">;扫描输入</span></span><br><span class="line">	<span class="comment">;键盘输入 al中存放键盘输入的ascii码</span></span><br><span class="line"><span class="symbol">scan_keynoard:</span></span><br><span class="line">	<span class="comment">;处理键盘的W A S D  10-13位存放  将对应位置1   输入小写</span></span><br><span class="line">	<span class="comment">;call readkey</span></span><br><span class="line">	<span class="comment">;测试 int 16h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">01h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">16h</span></span><br><span class="line">	<span class="keyword">jz</span> scan_keynoard_end	<span class="comment">;若键盘缓冲区没有则结束</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">00h</span> 				<span class="comment">;键盘缓冲区中有则读取</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">16h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">scan_keynoard_w:</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="string">&#x27;w&#x27;</span></span><br><span class="line">	<span class="keyword">jnz</span> scan_keynoard_a</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,keyboard_input_buffer</span><br><span class="line">	<span class="comment">;or ax,0000 0100 0000 0000b</span></span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">ax</span>,<span class="number">0400h</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">jmp</span> scan_keynoard_end</span><br><span class="line"><span class="symbol">scan_keynoard_a:</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">	<span class="keyword">jnz</span> scan_keynoard_s</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,keyboard_input_buffer</span><br><span class="line">	<span class="comment">;or ax,0000 1000 0000 0000b</span></span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">ax</span>,<span class="number">0800h</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">jmp</span> scan_keynoard_end</span><br><span class="line"><span class="symbol">scan_keynoard_s:</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="string">&#x27;s&#x27;</span></span><br><span class="line">	<span class="keyword">jnz</span> scan_keynoard_d</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,keyboard_input_buffer</span><br><span class="line">	<span class="comment">;or ax,0001 0000 0000 0000b</span></span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">ax</span>,<span class="number">1000h</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">jmp</span> scan_keynoard_end</span><br><span class="line"><span class="symbol">scan_keynoard_d:</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="string">&#x27;d&#x27;</span></span><br><span class="line">	<span class="keyword">jnz</span> scan_keynoard_num</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,keyboard_input_buffer</span><br><span class="line">	<span class="comment">;or ax,0010 0000 0000 0000b</span></span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">ax</span>,<span class="number">2000h</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">jmp</span> scan_keynoard_end</span><br><span class="line"><span class="comment">;扫描num num存在1-9位对应1-9</span></span><br><span class="line"><span class="symbol">scan_keynoard_num:</span></span><br><span class="line">	<span class="keyword">sub</span> <span class="built_in">al</span>,<span class="number">48</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">1</span>		<span class="comment">;小于1不行</span></span><br><span class="line">	<span class="keyword">jb</span> scan_keynoard_end</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">9</span>		<span class="comment">;大于9不行</span></span><br><span class="line">	<span class="keyword">ja</span> scan_keynoard_end</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">shl</span> <span class="built_in">bx</span>,<span class="built_in">cl</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,keyboard_input_buffer</span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">jmp</span> scan_keynoard_end</span><br><span class="line"></span><br><span class="line"><span class="comment">;将来增加新功能</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">scan_keynoard_end:</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">keyboard_input endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;点亮数码管 用来记录分数等信息 使用pc</span></span><br><span class="line">show_digital_tube proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">call</span> clear_digital_buffer</span><br><span class="line">	<span class="comment">;先得到每一个数码管应该显示的数字</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,snake_body_length</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset lednum</span><br><span class="line">	<span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line"><span class="symbol">get_one_tube_num:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">10</span></span><br><span class="line">	<span class="keyword">div</span> <span class="built_in">bl</span>  	       </span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="number">ah</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="number">ah</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jz</span> get_one_tube_num_over</span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">loop</span> get_one_tube_num</span><br><span class="line"></span><br><span class="line"><span class="symbol">get_one_tube_num_over:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;依次显示出来</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset lednum</span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">00000001B</span> </span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line"><span class="symbol">show_digital_tube_one_by_one:</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">bx</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,ledtb[<span class="built_in">bx</span>]	<span class="comment">;段码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;clear tube			;清空位码 灭掉所有的灯</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">280h</span>			 </span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">282h</span>			<span class="comment">;清空段码</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0ffh</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;控制数字 段码</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">282h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="comment">;控制哪一个tube去亮 位码</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">280h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">shl</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">	<span class="comment">;mov bx,1</span></span><br><span class="line">	<span class="comment">;call delay_short</span></span><br><span class="line">	<span class="keyword">loop</span> show_digital_tube_one_by_one</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">;clear tube			;清空位码 灭掉所有的灯</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">280h</span>			 </span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">282h</span>			<span class="comment">;清空段码</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0ffh</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">;验证数字算的duibudui</span></span><br><span class="line">	<span class="comment">;mov si,offset lednum</span></span><br><span class="line">	<span class="comment">;add si,3</span></span><br><span class="line">	<span class="comment">;mov cx,4</span></span><br><span class="line"><span class="symbol">disp_led_num:</span></span><br><span class="line">	<span class="comment">;mov al,[si]</span></span><br><span class="line">	<span class="comment">;dec si</span></span><br><span class="line">	<span class="comment">;call dispuib</span></span><br><span class="line">	<span class="comment">;loop disp_led_num</span></span><br><span class="line">	<span class="comment">;call dispcrlf</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">show_digital_tube endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;clear </span></span><br><span class="line">clear_digital_buffer proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset lednum</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>+<span class="number">1</span>],<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>+<span class="number">3</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">clear_digital_buffer endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;蜂鸣器响 入口参数：响的频率</span></span><br><span class="line">buzzer_sound proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">buzzer_sound endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;写入红色灯亮，ah为行号，al为列号 注意这里 （0，0）在左下角 </span></span><br><span class="line">make_it_red proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;ah,al hang lie</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset red_buffer</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="number">ah</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">si</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">00000001B</span></span><br><span class="line">	<span class="keyword">shl</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">bl</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="built_in">bl</span>	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">make_it_red endp</span><br><span class="line"></span><br><span class="line">make_it_green proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">	<span class="comment">;ah,al hang lie</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset green_buffer</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="number">ah</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">si</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">00000001B</span></span><br><span class="line">	<span class="keyword">shl</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">or</span> <span class="built_in">bl</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="built_in">bl</span>	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">make_it_green endp</span><br><span class="line"></span><br><span class="line">make_it_dark proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">	<span class="comment">;ah,al hang lie</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset red_buffer</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="number">ah</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">si</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">11111110B</span></span><br><span class="line">	<span class="keyword">rol</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">bl</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="built_in">bl</span>	</span><br><span class="line"></span><br><span class="line">	<span class="comment">;ah,al hang lie</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset green_buffer</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="number">ah</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">si</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">11111110B</span></span><br><span class="line">	<span class="keyword">rol</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">bl</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="built_in">bl</span>	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">make_it_dark endp</span><br><span class="line"></span><br><span class="line">make_all_dark proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset red_buffer</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">make_all_dark_again:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">0</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">loop</span> make_all_dark_again</span><br><span class="line">	</span><br><span class="line"><span class="symbol">make_all_dark_end:</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">make_all_dark endp</span><br><span class="line"></span><br><span class="line">clear_snake_body proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset snake_body_buffer</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">128</span></span><br><span class="line"><span class="symbol">clear_snake_body_again:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">0</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">loop</span> clear_snake_body_again</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">clear_snake_body endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;逐列点亮所有的led灯阵  只向上提供可靠的点亮程序，其余不管（例如延时显示、定时改变颜色等）</span></span><br><span class="line">show_led proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;写入8255方式控制字</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span> , <span class="number">283h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span> , <span class="number">80h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span> , <span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">;逐列刷新 红  si控制红行 di控制绿行</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset red_buffer <span class="comment">;控制每一列的红8行</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">di</span>,offset green_buffer <span class="comment">;控制每一列的绿8行</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">10000000b</span> <span class="comment">;第一列 颜色通过列线进行输出，281h输出则为第零列为红，282h输出则为第零列为绿 </span></span><br><span class="line"><span class="symbol">again_show_led_col:</span></span><br><span class="line">	<span class="comment">;红列  是控制哪一列是什么颜色的 红:281h 绿：282h 第0列为红色 </span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">281h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="comment">;每一列控制哪一行的红灯亮    这里有问题 对于控制行线来讲，若要红灯亮绿灯不亮则都不会亮（但是由于时间间隔很短，所以我在实验室的效果就是看起来不太亮）</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]					<span class="comment">;所以这里必须解决红绿灯互相影响的问题</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">1</span>					<span class="comment">;因为时按列亮灯，共用列，所以不可能在一列中同时显示红灯和绿灯。</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">280h</span>					<span class="comment">;要不试试逐个点亮  </span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>					<span class="comment">;我觉得实验室器材不太好，必不能支持如此高频率的数据传送</span></span><br><span class="line">								<span class="comment">;所以贪吃蛇只能做到食物和蛇一个颜色，让食物闪烁吧。</span></span><br><span class="line">	<span class="comment">;mov bx ,10000</span></span><br><span class="line">	<span class="comment">;call delay</span></span><br><span class="line">	<span class="comment">;绿列  </span></span><br><span class="line">	<span class="comment">;mov al,cl</span></span><br><span class="line">	<span class="comment">;mov dx,282h</span></span><br><span class="line">	<span class="comment">;out dx,al</span></span><br><span class="line">	<span class="comment">;每一列控制哪一行的绿灯亮</span></span><br><span class="line">	<span class="comment">;mov al,[di]</span></span><br><span class="line">	<span class="comment">;add di,1</span></span><br><span class="line">	<span class="comment">;mov dx,280h	</span></span><br><span class="line">	<span class="comment">;out dx,al</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;显示完每一列进行delay 以bx为参数</span></span><br><span class="line">	<span class="comment">;mov bx,1</span></span><br><span class="line">	<span class="comment">;call delay_short</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;关闭所有的列显示 </span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">281h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">280h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">shr</span> <span class="built_in">cl</span>,<span class="number">1</span> 	<span class="comment">;下一列</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">cl</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jnz</span> again_show_led_col</span><br><span class="line">	</span><br><span class="line">	<span class="comment">;趁这段时间列显示关闭，赶快将行信息输出到数码管（复用pa)</span></span><br><span class="line">	<span class="keyword">call</span> show_digital_tube	</span><br><span class="line"></span><br><span class="line"><span class="symbol">show_led_end:</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">show_led endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;运行贪吃蛇的程序   所有按键信息由中断进行扫描，程序只管从缓冲区中读取即可</span></span><br><span class="line">snake_gluttony proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;初始化，灭掉所有的灯 并清空蛇的身体</span></span><br><span class="line">	<span class="keyword">call</span> make_all_dark</span><br><span class="line">	<span class="keyword">call</span> clear_snake_body</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset msg_snake_gluttony_game_start</span><br><span class="line">	<span class="keyword">call</span> dispstr</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1000</span></span><br><span class="line">	<span class="keyword">call</span> delay</span><br><span class="line">	<span class="comment">;初始化贪吃蛇</span></span><br><span class="line">	<span class="comment">;设置蛇的初始位置  head(3,3) tail(3,4) dir=left</span></span><br><span class="line">	<span class="keyword">mov</span> snake_head_position_x,<span class="number">3</span></span><br><span class="line">	<span class="keyword">mov</span> snake_head_position_y,<span class="number">3</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">3</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">3</span></span><br><span class="line">	<span class="keyword">call</span> make_it_red</span><br><span class="line">	<span class="comment">;初始化一节身体 这里有问题</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset snake_body_buffer</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">03H</span>	<span class="comment">;横坐标 列 al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>+<span class="number">1</span>],<span class="number">04H</span>		<span class="comment">;纵坐标  行 ah</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">4</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">3</span></span><br><span class="line">	<span class="keyword">call</span> make_it_red</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>+<span class="number">2</span>],<span class="number">03H</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>+<span class="number">3</span>],<span class="number">05H</span></span><br><span class="line">	<span class="keyword">mov</span> snake_tail_position_x,<span class="number">3</span></span><br><span class="line">	<span class="keyword">mov</span> snake_tail_position_y,<span class="number">5</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">5</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">3</span></span><br><span class="line">	<span class="keyword">call</span> make_it_red</span><br><span class="line">	<span class="comment">;初始化一块食物</span></span><br><span class="line">	<span class="keyword">mov</span> food_x,<span class="number">1</span></span><br><span class="line">	<span class="keyword">mov</span> food_y,<span class="number">5</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">5</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">call</span> make_it_red</span><br><span class="line">	<span class="comment">;初始化方向为left 蛇身长度为1，此时蛇身只有一个尾巴</span></span><br><span class="line">	<span class="keyword">mov</span> snake_direction,<span class="number">2</span></span><br><span class="line">	<span class="keyword">mov</span> snake_body_length,<span class="number">2</span></span><br><span class="line">	<span class="keyword">mov</span> collision,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">snake_gluttony_begin:</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">snake_count_time:</span></span><br><span class="line">	<span class="comment">;蛇的身体信息已经全部适配为灯亮的信息</span></span><br><span class="line">	<span class="keyword">call</span> show_led</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,sync_time_buffer</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">10</span></span><br><span class="line">	<span class="keyword">div</span> <span class="built_in">bl</span>		<span class="comment">;得到余数在ah中 商在al</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="number">ah</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">ax</span>,[snake_time]		<span class="comment">;只要和之前的时间不相等就刷新</span></span><br><span class="line">	<span class="keyword">jnz</span> snake_flush</span><br><span class="line">	<span class="comment">;为防止因为溢出而造成的错误判断</span></span><br><span class="line">	<span class="keyword">mov</span> [snake_time],<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">jmp</span> snake_count_time</span><br><span class="line"><span class="comment">;snake的时间到了，可以刷新  ;现在要解决的问题是蛇不会移动</span></span><br><span class="line"><span class="symbol">snake_flush:</span></span><br><span class="line">	<span class="comment">;ax中存放当前贪吃蛇时间，放入snake_time</span></span><br><span class="line">	<span class="keyword">mov</span> [snake_time],<span class="built_in">ax</span></span><br><span class="line">	<span class="comment">;判断按键，进行贪吃蛇的逻辑操作  ;蛇的前近方向 3:上  0:下  2:左   1:右</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,keyboard_input_buffer</span><br><span class="line">	<span class="comment">;处理键盘的W A S D 改变方向 10-13位存放			;用开关连入 8255的pc 进行输入 </span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">10</span></span><br><span class="line">	<span class="keyword">shr</span> <span class="built_in">ax</span>,<span class="built_in">cl</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00001111B</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">00000001B</span></span><br><span class="line">	<span class="keyword">jz</span> snake_fulsh_process_key_w</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">00000010B</span></span><br><span class="line">	<span class="keyword">jz</span> snake_fulsh_process_key_a</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">00000100B</span></span><br><span class="line">	<span class="keyword">jz</span> snake_fulsh_process_key_s</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">00001000B</span></span><br><span class="line">	<span class="keyword">jz</span> snake_fulsh_process_key_d</span><br><span class="line"></span><br><span class="line">	<span class="comment">;没有任何按键按下则直接进行处理</span></span><br><span class="line">	<span class="keyword">jmp</span> snake_flush_process</span><br><span class="line"></span><br><span class="line"><span class="comment">;处理按键w</span></span><br><span class="line"><span class="symbol">snake_fulsh_process_key_w:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_direction</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span>	<span class="comment">;当前方向不为下时改变方向为上</span></span><br><span class="line">	<span class="keyword">jz</span> snake_flush_process</span><br><span class="line">	<span class="keyword">mov</span> snake_direction,<span class="number">3</span></span><br><span class="line">	<span class="keyword">jmp</span> snake_flush_process</span><br><span class="line"><span class="comment">;处理按键s</span></span><br><span class="line"><span class="symbol">snake_fulsh_process_key_s:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_direction</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">3</span>	<span class="comment">;当前方向不为上时改变方向为下</span></span><br><span class="line">	<span class="keyword">jz</span> snake_flush_process</span><br><span class="line">	<span class="keyword">mov</span> snake_direction,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jmp</span> snake_flush_process</span><br><span class="line"><span class="comment">;处理按键a</span></span><br><span class="line"><span class="symbol">snake_fulsh_process_key_a:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_direction</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">1</span>	<span class="comment">;当前方向不为右时改变方向为左</span></span><br><span class="line">	<span class="keyword">jz</span> snake_flush_process</span><br><span class="line">	<span class="keyword">mov</span> snake_direction,<span class="number">2</span></span><br><span class="line">	<span class="keyword">jmp</span> snake_flush_process</span><br><span class="line"><span class="comment">;处理按键d</span></span><br><span class="line"><span class="symbol">snake_fulsh_process_key_d:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_direction</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">2</span>	<span class="comment">;当前方向不为左时改变方向为右</span></span><br><span class="line">	<span class="keyword">jz</span> snake_flush_process</span><br><span class="line">	<span class="keyword">mov</span> snake_direction,<span class="number">1</span></span><br><span class="line">	<span class="keyword">jmp</span> snake_flush_process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;按键处理完了，处理贪吃蛇的位置</span></span><br><span class="line"><span class="symbol">snake_flush_process:</span></span><br><span class="line"><span class="comment">;现在已经得到了贪吃蛇的方向。输出检查是否成功</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;将按键信息清零</span></span><br><span class="line"><span class="symbol">snake_flush_process_clear_key:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,keyboard_input_buffer</span><br><span class="line">	<span class="comment">;处理键盘的W A S D 都置为零</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">ax</span>,<span class="number">1100001111111111B</span></span><br><span class="line">	<span class="keyword">mov</span> keyboard_input_buffer,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;位置刷新，根据上一次是否吃了食物决定身体更新策略</span></span><br><span class="line"><span class="comment">;若上一次刷新吃到了食物，则这一次蛇头变为蛇尾的一部分，然后蛇头向前走一步，若没有吃到，则从最后一节开始，每一节的位置时前一个的位置，第一个位置更新为蛇头的位置。</span></span><br><span class="line"><span class="symbol">move_snake_body:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="comment">;每个位置需要两个字节</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset snake_body_buffer	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">di</span>,snake_body_length		<span class="comment">;其实有没有吃都从最后一节向前更新即可，无非是length的不同</span></span><br><span class="line">	<span class="keyword">dec</span> <span class="built_in">di</span>			<span class="comment">;减一 方便指向每一节</span></span><br><span class="line">	<span class="keyword">shl</span> <span class="built_in">di</span>,<span class="number">1</span>	</span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">di</span>,<span class="built_in">si</span>	<span class="comment">;指向最后一节 目标地址</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,<span class="built_in">di</span></span><br><span class="line">	<span class="keyword">sub</span> <span class="built_in">si</span>,<span class="number">2</span>	<span class="comment">;源地址</span></span><br><span class="line"><span class="comment">;更新蛇的身体的每一节，第一节不更新</span></span><br><span class="line"><span class="symbol">move_snake_body_every_section:</span></span><br><span class="line">	<span class="comment">;先将旧的尾巴灭掉</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,snake_tail_position_y</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_tail_position_x</span><br><span class="line">	<span class="keyword">call</span> make_it_dark</span><br><span class="line">	<span class="comment">;更新蛇的尾巴信息 si所指向的</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">mov</span> snake_tail_position_x,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>+<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">mov</span> snake_tail_position_y,<span class="built_in">al</span></span><br><span class="line">	<span class="comment">;串传送的个数 （word）第一节不传送</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,snake_body_length</span><br><span class="line">	<span class="keyword">dec</span> <span class="built_in">cx</span>	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span>	</span><br><span class="line">	<span class="keyword">std</span>  		<span class="comment">;反向传送		</span></span><br><span class="line">	<span class="keyword">rep</span> <span class="keyword">movsw</span> 		</span><br><span class="line"></span><br><span class="line"><span class="comment">;更新第一节，将头的位置赋予即可</span></span><br><span class="line"><span class="symbol">move_snake_body_first_section:</span></span><br><span class="line">	<span class="comment">;高位存放纵坐标</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset snake_body_buffer</span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,snake_head_position_y</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_x</span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;位置刷新，将贪吃蛇头朝对应方向移动一格</span></span><br><span class="line"><span class="symbol">move_snake_head:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cl</span>,snake_direction</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">cl</span>,<span class="number">3</span>	<span class="comment">;上</span></span><br><span class="line">	<span class="keyword">jz</span> move_snake_head_up</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">cl</span>,<span class="number">0</span>	<span class="comment">;下</span></span><br><span class="line">	<span class="keyword">jz</span> move_snake_head_down</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">cl</span>,<span class="number">2</span> 	<span class="comment">;左</span></span><br><span class="line">	<span class="keyword">jz</span> move_snake_head_left</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">cl</span>,<span class="number">1</span>	<span class="comment">;右</span></span><br><span class="line">	<span class="keyword">jz</span> move_snake_head_right</span><br><span class="line">	<span class="comment">;不可能哪个方向都不对</span></span><br><span class="line">	<span class="comment">;jmp move_snake_head_direction_error</span></span><br><span class="line">	<span class="keyword">jmp</span> move_snake_head_left</span><br><span class="line"><span class="comment">;下</span></span><br><span class="line"><span class="symbol">move_snake_head_down:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,snake_head_position_y</span><br><span class="line">	<span class="keyword">sub</span> <span class="number">ah</span>,<span class="number">1</span>	</span><br><span class="line">	<span class="keyword">jnc</span> snake_judge_conflict</span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">7</span>	<span class="comment">;小于0，则从下面钻出来</span></span><br><span class="line">	<span class="keyword">jmp</span> snake_judge_conflict</span><br><span class="line"><span class="comment">;上</span></span><br><span class="line"><span class="symbol">move_snake_head_up:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,snake_head_position_y</span><br><span class="line">	<span class="keyword">add</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">8</span>	</span><br><span class="line">	<span class="keyword">jnz</span> snake_judge_conflict</span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span>	<span class="comment">;等于8，超界，则从上面钻出来</span></span><br><span class="line">	<span class="keyword">jmp</span> snake_judge_conflict</span><br><span class="line"><span class="comment">;左</span></span><br><span class="line"><span class="symbol">move_snake_head_left:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_x</span><br><span class="line">	<span class="keyword">sub</span> <span class="built_in">al</span>,<span class="number">1</span>	</span><br><span class="line">	<span class="keyword">jnc</span> snake_judge_conflict</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">7</span>	<span class="comment">;小于0，则从下右面钻出来</span></span><br><span class="line">	<span class="keyword">jmp</span> snake_judge_conflict</span><br><span class="line"><span class="comment">;右</span></span><br><span class="line"><span class="symbol">move_snake_head_right:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_x</span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">8</span>	</span><br><span class="line">	<span class="keyword">jnz</span> snake_judge_conflict</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span>	<span class="comment">;等于8 ，则从左面钻出来</span></span><br><span class="line">	<span class="keyword">jmp</span> snake_judge_conflict</span><br><span class="line"><span class="comment">;判断是否冲突 </span></span><br><span class="line"><span class="symbol">snake_judge_conflict:</span></span><br><span class="line">	<span class="comment">;此时 蛇头坐标为（ah,al)(行列)   ah中存放纵坐标，代表行值，al存放横坐标，代表列值</span></span><br><span class="line">	<span class="keyword">mov</span> snake_head_position_y,<span class="number">ah</span> 	<span class="comment">;行，纵坐标</span></span><br><span class="line">	<span class="keyword">mov</span> snake_head_position_x,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">call</span> show_snake_info</span><br><span class="line"></span><br><span class="line"><span class="comment">;首先判断是否蛇头和食物重合，若没有重合则蛇尾向前一步走，若重合则蛇尾不动，将蛇的身体信息全部向后移动一位</span></span><br><span class="line"><span class="comment">;清空上一次吃到食物的信息</span></span><br><span class="line"><span class="comment">;将当前食物位置存放在（bh,bl)中和（ah,al）比较</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">bh</span>,food_y	<span class="comment">;行</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,food_x	<span class="comment">;列</span></span><br><span class="line">	<span class="keyword">mov</span> food_eaten,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,snake_head_position_y</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_x</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line">	<span class="keyword">jnz</span> snake_judge_conflict_not_eat</span><br><span class="line">	<span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">bh</span></span><br><span class="line">	<span class="keyword">jnz</span> snake_judge_conflict_not_eat</span><br><span class="line">	<span class="comment">;下面时蛇吃了食物</span></span><br><span class="line">	<span class="keyword">mov</span> food_eaten,<span class="number">1</span></span><br><span class="line">	<span class="keyword">add</span> snake_body_length,<span class="number">1</span></span><br><span class="line"><span class="comment">;生成新的食物 位置为（7-当前蛇头x,7-当前蛇尾y)</span></span><br><span class="line"><span class="symbol">snake_create_new_food:</span></span><br><span class="line">	<span class="comment">;原来的食物不用灭，因为现在蛇头在这里</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,food_y</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,food_x</span><br><span class="line">	<span class="keyword">call</span> make_it_dark</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">7</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,snake_head_position_x</span><br><span class="line">	<span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">mov</span> food_x,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">7</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,snake_tail_position_y</span><br><span class="line">	<span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">mov</span> food_y,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">;蛇这一步没有吃到食物</span></span><br><span class="line"><span class="symbol">snake_judge_conflict_not_eat:</span></span><br><span class="line">	<span class="keyword">mov</span> food_eaten,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;判断是否碰撞到自己  头坐标(al,ah)   身体坐标（bl,bh）</span></span><br><span class="line"><span class="symbol">snake_judge_collision:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,snake_head_position_y</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_x</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset snake_body_buffer</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,snake_body_length</span><br><span class="line"><span class="symbol">snake_judge_collision_again:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">mov</span> <span class="number">bh</span>,[<span class="built_in">si</span>+<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">bh</span></span><br><span class="line">	<span class="keyword">jnz</span> snake_judge_collision_again_not_collision</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line">	<span class="keyword">jnz</span> snake_judge_collision_again_not_collision</span><br><span class="line">	<span class="comment">;碰撞了</span></span><br><span class="line"><span class="symbol">snake_judge_collision_again_collision:</span></span><br><span class="line">	<span class="keyword">mov</span> collision,<span class="number">1</span></span><br><span class="line">	<span class="keyword">jmp</span> snake_gluttony_end</span><br><span class="line"><span class="symbol">snake_judge_collision_again_not_collision:</span></span><br><span class="line">	<span class="keyword">loop</span> snake_judge_collision_again</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;在led点阵中点亮蛇阵 使用红色</span></span><br><span class="line"><span class="symbol">snake_lighten_led_red:</span></span><br><span class="line">	<span class="comment">;首先点亮食物</span></span><br><span class="line">	<span class="comment">;写入红色灯亮，ah为行号，al为列号 注意这里 （0，0）在左下角    即ah为y al为x</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,food_y</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,food_x</span><br><span class="line">	<span class="keyword">call</span> make_it_red</span><br><span class="line">	<span class="comment">;点亮头</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,snake_head_position_y</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_x</span><br><span class="line">	<span class="keyword">call</span> make_it_red</span><br><span class="line">	<span class="comment">;点亮身体  记得在更新身体的时候灭掉尾巴的灯</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset snake_body_buffer</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,snake_body_length</span><br><span class="line">	<span class="keyword">dec</span> <span class="built_in">cx</span></span><br><span class="line"><span class="symbol">snake_lighten_led_red_body:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,[<span class="built_in">si</span>+<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">call</span> make_it_red</span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">	<span class="keyword">loop</span> snake_lighten_led_red_body</span><br><span class="line"></span><br><span class="line">	<span class="keyword">jmp</span> snake_gluttony_begin</span><br><span class="line"></span><br><span class="line"><span class="symbol">snake_gluttony_end:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">snake_gluttony endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;延时 bx为传入的参数</span></span><br><span class="line">delay proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"><span class="symbol">again1_delay:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span> , <span class="number">0</span></span><br><span class="line"><span class="symbol">again2_delay:</span></span><br><span class="line">	<span class="keyword">nop</span></span><br><span class="line">	<span class="keyword">loop</span> again2_delay</span><br><span class="line">	<span class="keyword">dec</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">jnz</span> again1_delay</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">delay endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;短延时 bx为传入的参数 为了增加亮度</span></span><br><span class="line">delay_short proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"><span class="symbol">again1_delay_short:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span> , <span class="number">0ffh</span></span><br><span class="line"><span class="symbol">again2_delay_short:</span></span><br><span class="line">	<span class="keyword">nop</span></span><br><span class="line">	<span class="keyword">loop</span> again2_delay_short</span><br><span class="line">	<span class="keyword">dec</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">jnz</span> again1_delay_short</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">delay_short endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;8253 设置方式控制字为 00110100 计时器0先低后高方式二二进制 初值为 1000  连在1MHZ上  每10ms进行一次中断 out口接在主板irq上（主板irq已经固定在了irq10)</span></span><br><span class="line"></span><br><span class="line">set_int proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">cli</span></span><br><span class="line">	<span class="comment">;mov si,offset msgsetint</span></span><br><span class="line">	<span class="comment">;call dispstr </span></span><br><span class="line"><span class="comment">;设置8253 </span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28bh</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">00110110B</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">288h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1000</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;设置中断处理程序 irq10使用0B号中断</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">3572h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">mov</span> int_0b_seg,<span class="built_in">es</span></span><br><span class="line">	<span class="keyword">mov</span> int_0b_off,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">seg</span> int_irq10</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,offset int_irq10</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2572h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">	<span class="comment">;imr</span></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0a1h</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0fbh</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">0a1h</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;EOI</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">0a0h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">20h</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">sti</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">set_int endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;中断处理程序 每一次中断时10ms，这10ms用来扫描输入和同步时间量</span></span><br><span class="line">int_irq10 proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;mov si,offset msgintirq10</span></span><br><span class="line">	<span class="comment">;call dispstr</span></span><br><span class="line"><span class="comment">;设置时间量</span></span><br><span class="line">	<span class="keyword">add</span> sync_time_buffer,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;键盘输入  键盘可以用的话就用键盘吧</span></span><br><span class="line">	<span class="keyword">call</span> keyboard_input</span><br><span class="line"></span><br><span class="line"><span class="comment">;红外输入</span></span><br><span class="line">	<span class="comment">;call infrared_input</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;EOI</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">0a0h</span>,<span class="built_in">al</span></span><br><span class="line">	<span class="keyword">out</span> <span class="number">20h</span>,<span class="built_in">al</span></span><br><span class="line"><span class="symbol">int_irq10_end:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">iret</span></span><br><span class="line">int_irq10 endp</span><br><span class="line"></span><br><span class="line">dispstr proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"><span class="symbol">dps1:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jz</span> dps2</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0eh</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">jmp</span> dps1</span><br><span class="line"><span class="symbol">dps2:</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">dispstr endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_snake_info proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset msg_direction</span><br><span class="line">	<span class="keyword">call</span> dispstr</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_direction</span><br><span class="line">	<span class="keyword">call</span> dispuib</span><br><span class="line">	<span class="keyword">call</span> dispcrlf</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset msg_snake_body_position</span><br><span class="line">	<span class="keyword">call</span> dispstr</span><br><span class="line">	<span class="comment">;头</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_x</span><br><span class="line">	<span class="keyword">call</span> dispuib</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,snake_head_position_y</span><br><span class="line">	<span class="keyword">call</span> dispuib</span><br><span class="line">	<span class="comment">;身</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset snake_body_buffer</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,snake_body_length</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">shl</span> <span class="built_in">ax</span>,<span class="built_in">cl</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="symbol">snake_show_body_again:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">call</span> dispuib</span><br><span class="line">	<span class="keyword">loop</span> snake_show_body_again</span><br><span class="line"></span><br><span class="line">	<span class="keyword">call</span> dispcrlf</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">show_snake_info endp</span><br><span class="line"></span><br><span class="line"><span class="comment">;清屏</span></span><br><span class="line">clear_screen proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4000</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">si</span>,<span class="built_in">si</span></span><br><span class="line"><span class="symbol">clear_screen_again:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">si</span>],<span class="number">0</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">loop</span> clear_screen_again</span><br><span class="line"></span><br><span class="line">	<span class="comment">;入口参数：AH＝02H</span></span><br><span class="line">	<span class="comment">;BH＝显示页码</span></span><br><span class="line">	<span class="comment">;DH＝行(Y坐标)</span></span><br><span class="line">	<span class="comment">;DL＝ 列(X坐标)</span></span><br><span class="line">	<span class="comment">;设置光标位置</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">02h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">10h</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">clear_screen endp</span><br><span class="line"></span><br><span class="line">	end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>微机</category>
      </categories>
      <tags>
        <tag>微机</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>微机期末复习之知识总结</title>
    <url>/2021/06/26/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="微机期末复习之知识总结"><a href="#微机期末复习之知识总结" class="headerlink" title="微机期末复习之知识总结"></a>微机期末复习之知识总结</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="QUS"><a href="#QUS" class="headerlink" title="QUS"></a>QUS</h3><h4 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h4><ol>
<li>处理器字长：处理器单位时间内可以处理的二进制位数。</li>
<li>总线信号分为哪三种：数据总线、地址总线、控制总线</li>
<li>取指译码执行周期是指什么：从主存储器读取指令、翻译指令代码的功能、执行指令所需要的操作。</li>
</ol>
<h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><ol>
<li>IA-64结构是IA-32结构的64位扩展，也就是Intel64 结构？ <strong>×</strong></li>
<li>微机主存只要使用RAM芯片就足够了？    <strong>×</strong></li>
</ol>
<h4 id="大题"><a href="#大题" class="headerlink" title="大题"></a>大题</h4><ol>
<li>什么是通用微处理器、单片机（微控制器）、DSP芯片、嵌入式系统？<ol>
<li>通用微处理器：适合较广领域的微处理器芯片，例如装在笔记本上的。</li>
<li>单片机：是指通常用于控制领域的微处理器芯片，其内部除了CPU外还集成了计算机的主要部件，只需要配上少量外部电路和设备就可以工作。</li>
<li>DSP芯片：数字信号处理器，也是一种微控制器，其更加适合处理高速的数字信号，内部集成有告诉的乘法器，能够进行乘法和加法运算。</li>
<li>嵌入式系统：利用微控制器、数字信号处理器或者通用微处理器结核病具体应用构成的控制系统。</li>
</ol>
</li>
<li>区分：类路径、绝对路径、相对路径、当前目录。<ol>
<li>路径：操作系统以目录的形式管理磁盘上的文件，文件所在的分区和目录就是该文件的路径。</li>
<li>绝对路径：从根目录到文件所在的目录的完整的路径称为绝对路径，是保证文件唯一性的指示方法。</li>
<li>相对路径：从系统当前目录到文件所在目录的路径称为相对路径。</li>
<li>当前目录：用户当前所在的目录。</li>
</ol>
</li>
<li>冯诺依曼计算机的基本设计思想是什么？<ol>
<li>采用二进制表示数据和指令。指令由操作码和地址吗组成。</li>
<li>将程序和数据存放在存储器中，计算机在工作时从存储器中取出指令加以执行，自动完成计算任务。</li>
<li>指令的执行是顺序的，即按照指令在存储器中的存放顺序执行、程序分支由转移指令实现。</li>
<li>计算机由存储器、运算器、控制器、输入输出设备组成。</li>
</ol>
</li>
<li>计算机系统的层次。<blockquote>
<p>最长层是用户层。<br> 第五层是高级语言层。<br> 第四层是汇编语言层<br> 第三层是操作系统层<br> 第二层是机器语言层<br> 第一层是控制层<br> 第零层是数字电路层</p>
</blockquote>
</li>
</ol>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ol>
<li><p>指令执行过程</p>
<ol>
<li>取指：指令处理单元从主存中将指令取出并通过总线传输到处理器内部的指令寄存器中。</li>
<li>译码：指令处理单元通过指令译码电路获得该指令的功能。</li>
<li>执行：指令的处理单元的时序和控制逻辑按照一定的时间顺序接收响应的信号，完成至指令所要求的额操作。</li>
</ol>
</li>
<li><p>存储模型</p>
<ol>
<li>平展存储模型</li>
<li>段式存储模型</li>
<li>实地址存储模型</li>
</ol>
</li>
<li><p>16位模拟DOS平台开发环境代码框架</p>
</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">include io16<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">    .data</span></span><br><span class="line"><span class="comment">;数据</span></span><br><span class="line"><span class="meta">    .code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="comment">;主程序</span></span><br><span class="line">    exit0</span><br><span class="line"><span class="comment">;子程序</span></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h3 id="QUS-1"><a href="#QUS-1" class="headerlink" title="QUS"></a>QUS</h3><h4 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h4><ol>
<li>8086取指为什么可以被称为指令预取？<blockquote>
<p>8086分成总线接口单元和指令执行单元，可以独立操作。在执行单元执行一条指令的同时，总线接口单元可以读取下一条指令，等到执行的时候不用再进行取指了，所以称为预取。</p>
</blockquote>
</li>
<li>标志寄存器主要保存哪一些方面的信息？<blockquote>
<p>指令执行结果和控制指令的执行形式。</p>
</blockquote>
</li>
<li>除外设外的数据寻址方式有三类，分别为：立即数寻址、寄存器寻址、存储器寻址。</li>
<li>说明以下指令中源操作数的寻址方式。 VARD是一个双子变量。<table>
<thead>
<tr>
<th>指令</th>
<th>寻址方式</th>
</tr>
</thead>
<tbody><tr>
<td>mov edx,1234h</td>
<td>立即数</td>
</tr>
<tr>
<td>mov edx,VARD</td>
<td>直接</td>
</tr>
<tr>
<td>mov edx,ebx</td>
<td>寄存器</td>
</tr>
<tr>
<td>mov edx,[ebx]</td>
<td>寄存器间接</td>
</tr>
<tr>
<td>mov edx,[evx+1234h]</td>
<td>寄存器相对</td>
</tr>
<tr>
<td>mov edx,VARD[ebx]</td>
<td>寄存器相对</td>
</tr>
<tr>
<td>mov edx,[ebx+edi]</td>
<td>基址变址</td>
</tr>
<tr>
<td>mov edx,[ebx+edi+1234h]</td>
<td>相对基址变址</td>
</tr>
<tr>
<td>mov edx,VARD[esi+edi]</td>
<td>相对基址变址</td>
</tr>
<tr>
<td>mov edx,[ebp*4]</td>
<td>带比例寻址</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="第三章-第四章-汇编基础知识"><a href="#第三章-第四章-汇编基础知识" class="headerlink" title="第三章 第四章 汇编基础知识"></a>第三章 第四章 汇编基础知识</h2><h2 id="第五章-微机总线"><a href="#第五章-微机总线" class="headerlink" title="第五章 微机总线"></a>第五章 微机总线</h2><ol>
<li>微机以总线作为信息传输的公共通道。</li>
<li>总线结构的特点<ol>
<li>通过总线互相连接，实现数据传输。</li>
<li>组态灵活，易于扩展。</li>
</ol>
</li>
<li>总线类型<ol>
<li>芯片总线：在大规模集成电路内部进行芯片级互连。</li>
<li>内总线：模板级互连</li>
<li>外总线：设备级互连</li>
</ol>
</li>
<li>总线操作<ol>
<li>总线请求和仲裁：使用总线的主模块提出申请，总线仲裁机制确定把总线分配给请求模块。</li>
<li>寻址：主模块发出将要访问的从模块地址信息以及有关命令，启动从模块。</li>
<li>数据传送：源模块发出数据，经数据总线传送到目标模块。</li>
<li>结束：数据、地址、状态、命令信息均从总线上撤除，让出总线。</li>
</ol>
</li>
<li>同步方式<ol>
<li>同步时序：总线操作过程由公用的总线时钟信号控制，适合速度相当的设备。</li>
<li>总线的操作需要握手联络应答信号控制，开始伴有启动、选通或者读写信号。</li>
<li>传输的结束有一个确认信号，进行应答。</li>
<li>操作周期可变，适应速度相差很大的设备。</li>
</ol>
</li>
<li>总线的性能指标<ol>
<li>总线宽度：总线能够同时传送的数据位数。</li>
<li>总线频率：总线信号的时钟频率。</li>
<li>总线带宽：单位时间内传送的数据量。</li>
</ol>
</li>
<li>总线分类：地址总线、数据总线、控制总线。</li>
</ol>
<h3 id="QUS-2"><a href="#QUS-2" class="headerlink" title="QUS"></a>QUS</h3><h4 id="简答题-1"><a href="#简答题-1" class="headerlink" title="简答题"></a>简答题</h4><ol>
<li>为什么称处理器的数据总线是双向的？<blockquote>
<p>数据总线承担着处理器和存储器、外设之间的数据交换、既可以输入也可以输出。</p>
</blockquote>
</li>
<li>具有三态能力的引脚输出高阻意味着什么？<blockquote>
<p>相当于连接了一个阻抗很高的外部器件，信号无法正常输出，即放弃对于该引脚的额控制，断开其连接。</p>
</blockquote>
</li>
<li>总线时钟周期中的等待状态意味着什么？<blockquote>
<p>处理器检测到存储器或者IO端口速度太慢，不能按照基本的总线周期进行数据交换，插入一个等待状态Tw,保持总线信号不变。</p>
</blockquote>
</li>
<li>什么是猝发传送？<blockquote>
<p>处理器只提供首地址、但可以从后续连续地存储单元中读写多个数据。</p>
</blockquote>
</li>
<li>总线周期：<blockquote>
<p>总线请求和仲裁、寻址、数据传送、结束。</p>
</blockquote>
</li>
<li>处理器基本的总线操作：<blockquote>
<p>存储器读 存储器写 IO读 IO写</p>
</blockquote>
</li>
</ol>
<h4 id="大题-1"><a href="#大题-1" class="headerlink" title="大题"></a>大题</h4><ol>
<li>8086处理器输入控制信号有RESET,HOLD,NMI,INTR,他们的具体含义是什么？当他们有效时，8086CPU将做出什么反应。<ol>
<li>RESET：复位出入信号，高电平有效。有效时，迫使处理器回到其初始状态，转为无效时，处理器继续工作。</li>
<li>HOLD：总线请求，高电平有效。有效时，表示其他总线主控设备向处理器申请使用原来由处理器控制的总线。</li>
<li>NMI：不可屏蔽中断请求，是一个利用上升沿有效的输入信号。有效时表示外界正在向CPU申请不可屏蔽中断。</li>
<li>INTR：可屏蔽中断请求，高电平有效，有效时表示中断请求设备向CPU发出可屏蔽中断请求。</li>
</ol>
</li>
<li>区分概念：指令周期，总线周期（机器周期），时钟周期，T状态。<ol>
<li>指令周期：一条指令从取指译码到执行完成的过程。</li>
<li>总线周期（机器周期）：有数据交换的总线操作。</li>
<li>始终周期：处理器的基本工作节拍，由时钟信号产生，一个高电平一个低电平位一个周期。</li>
<li>完成特定操作的一个时钟周期。<ol>
<li>T1：总线周期的第一个时钟周期主要用于输出存储器或者IO地址。</li>
<li>T2：输出读/写控制信号。</li>
<li>T3：锁存地址、处理器提供的控制信号和数据再总线上继续维持有效，且T3时钟的前沿（下降沿）对READY引脚进行检测。若有效则进入T4。</li>
<li>T4：总线周期的最后一个时钟周期，处理器和存储器或者I/O端口进行数据传输直到完成，并为下一个时钟周期做好准备。</li>
<li>Tw：等待状态。T3时READY信号无效时，插入Tw，延续T3的状态，维持不变。</li>
</ol>
</li>
</ol>
</li>
<li>请解释8086（最小组态）以下引脚的含义：CLK, A19/S6～A16/S3，AD15～AD0, ALE,M/$\overline{\text{IO}}$, $\overline{\text{RD}}$, $\overline{\text{WR}}$。并画出其在一个具有等待状态的读总线周期的波形示意。<ol>
<li>CLK：时钟输入。其频率就是处理器工作的频率。</li>
<li>A19/S6～A16/S3：地址/状态时分复用引脚，在访问存储器的第一个时钟周期输出高四位地址A19～A16，在访问外设的第一个时钟周期输出低电平无效。其余时间输出状态信号S6～S3。</li>
<li>AD15～AD0：地址/数据时分复用引脚，用作地址线时是单项输出，用作数据线时时双向。</li>
<li>ALE：地址锁存允许，是一个三态、输出、高电平有效的信号。有效时，表示复用引脚A19/S6～A16/S3，AD15～AD0正在传输地址信号。</li>
<li>M/$\overline{\text{IO}}$：访问存储器或者IO，高电平为存储器（A19～A0），20位，低电平时为（A15～A0）16位IO端口。</li>
<li>$\overline{\text{RD}}$：读控制，低电平有效，表示正在读（存储器或者IO）</li>
<li>$\overline{\text{WR}}$：写控制，低电平有效，表示正在写（存储器或者IO）</li>
<li><img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/1.png" alt="图"></li>
</ol>
</li>
<li>时序<ol>
<li>同步时序：总线操作的各个过程由共用的总线时钟信号控制。</li>
<li>半同步时序：总线操作的各个过程由共用的总线时钟信号控制，但是慢的设备可以通过等待信号让快设备等待。</li>
<li>异步时序：总线操作需要握手联络应答信号控制，总线时钟信号可有可无。</li>
</ol>
</li>
</ol>
<h2 id="第六章-存储系统"><a href="#第六章-存储系统" class="headerlink" title="第六章 存储系统"></a>第六章 存储系统</h2><ol>
<li>ram</li>
</ol>
<table>
<thead>
<tr>
<th>RAM类型</th>
<th>组成单元</th>
<th>速度</th>
<th>集成度</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td>SRAM</td>
<td>触发器</td>
<td>快</td>
<td>低</td>
<td>小容量系统</td>
</tr>
<tr>
<td>DRAM</td>
<td>单个MOS管</td>
<td>慢</td>
<td>高</td>
<td>大容量系统</td>
</tr>
<tr>
<td>NVRAM</td>
<td>触发器</td>
<td>快</td>
<td>低</td>
<td>有后备电池</td>
</tr>
</tbody></table>
<ol start="2">
<li>cache地址映射方式<ol>
<li>直接映射：将一个主存块存储到唯一的cache行</li>
<li>全相联映射：将一个贮存快吧存储到任意一个cache行</li>
<li>组相联映射：将一个主存块存储到唯一一个cache组的任意一行。</li>
</ol>
</li>
<li>页表<ol>
<li>不详细说了，在os里面讲过</li>
</ol>
</li>
</ol>
<h3 id="QUS-3"><a href="#QUS-3" class="headerlink" title="QUS"></a>QUS</h3><h4 id="简答题-2"><a href="#简答题-2" class="headerlink" title="简答题"></a>简答题</h4><ol>
<li>什么时高速命中，什么时告诉缺失（未命中）？<ol>
<li>Cache中复制这主存中的部分内容。让处理器试图读取某一个字的时候，Cache控制器会首先检查Cache中是否已经包含这个字，若包含，则处理器直接读取Cache的内容，称为高速命中，反之，称为高速缺失。</li>
</ol>
</li>
<li>什么时Cache的地址映射？<ol>
<li>主存块和Cache行组之间的映射关系称为地址映射。分为直接映射，全相联映射，组相联映射。</li>
</ol>
</li>
<li>Cache写入策略用于解决什么问题？<ol>
<li>用于解决写入Cache时引起主存和Cache不一致的问题。</li>
</ol>
</li>
<li>存储器的存取时间和存取周期有什么区别？<ol>
<li>存储时间表示读写命令发出到数据传输完成所需要的时间，存储周期表示两次存储器访问所允许的最小时间间隔。</li>
</ol>
</li>
<li>DRAM芯片怎么既有行地址又有列地址？<ol>
<li>DRAM时分复用地址线，先传送行地址再传送列地址。</li>
</ol>
</li>
<li>译码分类<ol>
<li>全译码：使用全部地址总线进行译码，地址唯一，一个存储单元对应一个存储器地址。</li>
<li>部分译码：只是用部分地址总线进行译码，每有一个没有使用的地址信号就会有两种不同的编码指向同一个存储单元，出现地址重复。</li>
</ol>
</li>
<li>区分以下主存名称的含义。<ol>
<li>常规主存：再1MB空间中的第640KB系统RAM区称为常规主存或者基本主存。</li>
<li>扩展主存：IA-32处理器在1MB之后的主存空间称为扩展主存。</li>
<li>扩充主存：处理器不可以直接访问，利用体交换技术实现访问。</li>
<li>上位主存区UMA：在常规主存区后384K（A0000H～FFFFFH）称为UMA</li>
<li>上位主存块UMB：UMA没有使用的部分称为UMB</li>
<li>高端主存区HMA：1MB之上的64KB.</li>
<li>影子主存：PC机启动后可以将ROM-BIOS映射到RAM中，这部分用作RAM-BIOS的主存称为RAM，只读。</li>
</ol>
</li>
</ol>
<h4 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h4><ol>
<li>部分译码可以简化译码电路，且不会减少可用的存储空间。 <strong>×</strong></li>
<li>DRAM芯片上的所有单元同时刷新一次。<strong>×</strong></li>
<li>存储系统的刷新地址提供给所有的DRAM芯片。 <strong>√</strong></li>
</ol>
<h4 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h4><ol>
<li>对一个存储器芯片进行片选译码时，有一个高位系统地址信号没有参加译码，则该芯片扽每一个存储单元占有几个存储器地址？ <strong>ANS：2，2^1=2</strong></li>
<li>段描述符为<strong>0000B98200002000H</strong>，则段基地址为：<strong>00820000H</strong>  ，段界限为：<strong>02000</strong><ol>
<li><strong>段描述符的结构</strong></li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>位</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>高32位</td>
<td></td>
</tr>
<tr>
<td>31-24</td>
<td>段基址31-24</td>
</tr>
<tr>
<td>23</td>
<td>G</td>
</tr>
<tr>
<td>22</td>
<td>D/B</td>
</tr>
<tr>
<td>21</td>
<td>L</td>
</tr>
<tr>
<td>20</td>
<td>AVL</td>
</tr>
<tr>
<td>19-16</td>
<td>段界限19-16</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
</tr>
<tr>
<td>14-13</td>
<td>DPL</td>
</tr>
<tr>
<td>12</td>
<td>S</td>
</tr>
<tr>
<td>11-8</td>
<td>TYPE</td>
</tr>
<tr>
<td>7-0</td>
<td>段基址23-16</td>
</tr>
<tr>
<td>低32位</td>
<td></td>
</tr>
<tr>
<td>31-16</td>
<td>段基址15-0</td>
</tr>
<tr>
<td>15-0</td>
<td>段界限15-0</td>
</tr>
</tbody></table>
<h4 id="大题-2"><a href="#大题-2" class="headerlink" title="大题"></a>大题</h4><ol>
<li><img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/2.png" alt="图"></li>
</ol>
<h2 id="第七章-输入输出接口"><a href="#第七章-输入输出接口" class="headerlink" title="第七章 输入输出接口"></a>第七章 输入输出接口</h2><ol>
<li><p>I/O接口概述：<br> 微机的外设多种多样，工作原理、驱动方式、信息格式、工作速度千差万别，他们不可以直接和cpu相连接，必须通过中间电路（I/O）接口电路与系统连接。I/O接口就是位于基本系统和外设之间实现两者数据交换的控制电路。其基本功能有数据缓冲和信号变换。</p>
</li>
<li><p>主机和外设输送数据的方式</p>
<ol>
<li>无条件传送</li>
<li>查询</li>
<li>中断</li>
<li>DMA</li>
<li>专门的额IO处理机</li>
</ol>
</li>
<li><p>8259A的中断处理流程</p>
<ol>
<li><p>当某个外设发出一个中断信号后，由于主板已经把信号通路指向了8259A芯片的某个IRQ接口，所以该中断信号会被送入8259A。8259A先检查IMR寄存器是否屏蔽了来自该IRQ接口的中断信号，该为为1表示被屏蔽了。</p>
</li>
<li><p>将中断信号送入IRR寄存器，将该IRQ接口所在的IRR寄存器对应的位置1.</p>
</li>
<li><p>PR从IRR寄存器中挑选一个优先级最大的一个中断（IRQ接口号最低的）。</p>
</li>
<li><p>通过INT接口向CPU发送INTR信号。</p>
</li>
<li><p>CPU完成一条指令后，通过自己的INTA接口向8259A的INTA接口发送中断响应信号。</p>
</li>
<li><p>8259A收到CPU的中断响应信号后，将刚刚挑选出的优先级最大的中断在ISR寄存器中对应的位置1，表示正在处理当前中断，同时在IRR中该中断位置0。</p>
</li>
<li><p>CPU再次发送INTA信号，要求获取中断向量号。<strong>如果EIO被设置为自动的话，则8259A自动将ISR对应位置0，表示中断结束，否则需要手动发送EOI信号</strong></p>
</li>
<li><p>8259A向CPU发送中断向量号。<strong>此时如果来了一个优先级更高的中断，则将该中断替换上去，将被替换下来的中断重新装入IRR中</strong></p>
</li>
<li><p>CPU从数据总线上拿到中断向量号止之后，用作中断向量表或者中断描述符表的索引，转到对应的中断处理程序执行。</p>
</li>
</ol>
</li>
<li><p>设置中断的程序框架</p>
 <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;获取系统原80号向量的地址  es:bx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">3580H</span> </span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="keyword">mov</span> int80seg,<span class="built_in">es</span></span><br><span class="line"><span class="keyword">mov</span> int80off,<span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;设置新的向量</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ds</span> <span class="comment">;保存ds</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">seg</span> new80</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>,offset new80</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2580h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ds</span> <span class="comment">;恢复ds</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;设置IMR</span></span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">21h</span> <span class="comment">;这是主片，从片使用0a1h</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0feh</span><span class="comment">; 允许哪一位就设置哪一位为零。</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">21h</span>,<span class="built_in">al</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;恢复原中断</span></span><br><span class="line"><span class="comment">;和设置一样，不在赘述</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;中断程序的书写</span></span><br><span class="line"><span class="comment">;记得开中断</span></span><br><span class="line"><span class="comment">;记得发送EOI指令</span></span><br><span class="line">new80 proc</span><br><span class="line"><span class="keyword">sti</span> <span class="comment">;开中断</span></span><br><span class="line"><span class="comment">;保护寄存器和中断程序处理</span></span><br><span class="line"><span class="comment">;EOI</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">20h</span>,<span class="built_in">al</span><span class="comment">;主片</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">0a0h</span>,<span class="built_in">al</span><span class="comment">;从片</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new80 endp</span><br></pre></td></tr></table></figure></li>
<li><p>中断程序驻留内存</p>
 <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;dx中存放要驻留程序的长度（以16字节为单位)</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">dx</span>,<span class="number">15</span></span><br><span class="line"><span class="keyword">shr</span> <span class="built_in">dx</span>,<span class="number">4</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">3100h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="QUS-4"><a href="#QUS-4" class="headerlink" title="QUS"></a>QUS</h3><h4 id="简答题-3"><a href="#简答题-3" class="headerlink" title="简答题"></a>简答题</h4><ol>
<li>外设为什么不能和处理器之间相连？<ol>
<li>微机的外设多种多样，工作原理、驱动方式、信息格式、工作速度千差万别，他们不可以直接和cpu相连接，必须通过中间电路（I/O）接口电路与系统连接。</li>
</ol>
</li>
<li>计算机的两个功能部件、设备之间为什么一般需要数据缓冲？<ol>
<li>数据缓冲用于匹配快速的处理器和相对慢速度额外设或者两个功能部件速度不匹配的数据交换。</li>
</ol>
</li>
<li>什么时电路的命令字或者控制字？<ol>
<li>处理器向特定的接口板芯片的吧相应端口写入特定的数据用于选择IO芯片的工作方式或者控制外设工作，该数据称为命令字或者控制字。</li>
</ol>
</li>
<li>为什么说外部中断才是真正意义上的中断？<ol>
<li>玩不终端是由处理器外部提出的中断请求引起的程序中断，对于处理器来说，外部中断时随机产生的，所以才是真正意义上的中断。</li>
</ol>
</li>
<li>IO接口电路的寄存器分类？<ol>
<li>数据寄存器：保存处理器和外设之间交换的数据。</li>
<li>状态寄存器：保存外设当前的工作状态信息。</li>
<li>控制寄存器：保存处理器控制接口电路和外设进行操作的有关信息。处理器向控制寄存器写入信息选择接口电路的不同工作方式和与外设交换信息的数据格式。</li>
</ol>
</li>
<li>简述主机和外设交换数据的几种方式。<ol>
<li>无条件传送：最简单的数据传送，认为设备总是处于就绪状态。</li>
<li>程序查询方式：处理器查询外设的状态，在外设就绪的时候进行数据传输。</li>
<li>中断，外设就绪的时候通过请求引脚信号，主动向处理器提出交换数据的请求，处理器没有其他更加紧迫的任务就执行中断程序。</li>
<li>DMA传送：DMA控制器可以接管总线，作为总线的主控设备，通过系统总线来控制存储器和外设直接进行数据交换。</li>
</ol>
</li>
<li>以可屏蔽中断为例，说明一次完成的中断过程包括哪一些环节？<ol>
<li>中断请求。</li>
<li>中断响应。</li>
<li>关中断。</li>
<li>断点保护</li>
<li>中断源识别</li>
<li>现场保护。</li>
<li>中断服务</li>
<li>回复现场。</li>
<li>开中断</li>
<li>中断返回。</li>
</ol>
</li>
</ol>
<h4 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h4><ol>
<li><p>编程<br> <img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/3.png" alt="图"><br><img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/4.png" alt="图"><br>由图可知，开关时低电平有效（代表闭合），灯是高电平有效（代表亮），端口地址为8000</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">again:</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">8000H</span></span><br><span class="line">     <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">     <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">11111110B</span> <span class="comment">;k0单独按下</span></span><br><span class="line">     <span class="keyword">jz</span> next0</span><br><span class="line">     <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">11111101B</span> <span class="comment">;k1单独按下</span></span><br><span class="line">     <span class="keyword">jz</span> next1</span><br><span class="line">     <span class="keyword">jmp</span> again</span><br><span class="line"><span class="symbol"> next0:</span></span><br><span class="line">     <span class="comment">;顺序点亮</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line"><span class="symbol"> next11:</span></span><br><span class="line">     <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">     <span class="keyword">call</span> delay</span><br><span class="line">     <span class="keyword">shl</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line">     <span class="keyword">loop</span> next11</span><br><span class="line"> <span class="keyword">jmp</span> again</span><br><span class="line"><span class="symbol"> next1:</span></span><br><span class="line">     <span class="comment">;倒序点亮</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10000000B</span></span><br><span class="line"><span class="symbol"> next11:</span></span><br><span class="line">     <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">     <span class="keyword">call</span> delay</span><br><span class="line">     <span class="keyword">shr</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line">     <span class="keyword">loop</span> enxt11</span><br><span class="line"> <span class="keyword">jmp</span> again</span><br></pre></td></tr></table></figure></li>
<li><p>编程<br> <img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/5.png" alt="图"></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>编程<br> <img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/6.png" alt="图"></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第八章-常用接口电路"><a href="#第八章-常用接口电路" class="headerlink" title="第八章 常用接口电路"></a>第八章 常用接口电路</h2><h3 id="8253-8254"><a href="#8253-8254" class="headerlink" title="8253/8254"></a>8253/8254</h3><h4 id="控制字"><a href="#控制字" class="headerlink" title="控制字"></a>控制字</h4><p><img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/7.png" alt="图"></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li>定时中断  计数器0方式3 每秒产生计数器初值次的请求 <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;计数器0，先低后高, 方式3，二进制</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">00110110b</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">43h</span>,<span class="built_in">al</span>  <span class="comment">;方式控制字</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">40h</span>,<span class="built_in">al</span>  <span class="comment">;低</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">40h</span>,<span class="built_in">al</span>  <span class="comment">;高</span></span><br></pre></td></tr></table></figure></li>
<li>定时刷新 使用计数器1方式2 产生可自动重新计时的中断进行刷新 <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;计数器1，低字节，方式二，二进制</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">01010100b</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">43h</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">41h</span>,<span class="built_in">al</span></span><br></pre></td></tr></table></figure></li>
<li>扬声器控制 计数器2 方式3  <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ax</span>=<span class="number">1193180</span>/发声频率</span><br><span class="line"><span class="comment">;计数器2 先低后高 方式3 二进制</span></span><br><span class="line"><span class="comment">;写入计时器</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10110110b</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">43h</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">42h</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">42h</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;发声 </span></span><br><span class="line"><span class="comment">;读取61H端口，使得PB1 PB0=11</span></span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">61H</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">00000011b</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">61h</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;闭声 </span></span><br><span class="line"><span class="comment">;读取61H端口，使得PB1 PB0=00</span></span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">61H</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11111100b</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">61h</span>,<span class="built_in">al</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="8255"><a href="#8255" class="headerlink" title="8255"></a>8255</h3><h4 id="控制字-1"><a href="#控制字-1" class="headerlink" title="控制字"></a>控制字</h4><p><img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/8.png" alt="图"><br><img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/9.png" alt="图"></p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ol>
<li><p>8255端口A使用方式0输出打印数据<br> <img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/10.png" alt="图"></p>
 <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;初始化程序</span></span><br><span class="line"><span class="comment">;端口A为方式0输出，端口C（PC7）上部分和A一样，下部分为输入（PC2）。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0fffeh</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">10000001b</span></span><br><span class="line"><span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"><span class="comment">;初始使得打印机不打印 即 STROBE 高电平</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">00001111b</span></span><br><span class="line"><span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;子程序 入口参数 AH为打印数据</span></span><br><span class="line">printc proc</span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;查询PC2，看打印机是否忙 1为忙</span></span><br><span class="line"><span class="symbol">wait:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0fffch</span></span><br><span class="line">    <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">    <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00000100b</span></span><br><span class="line">    <span class="keyword">jnz</span> wait</span><br><span class="line">    <span class="comment">;不忙，则输出数据</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0fff8h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">    <span class="comment">;使得STROBE=0 低电平有效，进行打印数据</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0fffeh</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">00001110b</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">ax</span></span><br><span class="line">    <span class="comment">;适当延时 维持低电平有效</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line">    <span class="comment">;打印完了一个数据，使STROBE=1 无效</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0fffeh</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">00001111b</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">peintc endp</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>8255端口A使用方式1输出打印数据<br> <img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/11.png" alt="图"></p>
 <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">    <span class="comment">;初始化</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0fffeh</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">10100000b</span> <span class="comment">;不知道为什么 PC6也要为输出</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">;禁止中断 PC6=0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">00001100b</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">;子程序 入口参数 AH为打印数据</span></span><br><span class="line">    printc proc</span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">print:</span></span><br><span class="line">    <span class="comment">;输出数据</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0fff8h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">;判断 PC7==0？</span></span><br><span class="line"><span class="symbol">wait:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0fffch</span></span><br><span class="line">    <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">    <span class="keyword">test</span> <span class="built_in">al</span>,<span class="number">10000000b</span></span><br><span class="line">    <span class="keyword">jz</span> wait</span><br><span class="line">    <span class="comment">;PC7==1 继续打印</span></span><br><span class="line">    <span class="keyword">jmp</span> print</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">    peintc endp</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="数码管"><a href="#数码管" class="headerlink" title="数码管"></a>数码管</h3><ol>
<li>数码管分为段码和位码。注意判断是共阴极还是共阳极，前者为低电平有效，后者为高电平有效。</li>
</ol>
<h4 id="数码管的使用"><a href="#数码管的使用" class="headerlink" title="数码管的使用"></a>数码管的使用</h4><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> 	include io<span class="number">.</span><span class="keyword">inc</span></span><br><span class="line"><span class="meta">	.model</span> small</span><br><span class="line"><span class="meta">	.stack</span></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line">leddt <span class="built_in">byte</span> <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line">ledtb <span class="built_in">byte</span> <span class="number">3fh</span>,<span class="number">06h</span>,<span class="number">5bh</span>,<span class="number">4fh</span>,<span class="number">66h</span>,<span class="number">6dh</span>,<span class="number">7dh</span>,<span class="number">07h</span>,<span class="number">7fh</span>,<span class="number">6fh</span></span><br><span class="line"><span class="meta">	.code</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,@data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;8255 method cotrol word</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">28bh</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10000000b</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">     </span><br><span class="line"><span class="symbol">again:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,offset leddt</span><br><span class="line">	<span class="keyword">call</span> displed</span><br><span class="line">	<span class="keyword">jmp</span> again</span><br><span class="line"><span class="meta">	.exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">displed proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">bx</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="comment">;which light </span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">00001000b</span></span><br><span class="line"><span class="symbol">led1:</span></span><br><span class="line">	<span class="comment">;pa</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bl</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,ledtb[<span class="built_in">bx</span>]</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">288h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;pb which light to light</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">289h</span></span><br><span class="line">	<span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">;delay</span></span><br><span class="line">	<span class="keyword">call</span> delay</span><br><span class="line">	<span class="comment">;next light</span></span><br><span class="line">	<span class="keyword">ror</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">	<span class="comment">;all lights light,exit and begin nest round</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">10000000b</span></span><br><span class="line">	<span class="keyword">jnz</span> led1</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">displed endp</span><br><span class="line">	</span><br><span class="line">time=<span class="number">20</span></span><br><span class="line">delay proc</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,time</span><br><span class="line"><span class="symbol">delay1:</span></span><br><span class="line">	<span class="keyword">xor</span> <span class="built_in">cx</span>,<span class="built_in">cx</span></span><br><span class="line"><span class="symbol">delay2:</span></span><br><span class="line">	<span class="keyword">loop</span> delay2</span><br><span class="line">	<span class="keyword">dec</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">jnz</span> delay1</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">delay endp</span><br><span class="line">	end start</span><br></pre></td></tr></table></figure>

<h3 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h3><ol>
<li>中断方式<br><img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/12.png" alt="图"></li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;启动ADC</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">220h</span></span><br><span class="line"><span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol start="2">
<li>查询方式<br> 见实验代码</li>
</ol>
<h3 id="QUS-5"><a href="#QUS-5" class="headerlink" title="QUS"></a>QUS</h3><h4 id="判断题-1"><a href="#判断题-1" class="headerlink" title="判断题"></a>判断题</h4><ol>
<li>8255没有时钟信号，其工作方式1的数据传送采用异步传送。 <strong>√</strong></li>
<li>调制解调器的信号调制是数字信号和模拟信号的转换，所以其转换原理与ADC或者DAC器件一样。 <strong>×</strong></li>
</ol>
<h4 id="大题-3"><a href="#大题-3" class="headerlink" title="大题"></a>大题</h4><ol>
<li><p>偏移码</p>
<ol>
<li>符号位取反的补码。</li>
</ol>
</li>
<li><p>如图<br><img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/13.png" alt="图"></p>
</li>
<li><p>如图<br><img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/14.png" alt="图"><br><img src="/file/%E5%BE%AE%E6%9C%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/15.png" alt="图"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>期末复习</category>
        <category>微机</category>
      </categories>
      <tags>
        <tag>微机</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 四 二叉查找树</title>
    <url>/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%9B-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p><strong>二叉查找树是一个有序的树，使用二叉查找树可以极大的方便查找排好序的元素</strong></p>
<p>二叉查找树保证其中每一个结点的右子树都比他大，左子树都比他小，即左小右大。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。</p>
<p><strong>前驱</strong></p>
<p>在中序遍历中排在某元素前面的那个元素是该元素的前驱，当然第一个元素是没有前驱的。在数组型的二叉树中，前驱就放在其前面。<br>寻找前驱的算法如下：<br>    1. 若一个结点有左子树，则左子树的最右侧即为所求前驱。（也就是左边的最大值）<br>    2. 若没有左子树，则从这个结点向上遍历，直到找到某个结点是其父节点的右子树，则这个结点的父节点即为所求。所不存在则说明没有前驱。</p>
<p><strong>后继</strong></p>
<p>在中序遍历中排在某元素后面的那个元素是该元素的后继，当然最后一个元素是没有后继的。在数组型的二叉树中，后继就放在其后面。<br>寻找后继的算法如下：<br>    1. 若一个结点有右子树，则右子树的最左侧即为所求前驱。（也就是右边的最小值）<br>    2. 若没有右子树，则从这个结点向上遍历，直到找到某个结点是其父节点的左子树，则这个结点的父节点即为所求。所不存在则说明没有后继。</p>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><ol>
<li>构造空树</li>
<li>销毁一个树</li>
<li>判断树是否为空</li>
<li>插入一个结点</li>
<li>删除一个结点</li>
<li>打印二叉树</li>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>根据值的大小查找结点。</li>
<li>查找子树的最小结点</li>
<li>查找子树的最大结点</li>
<li>查找某个结点的前驱</li>
<li>查找某个结点的后继</li>
</ol>
<h2 id="二叉查找树的实现"><a href="#二叉查找树的实现" class="headerlink" title="二叉查找树的实现"></a>二叉查找树的实现</h2><h3 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉查找树</span></span><br><span class="line"><span class="comment">// binary search tree</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key; <span class="comment">//可以用Item代替，不过为了方便学习，就不这样了。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTree</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTree</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTree</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; * BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitBSTree</span><span class="params">(BSTree *tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyBSTree</span><span class="params">(BSTree *tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EmptyBSTree</span><span class="params">(BSTree *tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertBSTree</span><span class="params">(BSTree *tree, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteBSTree</span><span class="params">(BSTree *tree, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印二叉树 0代表根节点 1代表左边 -1代表右</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_BSTree</span><span class="params">(BSTree *tree, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder_BSTree</span><span class="params">(BSTree *tree)</span></span>;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder_BSTree</span><span class="params">(BSTree *tree)</span></span>;</span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder_BSTree</span><span class="params">(BSTree *tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Search_BSTree</span><span class="params">(BSTree *tree, <span class="keyword">int</span> key, BSTree *tree_save)</span></span>;</span><br><span class="line"><span class="comment">// (非递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">iterative_bstree_search</span><span class="params">(BSTree *tree, <span class="keyword">int</span> key, BSTree *tree_save)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最小结点：返回tree为根结点的二叉树的最小结点。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Min_BSTree</span><span class="params">(BSTree *tree, BSTree *tree_save)</span></span>;</span><br><span class="line"><span class="comment">// 查找最大结点：返回tree为根结点的二叉树的最大结点。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Max_BSTree</span><span class="params">(BSTree *tree, BSTree *tree_save)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Sucessor_BSTree</span><span class="params">(BSTree *tree, BSTree *x, BSTree *sucessor)</span></span>;</span><br><span class="line"><span class="comment">// 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Predecessor_BSTree</span><span class="params">(BSTree *tree, BSTree *x, BSTree *prede)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AutoFillBSTree</span><span class="params">(BSTree *tree, <span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bstree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitBSTree</span><span class="params">(BSTree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*tree) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyBSTree</span><span class="params">(BSTree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*tree) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*tree)-&gt;left == <span class="literal">NULL</span> &amp;&amp; (*tree)-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(tree);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DestroyBSTree(&amp;((*tree)-&gt;left));</span><br><span class="line">        DestroyBSTree(&amp;((*tree)-&gt;right));</span><br><span class="line">        <span class="keyword">if</span> ((*tree) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;销毁成功\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;销毁失败\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*tree) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;销毁成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EmptyBSTree</span><span class="params">(BSTree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*tree) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertBSTree</span><span class="params">(BSTree *tree, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree <span class="keyword">new</span> = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BSTree));</span><br><span class="line">    <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line">    <span class="keyword">new</span>-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//左低右高</span></span><br><span class="line">    <span class="keyword">if</span> (EmptyBSTree(tree))</span><br><span class="line">    &#123;</span><br><span class="line">        (*tree) = <span class="keyword">new</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入成功 %d\n&quot;</span>, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//寻找位置进行插入；</span></span><br><span class="line">        BSTree p = (*tree);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//小 往左走</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;key &lt; p-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//左边为空，则插入到左边即可</span></span><br><span class="line">                    p-&gt;left = <span class="keyword">new</span>;</span><br><span class="line">                    <span class="keyword">new</span>-&gt;parent = p;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;插入成功 %d 到 %d 的左边\n&quot;</span>, key, p-&gt;key);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//左边不空，继续寻找</span></span><br><span class="line">                    p = p-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//大 往右走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;key &gt; p-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//右边为空，则插入到右边即可</span></span><br><span class="line">                    p-&gt;right = <span class="keyword">new</span>;</span><br><span class="line">                    <span class="keyword">new</span>-&gt;parent = p;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;插入成功 %d 到 %d 的右边\n&quot;</span>, key, p-&gt;key);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//右边不空，继续寻找</span></span><br><span class="line">                    p = p-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;key == p-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;不允许相等的元素存在,插入失败\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteBSTree</span><span class="params">(BSTree *tree, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除的是根节点 删除叶子节点 删除的结点没有左子树或者右子树</span></span><br><span class="line">    <span class="comment">//空</span></span><br><span class="line">    <span class="keyword">if</span> (EmptyBSTree(tree))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BSTree p = (*tree);</span><br><span class="line">    <span class="comment">//p指向树的每一个结点（其实就是相应内存区域），改变 p-&gt;key，就是改变这块内存上key的值。所以才可以实现使用p遍历并更改结点。</span></span><br><span class="line">    <span class="comment">//其实，p-&gt;key==(*p).key  对(*p).key很自然就修改了其值，这点很容易理解。</span></span><br><span class="line">    <span class="comment">//假设这棵树在一个树的左边  解决删除的是根节点的问题</span></span><br><span class="line">    BSTree fakeroot = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BSTree));</span><br><span class="line">    fakeroot-&gt;left = p;</span><br><span class="line">    fakeroot-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    fakeroot-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;parent = fakeroot;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;key == (*p).key)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;true\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;1111111111111111111111\n&quot;);</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;key &lt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//向右走</span></span><br><span class="line">            <span class="comment">//printf(&quot;向右走\n&quot;);</span></span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;key &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">            <span class="comment">//printf(&quot;向左走\n&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;key == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到了，进行删除 p</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到了，进行删除 p %d\n&quot;</span>, p-&gt;key);</span><br><span class="line">            BSTree l = p-&gt;left;</span><br><span class="line">            BSTree r = p-&gt;right;</span><br><span class="line">            <span class="comment">//p为左子树</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;parent-&gt;left == p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//p没有左子树</span></span><br><span class="line">                <span class="keyword">if</span> ((l == <span class="literal">NULL</span>) &amp;&amp; (r != <span class="literal">NULL</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;parent-&gt;left = r;</span><br><span class="line">                    r-&gt;parent = p-&gt;parent;</span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                    p = <span class="literal">NULL</span>;</span><br><span class="line">                    (*tree) = fakeroot-&gt;left;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//p没有右子树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((r == <span class="literal">NULL</span>) &amp;&amp; (l != <span class="literal">NULL</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;parent-&gt;left = l;</span><br><span class="line">                    l-&gt;parent = p-&gt;parent;</span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                    p = <span class="literal">NULL</span>;</span><br><span class="line">                    (*tree) = fakeroot-&gt;left;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//p左右子树都有</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((r != <span class="literal">NULL</span>) &amp;&amp; (l != <span class="literal">NULL</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//p为左节点，应为右侧的高 继位</span></span><br><span class="line">                    p-&gt;parent-&gt;left = r;</span><br><span class="line">                    <span class="comment">//将l插入到r的最左下</span></span><br><span class="line">                    <span class="keyword">while</span> (r-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        r = r-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//找到了右子树的最左边，插入左子树</span></span><br><span class="line">                    r-&gt;left = l;</span><br><span class="line">                    l-&gt;parent = r;</span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                    p = <span class="literal">NULL</span>;</span><br><span class="line">                    (*tree) = fakeroot-&gt;left;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左右子树都没有</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;parent-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                    p = <span class="literal">NULL</span>;</span><br><span class="line">                    (*tree) = fakeroot-&gt;left;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//p为右子树</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将 右子树顶替p的位置，然后将左子树插入到右子树的最左下面即可，因为右边比左边大。</span></span><br><span class="line">                <span class="comment">//p为右节点，应为左侧的低 继位</span></span><br><span class="line">                <span class="comment">//p没有左子树</span></span><br><span class="line">                <span class="keyword">if</span> ((l == <span class="literal">NULL</span>) &amp;&amp; (r != <span class="literal">NULL</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;parent-&gt;right = r;</span><br><span class="line">                    r-&gt;parent = p-&gt;parent;</span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                    p = <span class="literal">NULL</span>;</span><br><span class="line">                    (*tree) = fakeroot-&gt;left;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//p没有右子树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((r == <span class="literal">NULL</span>) &amp;&amp; (l != <span class="literal">NULL</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;parent-&gt;right = l;</span><br><span class="line">                    l-&gt;parent = p-&gt;parent;</span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                    p = <span class="literal">NULL</span>;</span><br><span class="line">                    (*tree) = fakeroot-&gt;left;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//p左右子树都有</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((r != <span class="literal">NULL</span>) &amp;&amp; (l != <span class="literal">NULL</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;parent-&gt;right = l;</span><br><span class="line">                    <span class="keyword">while</span> (l-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        l = l-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//找到了右子树的最左边，插入左子树</span></span><br><span class="line">                    l-&gt;right = r;</span><br><span class="line">                    r-&gt;parent = l;</span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                    p = <span class="literal">NULL</span>;</span><br><span class="line">                    (*tree) = fakeroot-&gt;left;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左右子树都没有</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;parent-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                    p = <span class="literal">NULL</span>;</span><br><span class="line">                    (*tree) = fakeroot-&gt;left;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;没有找到这个元素，删除失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印二叉树 0代表根节点 -1代表左边 1代表右</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_BSTree</span><span class="params">(BSTree *tree, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree p = *tree;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根节点</span></span><br><span class="line">        <span class="keyword">if</span> (direction == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;结点 %2d 为根节点\n&quot;</span>, p-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;结点 %2d 为结点 %2d 的left\n&quot;</span>, p-&gt;key, p-&gt;parent-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;结点 %2d 为结点 %2d right\n&quot;</span>, p-&gt;key, p-&gt;parent-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">        Print_BSTree(&amp;(p-&gt;left), <span class="number">-1</span>);</span><br><span class="line">        Print_BSTree(&amp;(p-&gt;right), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder_BSTree</span><span class="params">(BSTree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree p = (*tree);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;key);</span><br><span class="line">        Preorder_BSTree(&amp;(p-&gt;left));</span><br><span class="line">        Preorder_BSTree(&amp;(p-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder_BSTree</span><span class="params">(BSTree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree p = (*tree);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Inorder_BSTree(&amp;(p-&gt;left));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;key);</span><br><span class="line">        Inorder_BSTree(&amp;(p-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder_BSTree</span><span class="params">(BSTree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree p = (*tree);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Postorder_BSTree(&amp;(p-&gt;left));</span><br><span class="line">        Postorder_BSTree(&amp;(p-&gt;right));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Search_BSTree</span><span class="params">(BSTree *tree, <span class="keyword">int</span> key, BSTree *tree_save)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree p = (*tree);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//*tree_save = NULL;</span></span><br><span class="line">        <span class="comment">//printf(&quot;没找到\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;key == key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//找到了</span></span><br><span class="line">        *tree_save = p;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Search_BSTree(&amp;(p-&gt;left), key, tree_save);</span><br><span class="line">    Search_BSTree(&amp;(p-&gt;right), key, tree_save);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (非递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">iterative_bstree_search</span><span class="params">(BSTree *tree, <span class="keyword">int</span> key, BSTree *tree_save)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree p = (*tree);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;key == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到了</span></span><br><span class="line">            (*tree_save) = p;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到了\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;key &lt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//往右走</span></span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;key &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没找到</span></span><br><span class="line">    (*tree_save) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;没找到\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最小结点：返回tree为根结点的二叉树的最小结点。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Min_BSTree</span><span class="params">(BSTree *tree, BSTree *tree_save)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree p = (*tree);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *tree_save = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    *tree_save = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找最大结点：返回tree为根结点的二叉树的最大结点。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Max_BSTree</span><span class="params">(BSTree *tree, BSTree *tree_save)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree p = (*tree);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *tree_save = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    *tree_save = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前驱节点：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的前一个节点为该节点的前驱节点；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后继节点：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的后一个节点为该节点的后继节点；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Sucessor_BSTree</span><span class="params">(BSTree *tree, BSTree *x, BSTree *sucessor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//即其右子树的最左边</span></span><br><span class="line">    <span class="keyword">if</span> ((*x) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空结点，没有后继\n&quot;</span>);</span><br><span class="line">        (*sucessor) = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有右子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((*x)-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Min_BSTree(&amp;((*x)-&gt;right), sucessor);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了后继，%d 的后继为 %d \n&quot;</span>, (*x)-&gt;key, (*sucessor)-&gt;key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有右子树 则从此开始向上找一个是左结点的结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((*x)-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BSTree p = *x;</span><br><span class="line">        <span class="comment">//从x往上查，直到有一个结点是左节点  则该左节点的父节点为所求</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;parent != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;parent-&gt;left == p)</span><br><span class="line">            &#123;</span><br><span class="line">                *sucessor = p-&gt;parent;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;找到了后继，%d 的后继为 %d \n&quot;</span>, (*x)-&gt;key, (*sucessor)-&gt;key);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p此时已经是root了，还没有找到说明那个结点没有后继。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;结点 %d 没有后继\n&quot;</span>, (*x)-&gt;key);</span><br><span class="line">        (*sucessor) = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Predecessor_BSTree</span><span class="params">(BSTree *tree, BSTree *x, BSTree *prede)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*x == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空结点，没有前驱\n&quot;</span>);</span><br><span class="line">        *prede = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左子树 则寻找其左子树的最大值</span></span><br><span class="line">    <span class="keyword">if</span> ((*x)-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Max_BSTree(&amp;((*x)-&gt;left), prede);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了前驱，%d 的前驱为 %d \n&quot;</span>, (*x)-&gt;key, (*prede)-&gt;key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有左子树，则向上寻找一个是其父节点的右子树的结点。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((*x)-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BSTree p = *x;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;parent != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;parent-&gt;right == p)</span><br><span class="line">            &#123;</span><br><span class="line">                *prede = p-&gt;parent;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;找到了前驱，%d 的前驱为 %d \n&quot;</span>, (*x)-&gt;key, (*prede)-&gt;key);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p此时已经是root了，还没有找到说明那个结点没有前驱。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;结点 %d 没有前驱\n&quot;</span>, (*x)-&gt;key);</span><br><span class="line">        (*prede) = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AutoFillBSTree</span><span class="params">(BSTree *tree, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InsertBSTree(tree, <span class="number">5</span>);</span><br><span class="line">    InsertBSTree(tree, <span class="number">4</span>);</span><br><span class="line">    InsertBSTree(tree, <span class="number">6</span>);</span><br><span class="line">    InsertBSTree(tree, <span class="number">2</span>);</span><br><span class="line">    InsertBSTree(tree, <span class="number">3</span>);</span><br><span class="line">    InsertBSTree(tree, <span class="number">1</span>);</span><br><span class="line">    InsertBSTree(tree, <span class="number">8</span>);</span><br><span class="line">    InsertBSTree(tree, <span class="number">7</span>);</span><br><span class="line">    InsertBSTree(tree, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        BSTree sucessor = <span class="literal">NULL</span>;</span><br><span class="line">        BSTree x = <span class="literal">NULL</span>;</span><br><span class="line">        Search_BSTree(tree, i, &amp;x);</span><br><span class="line">        Sucessor_BSTree(tree, &amp;x, &amp;sucessor);</span><br><span class="line">        <span class="keyword">if</span> (sucessor != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;succor: %d\n&quot;</span>, sucessor-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        BSTree prede = <span class="literal">NULL</span>;</span><br><span class="line">        BSTree x = <span class="literal">NULL</span>;</span><br><span class="line">        Search_BSTree(tree, i, &amp;x);</span><br><span class="line">        Predecessor_BSTree(tree, &amp;x, &amp;prede);</span><br><span class="line">        <span class="keyword">if</span> (prede != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;succor: %d\n&quot;</span>, prede-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bstree.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree tree;</span><br><span class="line">    InitBSTree(&amp;tree);</span><br><span class="line">    <span class="comment">//DestroyBSTree(&amp;tree);</span></span><br><span class="line">    AutoFillBSTree(&amp;tree, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n前序遍历: &quot;</span>);</span><br><span class="line">    Preorder_BSTree(&amp;tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n中序遍历: &quot;</span>);</span><br><span class="line">    Inorder_BSTree(&amp;tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n后序遍历: &quot;</span>);</span><br><span class="line">    Postorder_BSTree(&amp;tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    Print_BSTree(&amp;tree, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>CDB</title>
    <url>/2021/07/20/CDB/</url>
    <content><![CDATA[<h1 id="CDB"><a href="#CDB" class="headerlink" title="CDB"></a>CDB</h1><p>我想学习数据结构，最好的方式就是使用数据结构的知识做出一个系统，而我认为对于目前的我来讲，最好的选择就是做一个小型的数据库引擎。取名为<strong>CDB</strong></p>
<p>学习GitHub上的<a href="https://cstack.github.io/db_tutorial/">这个</a>项目。</p>
<h2 id="第一步-数据库的交互框架"><a href="#第一步-数据库的交互框架" class="headerlink" title="第一步 数据库的交互框架"></a>第一步 数据库的交互框架</h2><p>数据库工作的流程为：<br>    1. 打印提示符接受输入<br>    2. 解析输入，得到真实的命令<br>    3. 将解析得到的语义进行数据库底层操作<br>    4. 数据库底层操作很复杂，现在还不懂，懂了再加上</p>
<p>所以首先我们需要解析每一次的输入，并解析为程序可以读懂的信息，根据解析结果进行进一步操作。</p>
<p>所以我们需要一个缓冲区来存储输入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* buffer;</span><br><span class="line">    <span class="keyword">size_t</span> buffer_length;</span><br><span class="line">    <span class="keyword">size_t</span> input_length;</span><br><span class="line">&#125;InputBuffer;</span><br></pre></td></tr></table></figure>

<p>在得到每一次的输入之后还首先需要进行<strong>元命令判断</strong>其结果使用enum进行选择。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    META_COMMAND_EXIT,</span><br><span class="line">    META_COMMAND_SUCCESS,</span><br><span class="line">    META_COMMAND_UNRECOGNIZED_COMMAND</span><br><span class="line">&#125;MetaCommandResult;</span><br></pre></td></tr></table></figure>

<p>元命令目前分为两类，以类是以 <strong>.</strong> 开头的非SQL命令，另一类位SQL命令。</p>
<p>进行元命令判断之后进行处理，目前只有退出一项。</p>
<p>与元命令并行的是SQL命令的处理，其不以 <strong>.</strong> 开头。同理，这种命令的处理也存在几种状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PREPARE_SUCCESS,</span><br><span class="line">	PREPARE_SYNTAX_ERROR,</span><br><span class="line">	PREPARE_UNRECOGNIZED_STATEMENT</span><br><span class="line">&#125; PrepareResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	STATEMENT_INSERT,</span><br><span class="line">	STATEMENT_SELECT</span><br><span class="line">&#125; StatementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	StatementType type;</span><br><span class="line">	Row row_to_insert;</span><br><span class="line">&#125; Statement;</span><br></pre></td></tr></table></figure>

<p>程序预处理SQL命令得到这样的状态，根据状态来执行真正的SQL命令。</p>
<p>以上就是数据库的交互框架，就是一个巨大的状态机，虽然我不是很喜欢状态机，可是目前能力不足，只能使用状态机来实现了。希望以后做一个不使用状态机的大项目。</p>
<p>这一步的程序被覆盖掉了。</p>
<h2 id="第二步-数据库的简单插入操作"><a href="#第二步-数据库的简单插入操作" class="headerlink" title="第二步 数据库的简单插入操作"></a>第二步 数据库的简单插入操作</h2><p>这一步要实现数据库与底层的互连，打通和底层内存间的交互。实现简单的insert和使用select打印出数据表。这里全部使用硬编码。</p>
<p>下面讲一下数据库的底层安排。</p>
<p>table使用一个简单的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ROW</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> id;</span><br><span class="line">	<span class="keyword">char</span> username[COLUMN_USERNAME_SIZE];</span><br><span class="line">	<span class="keyword">char</span> email[COLUMN_EMAIL_SIZE];</span><br><span class="line">&#125; Row;</span><br><span class="line"><span class="comment">//Table</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> num_rows;</span><br><span class="line">	<span class="keyword">void</span>* pages[TABLE_MAX_PAGES];</span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure>

<p>将一张表分为数个page，这里的page和操作系统提供的分页机制相吻合，都是4KB大小，这样可以从操作系统层面上提高数据库的效率。在预处理中已经将命令的参数存入一行中了。（statement-&gt;row),现在需要获得数据要存入的内存地址和存入该内存地址的方法。</p>
<p>分配内存：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Row* <span class="title">row_slot</span><span class="params">(Table* table, <span class="keyword">uint32_t</span> row_num)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> page_num = row_num / ROWS_PER_PAGE;</span><br><span class="line">	<span class="keyword">void</span>* page = table-&gt;pages[page_num];</span><br><span class="line">	<span class="keyword">if</span> (page == <span class="literal">NULL</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Allocate memory only when we try to access page</span></span><br><span class="line">		page = table-&gt;pages[page_num] = <span class="built_in">malloc</span>(PAGE_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">uint32_t</span> row_offset = row_num % ROWS_PER_PAGE;</span><br><span class="line">	<span class="keyword">uint32_t</span> byte_offset = row_offset * ROW_SIZE;</span><br><span class="line">	<span class="comment">//之所以报 “必须是指向完整类型”的错，是因为指针指向类型不确定，则其单位不确定，加上byte_offset后也不知道到底指向哪一块内存。</span></span><br><span class="line">	<span class="comment">//由于 byte_offset 是字节单位，所以page页要变为指向8位内存的指针。所以转化位 uint8_t</span></span><br><span class="line">	<span class="keyword">return</span> (Row*)((<span class="keyword">uint8_t</span>*)page + byte_offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数返回一个指向要插入的内存地址的指针。</p>
<p>插入内存：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将行的信息存储到内存中</span></span><br><span class="line"><span class="comment">//A void pointer can hold address of any type and can be typcasted to any type</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serialize_row</span><span class="params">(Row* source, Row* destination)</span> </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">// ID_SIZE 指的是字节数</span></span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)destination + ID_OFFSET, &amp;(source-&gt;id), ID_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)destination + USERNAME_OFFSET, &amp;(source-&gt;username), USERNAME_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)destination + EMAIL_OFFSET, &amp;(source-&gt;email), EMAIL_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将destination从<strong>row*</strong> 转换为 **(uint8_t*)**来将其单位转化为字节，这样下面加上各个属性的offset之后就正确地指向对应地内存位置了。第三个参数代表赋值地字节数。这里终于意识到c语言指针地强大之处了。</p>
<p>同理该有一个相反地函数用于输出数据:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deserialize_row</span><span class="params">(Row* source, Row* destination)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;(destination-&gt;id), (<span class="keyword">uint8_t</span>*)source + ID_OFFSET, ID_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;(destination-&gt;username), (<span class="keyword">uint8_t</span>*)source + USERNAME_OFFSET, USERNAME_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;(destination-&gt;email), (<span class="keyword">uint8_t</span>*)source + EMAIL_OFFSET, EMAIL_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样与内存的底层交互就完成了，现在只需要得到offset即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLUMN_USERNAME_SIZE 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLUMN_EMAIL_SIZE 255</span></span><br><span class="line"><span class="comment">//表中最大页数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABLE_MAX_PAGES 100</span></span><br><span class="line"><span class="comment">//页的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="comment">//定义宏获取size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size_of_attribute(Struct, Attribute) sizeof(((Struct*)0)-&gt;Attribute)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取行中每一个元素的size和offset</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> ID_SIZE = <span class="built_in">size_of_attribute</span>(Row, id);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> USERNAME_SIZE = <span class="built_in">size_of_attribute</span>(Row, username);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> EMAIL_SIZE = <span class="built_in">size_of_attribute</span>(Row, email);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> ID_OFFSET = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> USERNAME_OFFSET = <span class="number">0</span> + <span class="built_in">size_of_attribute</span>(Row, id);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> EMAIL_OFFSET = <span class="number">0</span> + <span class="built_in">size_of_attribute</span>(Row, id) + <span class="built_in">size_of_attribute</span>(Row, username);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> ROW_SIZE = <span class="built_in">size_of_attribute</span>(Row, id) + <span class="built_in">size_of_attribute</span>(Row, username) + <span class="built_in">size_of_attribute</span>(Row, email);</span><br><span class="line"><span class="comment">//每一页有多少行</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> ROWS_PER_PAGE = PAGE_SIZE /(<span class="built_in">size_of_attribute</span>(Row, id) + <span class="built_in">size_of_attribute</span>(Row, username) + <span class="built_in">size_of_attribute</span>(Row, email));</span><br><span class="line"><span class="comment">//一张表里面最大行数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> TABLE_MAX_ROWS = PAGE_SIZE / (<span class="built_in">size_of_attribute</span>(Row, id) + <span class="built_in">size_of_attribute</span>(Row, username) + <span class="built_in">size_of_attribute</span>(Row, email)) * TABLE_MAX_PAGES;</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="CDB-h"><a href="#CDB-h" class="headerlink" title="CDB.h"></a>CDB.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLUMN_USERNAME_SIZE 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLUMN_EMAIL_SIZE 255</span></span><br><span class="line"><span class="comment">//表中最大页数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABLE_MAX_PAGES 100</span></span><br><span class="line"><span class="comment">//页的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="comment">//定义宏获取size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size_of_attribute(Struct, Attribute) sizeof(((Struct*)0)-&gt;Attribute)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入缓冲</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span>* buffer;</span><br><span class="line">	<span class="comment">// _int64</span></span><br><span class="line">	<span class="keyword">size_t</span> buffer_length;</span><br><span class="line">	<span class="keyword">size_t</span> input_length;</span><br><span class="line">&#125; InputBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断输入得到的命令状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	META_COMMAND_EXIT,</span><br><span class="line">	META_COMMAND_SUCCESS,</span><br><span class="line">	META_COMMAND_UNRECOGNIZED_COMMAND</span><br><span class="line">&#125; MetaCommandResult;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理得到的状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PREPARE_SUCCESS,</span><br><span class="line">	PREPARE_NEGATIVE_ID,</span><br><span class="line">	PREPARE_SYNTAX_ERROR,</span><br><span class="line">	PREPARE_STRING_TOO_LONG,</span><br><span class="line">	PREPARE_TOO_MANY_PARAMETER,</span><br><span class="line">	PREPARE_UNRECOGNIZED_STATEMENT</span><br><span class="line">&#125; PrepareResult;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理后的状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	EXECUTE_SUCCESS,</span><br><span class="line">	EXECUTE_TABLE_FULL</span><br><span class="line">&#125;ExecuteResult;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到的输入的表达式的状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	STATEMENT_INSERT,</span><br><span class="line">	STATEMENT_SELECT</span><br><span class="line">&#125; StatementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义 一行 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> id;</span><br><span class="line">	<span class="comment">//加一是因为c语言需要最后一个字符为0，所以可用字符就减一了。</span></span><br><span class="line">	<span class="comment">//不过即使这样也还需要在输入的时候判断是否大小超界</span></span><br><span class="line">	<span class="keyword">char</span> username[COLUMN_USERNAME_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">char</span> email[COLUMN_EMAIL_SIZE + <span class="number">1</span>];</span><br><span class="line">&#125; Row;</span><br><span class="line"></span><br><span class="line"><span class="comment">//statement</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	StatementType type;</span><br><span class="line">	Row row_to_insert;</span><br><span class="line">&#125; Statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取行中每一个元素的size和offset</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> ID_SIZE = <span class="built_in">size_of_attribute</span>(Row, id);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> USERNAME_SIZE = <span class="built_in">size_of_attribute</span>(Row, username);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> EMAIL_SIZE = <span class="built_in">size_of_attribute</span>(Row, email);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> ID_OFFSET = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> USERNAME_OFFSET = <span class="number">0</span> + <span class="built_in">size_of_attribute</span>(Row, id);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> EMAIL_OFFSET = <span class="number">0</span> + <span class="built_in">size_of_attribute</span>(Row, id) + <span class="built_in">size_of_attribute</span>(Row, username);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> ROW_SIZE = <span class="built_in">size_of_attribute</span>(Row, id) + <span class="built_in">size_of_attribute</span>(Row, username) + <span class="built_in">size_of_attribute</span>(Row, email);</span><br><span class="line"><span class="comment">//每一页有多少行</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> ROWS_PER_PAGE = PAGE_SIZE / (<span class="built_in">size_of_attribute</span>(Row, id) + <span class="built_in">size_of_attribute</span>(Row, username) + <span class="built_in">size_of_attribute</span>(Row, email));</span><br><span class="line"><span class="comment">//一张表里面最大行数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> TABLE_MAX_ROWS = PAGE_SIZE / (<span class="built_in">size_of_attribute</span>(Row, id) + <span class="built_in">size_of_attribute</span>(Row, username) + <span class="built_in">size_of_attribute</span>(Row, email)) * TABLE_MAX_PAGES;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一张表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> num_rows;</span><br><span class="line">	<span class="keyword">void</span>* pages[TABLE_MAX_PAGES];</span><br><span class="line">&#125; Table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个input_buffer</span></span><br><span class="line"><span class="function">InputBuffer* <span class="title">new_input_buffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//打印命令提示符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_prompt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取一行的输入，以换行符为终结</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">getline</span><span class="params">(<span class="keyword">char</span>** buffer, <span class="keyword">size_t</span>* n)</span></span>;</span><br><span class="line"><span class="comment">//读取输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_input</span><span class="params">(InputBuffer* input_buffer)</span></span>;</span><br><span class="line"><span class="comment">//关闭输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_input_buffer</span><span class="params">(InputBuffer* input_buffer)</span></span>;</span><br><span class="line"><span class="comment">// 判断是何种命令</span></span><br><span class="line"><span class="function">MetaCommandResult <span class="title">do_meta_command</span><span class="params">(InputBuffer* input_buffer)</span></span>;</span><br><span class="line"><span class="comment">//预处理结果</span></span><br><span class="line"><span class="function">PrepareResult <span class="title">prepare_statement</span><span class="params">(InputBuffer* input_buffer, Statement* statement)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_trim</span><span class="params">(InputBuffer* input_buffer)</span></span>;</span><br><span class="line"><span class="function">PrepareResult <span class="title">prepare_insert</span><span class="params">(InputBuffer* input_buffer, Statement* statement)</span></span>;</span><br><span class="line"><span class="comment">//执行命令 根据 statement 来执行相应的命令</span></span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_statement</span><span class="params">(Statement* statement, Table* table)</span></span>;</span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_insert</span><span class="params">(Statement* statement, Table* table)</span></span>;</span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_select</span><span class="params">(Statement* statement, Table* table)</span></span>;</span><br><span class="line"><span class="comment">//将行的信息存储到内存中</span></span><br><span class="line"><span class="comment">//A void pointer can hold address of any type and can be typcasted to any type</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serialize_row</span><span class="params">(Row* source, Row* destination)</span></span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deserialize_row</span><span class="params">(Row* source, Row* destination)</span></span>;</span><br><span class="line"><span class="comment">//插入前判断插入的内存位置 以及适时分配内存 </span></span><br><span class="line"><span class="function">Row* <span class="title">row_slot</span><span class="params">(Table* table, <span class="keyword">uint32_t</span> row_num)</span></span>;</span><br><span class="line"><span class="function">Table* <span class="title">new_table</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_table</span><span class="params">(Table* table)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_row</span><span class="params">(Row* row)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="CDB-c"><a href="#CDB-c" class="headerlink" title="CDB.c"></a>CDB.c</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//在最前面加上这个宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CDB.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">InputBuffer* <span class="title">new_input_buffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	InputBuffer* input_buffer = (InputBuffer*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(InputBuffer));</span><br><span class="line">	<span class="keyword">if</span> (input_buffer)</span><br><span class="line">	&#123;</span><br><span class="line">		input_buffer-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line">		input_buffer-&gt;buffer_length = <span class="number">0</span>;</span><br><span class="line">		input_buffer-&gt;input_length = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> input_buffer;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_prompt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;CDB &gt;&gt; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一行的输入，以换行符为终结</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">getline</span><span class="params">(<span class="keyword">char</span>** buffer, <span class="keyword">size_t</span>* n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">size_t</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//一行最多不超过80个字符</span></span><br><span class="line">	<span class="keyword">uint32_t</span> COLUMN_MAX_SIZE = COLUMN_USERNAME_SIZE + COLUMN_EMAIL_SIZE + <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">char</span>* buffer_temp = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(COLUMN_MAX_SIZE * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="keyword">if</span> (buffer_temp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &amp;&amp; c != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		*(buffer_temp + bytes_read++) = c;</span><br><span class="line">		<span class="keyword">if</span> (bytes_read == COLUMN_MAX_SIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;too long\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	*buffer = buffer_temp;</span><br><span class="line">	<span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_input</span><span class="params">(InputBuffer* input_buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// void 对于所有类型都非法 </span></span><br><span class="line">	<span class="comment">// 返回读取得到的字节数量</span></span><br><span class="line">	<span class="keyword">size_t</span> bytes_read = <span class="built_in">getline</span>(&amp;(input_buffer-&gt;buffer), &amp;(input_buffer-&gt;buffer_length));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf(&quot;这次读取到的字节数量为 %llu\n&quot;, bytes_read);</span></span><br><span class="line">	<span class="keyword">if</span> (bytes_read &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error reading input\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ignore trailing newline    </span></span><br><span class="line">	input_buffer-&gt;input_length = bytes_read;</span><br><span class="line">	input_buffer-&gt;buffer[bytes_read] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_input_buffer</span><span class="params">(InputBuffer* input_buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(input_buffer-&gt;buffer);</span><br><span class="line">	<span class="built_in">free</span>(input_buffer);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;关闭输入\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是何种命令</span></span><br><span class="line"><span class="function">MetaCommandResult <span class="title">do_meta_command</span><span class="params">(InputBuffer* input_buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//退出</span></span><br><span class="line">		<span class="keyword">return</span> META_COMMAND_EXIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.q&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//退出</span></span><br><span class="line">		<span class="keyword">return</span> META_COMMAND_EXIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.v&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//显示当前版本</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CDB version 0.1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//不可解析</span></span><br><span class="line">		<span class="keyword">return</span> META_COMMAND_UNRECOGNIZED_COMMAND;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理，就是前缀命令识别</span></span><br><span class="line"><span class="function">PrepareResult <span class="title">prepare_statement</span><span class="params">(InputBuffer* input_buffer, Statement* statement)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">prepare_trim</span>(input_buffer);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;insert&quot;</span>, <span class="number">6</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">prepare_insert</span>(input_buffer, statement);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;select&quot;</span>, <span class="number">6</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		statement-&gt;type = STATEMENT_SELECT;</span><br><span class="line">		<span class="keyword">return</span> PREPARE_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> PREPARE_UNRECOGNIZED_STATEMENT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//预处理的预处理 去掉多余的空格</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_trim</span><span class="params">(InputBuffer* input_buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* temp = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(input_buffer-&gt;buffer) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="keyword">char</span>* p1 = temp;</span><br><span class="line">	<span class="keyword">char</span>* p2 = input_buffer-&gt;buffer;</span><br><span class="line">	<span class="comment">//首先去掉前面的空格</span></span><br><span class="line">	<span class="keyword">while</span> ((*p2) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//现在p2指向真正的命令起始</span></span><br><span class="line">	<span class="comment">//去掉文本中间多余的空格</span></span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> ((*p2) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (((*p2) == <span class="string">&#x27; &#x27;</span>) &amp;&amp; (flag == <span class="literal">true</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			*p1 = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			p1++;</span><br><span class="line">			p2++;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((*p2) != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*p1 = *p2;</span><br><span class="line">			p1++;</span><br><span class="line">			p2++;</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p2++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//此时 p1 指向最后，需要变为0</span></span><br><span class="line">	*p1 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">free</span>(input_buffer-&gt;buffer);</span><br><span class="line">	input_buffer-&gt;buffer = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PrepareResult <span class="title">prepare_insert</span><span class="params">(InputBuffer* input_buffer, Statement* statement)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	statement-&gt;type = STATEMENT_INSERT;</span><br><span class="line">	<span class="comment">//这里应该可以去掉开头的空格，目前还不可以</span></span><br><span class="line">	<span class="keyword">char</span>* keyword = <span class="built_in">strtok</span>(input_buffer-&gt;buffer, <span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">char</span>* id_string = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">char</span>* username = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">char</span>* email = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">char</span>* test_parameter = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (id_string == <span class="literal">NULL</span> || username == <span class="literal">NULL</span> || email == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> PREPARE_SYNTAX_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (test_parameter != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> PREPARE_TOO_MANY_PARAMETER;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> id = <span class="built_in">atoi</span>(id_string);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(username) &gt; COLUMN_USERNAME_SIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> PREPARE_STRING_TOO_LONG;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(email) &gt; COLUMN_EMAIL_SIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> PREPARE_STRING_TOO_LONG;</span><br><span class="line">	&#125;</span><br><span class="line">	statement-&gt;row_to_insert.id = id;</span><br><span class="line">	<span class="built_in">strcpy</span>(statement-&gt;row_to_insert.username, username);</span><br><span class="line">	<span class="built_in">strcpy</span>(statement-&gt;row_to_insert.email, email);</span><br><span class="line">	<span class="keyword">return</span> PREPARE_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行命令</span></span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_statement</span><span class="params">(Statement* statement, Table* table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (statement-&gt;type)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">case</span></span> (STATEMENT_INSERT):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">execute_insert</span>(statement, table);</span><br><span class="line">	<span class="built_in"><span class="keyword">case</span></span> (STATEMENT_SELECT):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">execute_select</span>(statement, table);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_insert</span><span class="params">(Statement* statement, Table* table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (table-&gt;num_rows &gt;= TABLE_MAX_ROWS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> EXECUTE_TABLE_FULL;</span><br><span class="line">	&#125;</span><br><span class="line">	Row* row_to_insert = &amp;(statement-&gt;row_to_insert);</span><br><span class="line">	<span class="comment">//将一行存入内存</span></span><br><span class="line">	<span class="built_in">serialize_row</span>(row_to_insert, <span class="built_in">row_slot</span>(table, table-&gt;num_rows));</span><br><span class="line">	table-&gt;num_rows += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> EXECUTE_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_select</span><span class="params">(Statement* statement, Table* table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Row row;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; table-&gt;num_rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//解析出一行</span></span><br><span class="line">		<span class="built_in">deserialize_row</span>(<span class="built_in">row_slot</span>(table, i), &amp;row);</span><br><span class="line">		<span class="built_in">print_row</span>(&amp;row);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EXECUTE_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将行的信息存储到内存中</span></span><br><span class="line"><span class="comment">//A void pointer can hold address of any type and can be typcasted to any type</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serialize_row</span><span class="params">(Row* source, Row* destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ID_SIZE 指的是字节数</span></span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)destination + ID_OFFSET, &amp;(source-&gt;id), ID_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)destination + USERNAME_OFFSET, &amp;(source-&gt;username), USERNAME_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)destination + EMAIL_OFFSET, &amp;(source-&gt;email), EMAIL_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deserialize_row</span><span class="params">(Row* source, Row* destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;(destination-&gt;id), (<span class="keyword">uint8_t</span>*)source + ID_OFFSET, ID_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;(destination-&gt;username), (<span class="keyword">uint8_t</span>*)source + USERNAME_OFFSET, USERNAME_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;(destination-&gt;email), (<span class="keyword">uint8_t</span>*)source + EMAIL_OFFSET, EMAIL_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入前判断插入的内存位置 以及适时分配内存 </span></span><br><span class="line"><span class="function">Row* <span class="title">row_slot</span><span class="params">(Table* table, <span class="keyword">uint32_t</span> row_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> page_num = row_num / ROWS_PER_PAGE;</span><br><span class="line">	<span class="keyword">void</span>* page = table-&gt;pages[page_num];</span><br><span class="line">	<span class="keyword">if</span> (page == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Allocate memory only when we try to access page</span></span><br><span class="line">		page = table-&gt;pages[page_num] = <span class="built_in">malloc</span>(PAGE_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">uint32_t</span> row_offset = row_num % ROWS_PER_PAGE;</span><br><span class="line">	<span class="keyword">uint32_t</span> byte_offset = row_offset * ROW_SIZE;</span><br><span class="line">	<span class="comment">//之所以报 “必须是指向完整类型”的错，是因为指针指向类型不确定，则其单位不确定，加上byte_offset后也不知道到底指向哪一块内存。</span></span><br><span class="line">	<span class="comment">//由于 byte_offset 是字节单位，所以page页要变为指向8位内存的指针。所以转化位 uint8_t</span></span><br><span class="line">	<span class="keyword">return</span> (Row*)((<span class="keyword">uint8_t</span>*)page + byte_offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Table* <span class="title">new_table</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Table* table = (Table*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Table));</span><br><span class="line">	table-&gt;num_rows = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; TABLE_MAX_PAGES; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		table-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_table</span><span class="params">(Table* table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; table-&gt;pages[i]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(table-&gt;pages[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(table);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_row</span><span class="params">(Row* row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;| id: %u username: %s email: %s |\n&quot;</span>, row-&gt;id, row-&gt;username, row-&gt;email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CDB.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Table* table = <span class="built_in">new_table</span>();</span><br><span class="line">	InputBuffer* input_buffer = <span class="built_in">new_input_buffer</span>();</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">print_prompt</span>();</span><br><span class="line">		<span class="built_in">read_input</span>(input_buffer);</span><br><span class="line">		<span class="comment">//判断是否有输入，若是回车直接 continue</span></span><br><span class="line">		<span class="keyword">if</span> (input_buffer-&gt;input_length == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//以 . 开头则为非 sql 命令</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (input_buffer-&gt;buffer[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">do_meta_command</span>(input_buffer))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//退出</span></span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (META_COMMAND_EXIT):</span><br><span class="line">				<span class="comment">//printf(&quot;META_COMMAND_EXIT&quot;);</span></span><br><span class="line">				<span class="built_in">close_input_buffer</span>(input_buffer);</span><br><span class="line">				<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//此命令可以解析</span></span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (META_COMMAND_SUCCESS):</span><br><span class="line">				<span class="comment">//printf(&quot;META_COMMAND_SUCCESS&quot;);</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//命令不可解析</span></span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (META_COMMAND_UNRECOGNIZED_COMMAND):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Unrecognized command &#x27;%s&#x27;\n&quot;</span>, input_buffer-&gt;buffer);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//sql命令</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (input_buffer-&gt;buffer[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//进行预处理  即判断 insert create 等命令</span></span><br><span class="line">			Statement statement;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">prepare_statement</span>(input_buffer, &amp;statement))</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (PREPARE_SUCCESS):</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (PREPARE_STRING_TOO_LONG):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;String is too long.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span>(PREPARE_NEGATIVE_ID):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;your id id negative.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span>(PREPARE_TOO_MANY_PARAMETER):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;too many parameter.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (PREPARE_UNRECOGNIZED_STATEMENT):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Unrecognized keyword at start of &#x27;%s&#x27;.\n&quot;</span>, input_buffer-&gt;buffer);</span><br><span class="line">				<span class="comment">//break 会break switch本身， 而continue 会continue 上一层，而忽略掉 switch</span></span><br><span class="line">				<span class="comment">//这里直接continue 到while(true)</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span>(PREPARE_SYNTAX_ERROR):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Syntax error. Could not parse statement.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">execute_statement</span>(&amp;statement, table))</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (EXECUTE_SUCCESS):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Executed.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (EXECUTE_TABLE_FULL):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Error: Table full.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三步-保存到硬盘"><a href="#第三步-保存到硬盘" class="headerlink" title="第三步 保存到硬盘"></a>第三步 保存到硬盘</h2><p>这一步，我们要将内存中的数据库存入磁盘中。</p>
<h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><p>首先从程序入口处得知数据库的文件名，当前一个数据库只有一张表，一个文件。即这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Must supply a database filename.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>* filename = argv[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行如下定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储page   这里page和table的关系也说明了一张表可以使用很多文件来存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> file_descriptor;</span><br><span class="line">	<span class="keyword">uint32_t</span> file_length;</span><br><span class="line">	<span class="keyword">void</span>* pages[TABLE_MAX_PAGES];</span><br><span class="line">&#125; Pager;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一张表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> num_rows;</span><br><span class="line">	Pager* pager;</span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure>

<p>一个表内包含一个pager用来管理数据库中的page，另外还需要存储数据库中的条目数量。一个pager就是一个文件的索引，负责存储对应的文件句柄，并且存储pages,一张表可以用有很多个pager,一个pager存储一个文件，这样就可以让一张表使用多个文件来存储了。另外，这里pager用到了操作系统中缓存的概念，其中每一个page都指向内存中的一块区域，但是如果对应的page没有在内存中（NULL）就需要进行内存和和硬盘的交换。</p>
<h3 id="初始化table-amp-amp-pager"><a href="#初始化table-amp-amp-pager" class="headerlink" title="初始化table &amp;&amp; pager"></a>初始化table &amp;&amp; pager</h3><p>程序要连接数据库，因为目前数据库中只有一张表故连接这一张表就好。所以 <strong>db_open</strong> 自然就是 <strong>table_open</strong>. </p>
<p>table中的pager需要先进行初始化，然后利用pager中的file_length就可以得到table中的 num_rows.</p>
<p>对于pager,首先需要根据上层传来的filename打开文件，然后根据文件信息算出来 file_length, 由此得出 page的数量，根据数量将 void* pages[TABLE_MAX_PAGES]; 全部指向null,因为当前内存中含没有任何数据库数据。</p>
<p>这杨初始化的工作就完成了。</p>
<h3 id="内存替换"><a href="#内存替换" class="headerlink" title="内存替换"></a>内存替换</h3><p>这里实现了一个简单的抽象内存管理模块，入口：pager page_num  出口：在内存中找到或者开辟一块page区域，并以指针的形式返回。</p>
<p>加入要使用的页（根据页号来判断）不在内存中则发生缺页中断，这时在内存中开辟一个页空间，并且判断磁盘中是否有该页（根据该页号和磁盘中的页数量作比较），若有的话则读取磁盘内容填充该页的内容，若没有的话则什么都不做直接饭返回这个空页即可。</p>
<p>这样就在内存中得到了想要的页。</p>
<p>同理，反过来在结束程序的时候还需要将内存中更新的页和磁盘中的相同步。</p>
<h3 id="程序抽象"><a href="#程序抽象" class="headerlink" title="程序抽象"></a>程序抽象</h3><p>现在使用光标进行程序的抽象，即使用光标标识某一个行，使用一个函数获取该光标真实表示的行（在内存中），当然，若内存中本就不存在的话则使用上面提到的内存替换策略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一张表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> num_rows;</span><br><span class="line">	Pager* pager;</span><br><span class="line">&#125; Table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//光标指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Table* table;</span><br><span class="line">	<span class="keyword">uint32_t</span> row_num;</span><br><span class="line">	<span class="keyword">bool</span> end_of_table;  <span class="comment">// Indicates a position one past the last element</span></span><br><span class="line">&#125; Cursor;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入前判断插入的内存位置 以及适时分配内存 光标指针的作用就是指示某个table中的某一行，并表明该行是否为最后一行。</span></span><br><span class="line"><span class="comment">//入口：一个光标指针   出口：指向内存中光标指针对应行的指针</span></span><br><span class="line"><span class="function">Row* <span class="title">cursor_value</span><span class="params">(Cursor* cursor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> row_num = cursor-&gt;row_num;</span><br><span class="line">	<span class="keyword">uint32_t</span> page_num = row_num / ROWS_PER_PAGE;</span><br><span class="line">	<span class="comment">//算出来吧光标指针指向哪一个page  并获取这一页</span></span><br><span class="line">	<span class="keyword">void</span>* page = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">	<span class="keyword">uint32_t</span> row_offset = row_num % ROWS_PER_PAGE;</span><br><span class="line">	<span class="keyword">uint32_t</span> byte_offset = row_offset * ROW_SIZE;</span><br><span class="line">	<span class="comment">//之所以报 “必须是指向完整类型”的错，是因为指针指向类型不确定，则其单位不确定，加上byte_offset后也不知道到底指向哪一块内存。</span></span><br><span class="line">	<span class="comment">//由于 byte_offset 是字节单位，所以page页要变为指向8位内存的指针。所以转化位 uint8_t</span></span><br><span class="line">	<span class="keyword">return</span> (Row*)((<span class="keyword">uint8_t</span>*)page + byte_offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="CDB-h-1"><a href="#CDB-h-1" class="headerlink" title="CDB.h"></a>CDB.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLUMN_USERNAME_SIZE 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLUMN_EMAIL_SIZE 255</span></span><br><span class="line"><span class="comment">//表中最大页数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABLE_MAX_PAGES 100</span></span><br><span class="line"><span class="comment">//页的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="comment">//定义宏获取size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size_of_attribute(Struct, Attribute) sizeof(((Struct*)0)-&gt;Attribute)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入缓冲</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span>* buffer;</span><br><span class="line">	<span class="comment">// _int64</span></span><br><span class="line">	<span class="keyword">size_t</span> buffer_length;</span><br><span class="line">	<span class="keyword">size_t</span> input_length;</span><br><span class="line">&#125; InputBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断输入得到的命令状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	META_COMMAND_EXIT,</span><br><span class="line">	META_COMMAND_SUCCESS,</span><br><span class="line">	META_COMMAND_UNRECOGNIZED_COMMAND</span><br><span class="line">&#125; MetaCommandResult;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理得到的状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PREPARE_SUCCESS,</span><br><span class="line">	PREPARE_NEGATIVE_ID,</span><br><span class="line">	PREPARE_SYNTAX_ERROR,</span><br><span class="line">	PREPARE_STRING_TOO_LONG,</span><br><span class="line">	PREPARE_TOO_MANY_PARAMETER,</span><br><span class="line">	PREPARE_UNRECOGNIZED_STATEMENT</span><br><span class="line">&#125; PrepareResult;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理后的状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	EXECUTE_SUCCESS,</span><br><span class="line">	EXECUTE_TABLE_FULL</span><br><span class="line">&#125;ExecuteResult;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到的输入的表达式的状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	STATEMENT_INSERT,</span><br><span class="line">	STATEMENT_SELECT</span><br><span class="line">&#125; StatementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义 一行 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> id;</span><br><span class="line">	<span class="comment">//加一是因为c语言需要最后一个字符为0，所以可用字符就减一了。</span></span><br><span class="line">	<span class="comment">//不过即使这样也还需要在输入的时候判断是否大小超界</span></span><br><span class="line">	<span class="keyword">char</span> username[COLUMN_USERNAME_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">char</span> email[COLUMN_EMAIL_SIZE + <span class="number">1</span>];</span><br><span class="line">&#125; Row;</span><br><span class="line"></span><br><span class="line"><span class="comment">//statement</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	StatementType type;</span><br><span class="line">	Row row_to_insert;</span><br><span class="line">&#125; Statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取行中每一个元素的size和offset</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> ID_SIZE = <span class="built_in">size_of_attribute</span>(Row, id);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> USERNAME_SIZE = <span class="built_in">size_of_attribute</span>(Row, username);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> EMAIL_SIZE = <span class="built_in">size_of_attribute</span>(Row, email);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> ID_OFFSET = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> USERNAME_OFFSET = <span class="number">0</span> + <span class="built_in">size_of_attribute</span>(Row, id);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> EMAIL_OFFSET = <span class="number">0</span> + <span class="built_in">size_of_attribute</span>(Row, id) + <span class="built_in">size_of_attribute</span>(Row, username);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> ROW_SIZE = <span class="built_in">size_of_attribute</span>(Row, id) + <span class="built_in">size_of_attribute</span>(Row, username) + <span class="built_in">size_of_attribute</span>(Row, email);</span><br><span class="line"><span class="comment">//每一页有多少行</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> ROWS_PER_PAGE = PAGE_SIZE / (<span class="built_in">size_of_attribute</span>(Row, id) + <span class="built_in">size_of_attribute</span>(Row, username) + <span class="built_in">size_of_attribute</span>(Row, email));</span><br><span class="line"><span class="comment">//一张表里面最大行数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> TABLE_MAX_ROWS = PAGE_SIZE / (<span class="built_in">size_of_attribute</span>(Row, id) + <span class="built_in">size_of_attribute</span>(Row, username) + <span class="built_in">size_of_attribute</span>(Row, email)) * TABLE_MAX_PAGES;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储page   这里page和table的关系也说明了一张表可以使用很多文件来存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> file_descriptor;</span><br><span class="line">	<span class="keyword">uint32_t</span> file_length;</span><br><span class="line">	<span class="keyword">void</span>* pages[TABLE_MAX_PAGES];</span><br><span class="line">&#125; Pager;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一张表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> num_rows;</span><br><span class="line">	Pager* pager;</span><br><span class="line">&#125; Table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//光标指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Table* table;</span><br><span class="line">	<span class="keyword">uint32_t</span> row_num;</span><br><span class="line">	<span class="keyword">bool</span> end_of_table;  <span class="comment">// Indicates a position one past the last element</span></span><br><span class="line">&#125; Cursor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个input_buffer</span></span><br><span class="line"><span class="function">InputBuffer* <span class="title">new_input_buffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//打印命令提示符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_prompt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取一行的输入，以换行符为终结</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">getline</span><span class="params">(<span class="keyword">char</span>** buffer, <span class="keyword">size_t</span>* n)</span></span>;</span><br><span class="line"><span class="comment">//读取输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_input</span><span class="params">(InputBuffer* input_buffer)</span></span>;</span><br><span class="line"><span class="comment">//关闭输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_input_buffer</span><span class="params">(InputBuffer* input_buffer)</span></span>;</span><br><span class="line"><span class="comment">// 判断是何种命令</span></span><br><span class="line"><span class="function">MetaCommandResult <span class="title">do_meta_command</span><span class="params">(InputBuffer* input_buffer, Table* table)</span></span>;</span><br><span class="line"><span class="comment">//预处理结果</span></span><br><span class="line"><span class="function">PrepareResult <span class="title">prepare_statement</span><span class="params">(InputBuffer* input_buffer, Statement* statement)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_trim</span><span class="params">(InputBuffer* input_buffer)</span></span>;</span><br><span class="line"><span class="function">PrepareResult <span class="title">prepare_insert</span><span class="params">(InputBuffer* input_buffer, Statement* statement)</span></span>;</span><br><span class="line"><span class="comment">//执行命令 根据 statement 来执行相应的命令</span></span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_statement</span><span class="params">(Statement* statement, Table* table)</span></span>;</span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_insert</span><span class="params">(Statement* statement, Table* table)</span></span>;</span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_select</span><span class="params">(Statement* statement, Table* table)</span></span>;</span><br><span class="line"><span class="comment">//将行的信息存储到内存中</span></span><br><span class="line"><span class="comment">//A void pointer can hold address of any type and can be typcasted to any type</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serialize_row</span><span class="params">(Row* source, Row* destination)</span></span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deserialize_row</span><span class="params">(Row* source, Row* destination)</span></span>;</span><br><span class="line"><span class="comment">//插入前判断插入的内存位置 以及适时分配内存 </span></span><br><span class="line"><span class="function">Row* <span class="title">cursor_value</span><span class="params">(Cursor* cursor)</span></span>;</span><br><span class="line"><span class="comment">//从磁盘中获取page</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_page</span><span class="params">(Pager* pager, <span class="keyword">uint32_t</span> page_num)</span></span>;</span><br><span class="line"><span class="comment">//同步内存中的额数据和磁盘中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pager_flush</span><span class="params">(Pager* pager, <span class="keyword">uint32_t</span> page_num, <span class="keyword">uint32_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//连接数据库  使用文件名</span></span><br><span class="line"><span class="function">Table* <span class="title">db_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span>;</span><br><span class="line"><span class="function">Pager* <span class="title">pager_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">db_close</span><span class="params">(Table* table)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_table</span><span class="params">(Table* table)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_row</span><span class="params">(Row* row)</span></span>;</span><br><span class="line"><span class="comment">//指向表的开头 第一行</span></span><br><span class="line"><span class="function">Cursor* <span class="title">table_start</span><span class="params">(Table* table)</span></span>;</span><br><span class="line"><span class="comment">//指向当前要插入的一行</span></span><br><span class="line"><span class="function">Cursor* <span class="title">table_end</span><span class="params">(Table* table)</span></span>;</span><br><span class="line"><span class="comment">//更新 cursor</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cursor_advance</span><span class="params">(Cursor* cursor)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="CDB-cpp"><a href="#CDB-cpp" class="headerlink" title="CDB.cpp"></a>CDB.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//在最前面加上这个宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CDB.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">InputBuffer* <span class="title">new_input_buffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	InputBuffer* input_buffer = (InputBuffer*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(InputBuffer));</span><br><span class="line">	<span class="keyword">if</span> (input_buffer)</span><br><span class="line">	&#123;</span><br><span class="line">		input_buffer-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line">		input_buffer-&gt;buffer_length = <span class="number">0</span>;</span><br><span class="line">		input_buffer-&gt;input_length = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> input_buffer;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_prompt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;CDB &gt;&gt; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一行的输入，以换行符为终结</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">getline</span><span class="params">(<span class="keyword">char</span>** buffer, <span class="keyword">size_t</span>* n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">size_t</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//一行最多不超过80个字符</span></span><br><span class="line">	<span class="keyword">uint32_t</span> COLUMN_MAX_SIZE = COLUMN_USERNAME_SIZE + COLUMN_EMAIL_SIZE + <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">char</span>* buffer_temp = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(COLUMN_MAX_SIZE * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="keyword">if</span> (buffer_temp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &amp;&amp; c != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		*(buffer_temp + bytes_read++) = c;</span><br><span class="line">		<span class="keyword">if</span> (bytes_read == COLUMN_MAX_SIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;too long\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	*buffer = buffer_temp;</span><br><span class="line">	<span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_input</span><span class="params">(InputBuffer* input_buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// void 对于所有类型都非法 </span></span><br><span class="line">	<span class="comment">// 返回读取得到的字节数量</span></span><br><span class="line">	<span class="keyword">size_t</span> bytes_read = <span class="built_in">getline</span>(&amp;(input_buffer-&gt;buffer), &amp;(input_buffer-&gt;buffer_length));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf(&quot;这次读取到的字节数量为 %llu\n&quot;, bytes_read);</span></span><br><span class="line">	<span class="keyword">if</span> (bytes_read &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error reading input\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ignore trailing newline    </span></span><br><span class="line">	input_buffer-&gt;input_length = bytes_read;</span><br><span class="line">	input_buffer-&gt;buffer[bytes_read] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_input_buffer</span><span class="params">(InputBuffer* input_buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(input_buffer-&gt;buffer);</span><br><span class="line">	<span class="built_in">free</span>(input_buffer);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;关闭输入\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是何种命令</span></span><br><span class="line"><span class="function">MetaCommandResult <span class="title">do_meta_command</span><span class="params">(InputBuffer* input_buffer, Table* table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//退出</span></span><br><span class="line">		<span class="built_in">db_close</span>(table);</span><br><span class="line">		<span class="keyword">return</span> META_COMMAND_EXIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.q&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//退出</span></span><br><span class="line">		<span class="built_in">db_close</span>(table);</span><br><span class="line">		<span class="keyword">return</span> META_COMMAND_EXIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.v&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//显示当前版本</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CDB version 0.1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//不可解析</span></span><br><span class="line">		<span class="keyword">return</span> META_COMMAND_UNRECOGNIZED_COMMAND;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理，就是前缀命令识别</span></span><br><span class="line"><span class="function">PrepareResult <span class="title">prepare_statement</span><span class="params">(InputBuffer* input_buffer, Statement* statement)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">prepare_trim</span>(input_buffer);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;insert&quot;</span>, <span class="number">6</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">prepare_insert</span>(input_buffer, statement);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;select&quot;</span>, <span class="number">6</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		statement-&gt;type = STATEMENT_SELECT;</span><br><span class="line">		<span class="keyword">return</span> PREPARE_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> PREPARE_UNRECOGNIZED_STATEMENT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//预处理的预处理 去掉多余的空格</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_trim</span><span class="params">(InputBuffer* input_buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* temp = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(input_buffer-&gt;buffer) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="keyword">char</span>* p1 = temp;</span><br><span class="line">	<span class="keyword">char</span>* p2 = input_buffer-&gt;buffer;</span><br><span class="line">	<span class="comment">//首先去掉前面的空格</span></span><br><span class="line">	<span class="keyword">while</span> ((*p2) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//现在p2指向真正的命令起始</span></span><br><span class="line">	<span class="comment">//去掉文本中间多余的空格</span></span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> ((*p2) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (((*p2) == <span class="string">&#x27; &#x27;</span>) &amp;&amp; (flag == <span class="literal">true</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			*p1 = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			p1++;</span><br><span class="line">			p2++;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((*p2) != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*p1 = *p2;</span><br><span class="line">			p1++;</span><br><span class="line">			p2++;</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p2++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//此时 p1 指向最后，需要变为0</span></span><br><span class="line">	*p1 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">free</span>(input_buffer-&gt;buffer);</span><br><span class="line">	input_buffer-&gt;buffer = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PrepareResult <span class="title">prepare_insert</span><span class="params">(InputBuffer* input_buffer, Statement* statement)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	statement-&gt;type = STATEMENT_INSERT;</span><br><span class="line">	<span class="comment">//这里应该可以去掉开头的空格，目前还不可以</span></span><br><span class="line">	<span class="keyword">char</span>* keyword = <span class="built_in">strtok</span>(input_buffer-&gt;buffer, <span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">char</span>* id_string = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">char</span>* username = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">char</span>* email = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">char</span>* test_parameter = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (id_string == <span class="literal">NULL</span> || username == <span class="literal">NULL</span> || email == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> PREPARE_SYNTAX_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (test_parameter != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> PREPARE_TOO_MANY_PARAMETER;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> id = <span class="built_in">atoi</span>(id_string);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(username) &gt; COLUMN_USERNAME_SIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> PREPARE_STRING_TOO_LONG;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(email) &gt; COLUMN_EMAIL_SIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> PREPARE_STRING_TOO_LONG;</span><br><span class="line">	&#125;</span><br><span class="line">	statement-&gt;row_to_insert.id = id;</span><br><span class="line">	<span class="built_in">strcpy</span>(statement-&gt;row_to_insert.username, username);</span><br><span class="line">	<span class="built_in">strcpy</span>(statement-&gt;row_to_insert.email, email);</span><br><span class="line">	<span class="keyword">return</span> PREPARE_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行命令</span></span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_statement</span><span class="params">(Statement* statement, Table* table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (statement-&gt;type)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">case</span></span> (STATEMENT_INSERT):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">execute_insert</span>(statement, table);</span><br><span class="line">	<span class="built_in"><span class="keyword">case</span></span> (STATEMENT_SELECT):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">execute_select</span>(statement, table);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_insert</span><span class="params">(Statement* statement, Table* table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (table-&gt;num_rows &gt;= TABLE_MAX_ROWS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> EXECUTE_TABLE_FULL;</span><br><span class="line">	&#125;</span><br><span class="line">	Row* row_to_insert = &amp;(statement-&gt;row_to_insert);</span><br><span class="line">	Cursor* cursor = <span class="built_in">table_end</span>(table);</span><br><span class="line">	<span class="comment">//将一行存入内存</span></span><br><span class="line">	<span class="built_in">serialize_row</span>(row_to_insert, <span class="built_in">cursor_value</span>(cursor));</span><br><span class="line">	table-&gt;num_rows += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> EXECUTE_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_select</span><span class="params">(Statement* statement, Table* table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cursor* cursor = <span class="built_in">table_start</span>(table);</span><br><span class="line">	Row row;</span><br><span class="line">	<span class="keyword">while</span> (!(cursor-&gt;end_of_table)) &#123;</span><br><span class="line">		<span class="built_in">deserialize_row</span>(<span class="built_in">cursor_value</span>(cursor), &amp;row);</span><br><span class="line">		<span class="built_in">print_row</span>(&amp;row);</span><br><span class="line">		<span class="built_in">cursor_advance</span>(cursor);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(cursor);</span><br><span class="line">	<span class="keyword">return</span> EXECUTE_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将行的信息存储到内存中</span></span><br><span class="line"><span class="comment">//A void pointer can hold address of any type and can be typcasted to any type</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serialize_row</span><span class="params">(Row* source, Row* destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ID_SIZE 指的是字节数</span></span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)destination + ID_OFFSET, &amp;(source-&gt;id), ID_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)destination + USERNAME_OFFSET, &amp;(source-&gt;username), USERNAME_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)destination + EMAIL_OFFSET, &amp;(source-&gt;email), EMAIL_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deserialize_row</span><span class="params">(Row* source, Row* destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;(destination-&gt;id), (<span class="keyword">uint8_t</span>*)source + ID_OFFSET, ID_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;(destination-&gt;username), (<span class="keyword">uint8_t</span>*)source + USERNAME_OFFSET, USERNAME_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;(destination-&gt;email), (<span class="keyword">uint8_t</span>*)source + EMAIL_OFFSET, EMAIL_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入前判断插入的内存位置 以及适时分配内存 光标指针的作用就是指示某个table中的某一行，并表明该行是否为最后一行。</span></span><br><span class="line"><span class="comment">//入口：一个光标指针   出口：指向内存中光标指针对应行的指针</span></span><br><span class="line"><span class="function">Row* <span class="title">cursor_value</span><span class="params">(Cursor* cursor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> row_num = cursor-&gt;row_num;</span><br><span class="line">	<span class="keyword">uint32_t</span> page_num = row_num / ROWS_PER_PAGE;</span><br><span class="line">	<span class="comment">//算出来吧光标指针指向哪一个page  并获取这一页</span></span><br><span class="line">	<span class="keyword">void</span>* page = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">	<span class="keyword">uint32_t</span> row_offset = row_num % ROWS_PER_PAGE;</span><br><span class="line">	<span class="keyword">uint32_t</span> byte_offset = row_offset * ROW_SIZE;</span><br><span class="line">	<span class="comment">//之所以报 “必须是指向完整类型”的错，是因为指针指向类型不确定，则其单位不确定，加上byte_offset后也不知道到底指向哪一块内存。</span></span><br><span class="line">	<span class="comment">//由于 byte_offset 是字节单位，所以page页要变为指向8位内存的指针。所以转化位 uint8_t</span></span><br><span class="line">	<span class="keyword">return</span> (Row*)((<span class="keyword">uint8_t</span>*)page + byte_offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从磁盘中获取page  </span></span><br><span class="line"><span class="comment">//入口：pager page_num  出口：在内存中找到或者开辟一块page区域，并以指针的形式返回。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_page</span><span class="params">(Pager* pager, <span class="keyword">uint32_t</span> page_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (page_num &gt; TABLE_MAX_PAGES)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Tried to fetch page number out of bounds. %d &gt; %d\n&quot;</span>, page_num, TABLE_MAX_PAGES);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pager-&gt;pages[page_num] == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Cache miss. Allocate memory and load from file.</span></span><br><span class="line">		<span class="keyword">void</span>* page = <span class="built_in">malloc</span>(PAGE_SIZE);</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;load page error.\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//pager中没有存储page的数量，所以才需要在这里算出来</span></span><br><span class="line">		<span class="keyword">uint32_t</span> num_pages = pager-&gt;file_length / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// We might save a partial page at the end of the file</span></span><br><span class="line">		<span class="keyword">if</span> (pager-&gt;file_length % PAGE_SIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			num_pages += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里应为 num_pages-1 因为都是从零开始，num_pages算出来的是真实的page数量，比下标大一</span></span><br><span class="line">		<span class="keyword">if</span> (page_num &lt;= num_pages - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//设定文件指针位置</span></span><br><span class="line">			_lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);</span><br><span class="line">			<span class="comment">//获取一个page到内存中。并将读取到的字节数存储到bytes_read中</span></span><br><span class="line">			<span class="keyword">size_t</span> bytes_read = _read(pager-&gt;file_descriptor, page, PAGE_SIZE);</span><br><span class="line">			<span class="keyword">if</span> (bytes_read == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//打印出程序错误代码，目前我还不会用。</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Error reading file: %d\n&quot;</span>, errno);</span><br><span class="line">				<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果大于当前文件中的页数，则说明文件中没有这个页，这是一个新页，直接使用即可。</span></span><br><span class="line">		pager-&gt;pages[page_num] = page;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pager-&gt;pages[page_num];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目前数据库中只有一张表</span></span><br><span class="line"><span class="function">Table* <span class="title">db_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Pager* pager = <span class="built_in">pager_open</span>(filename);</span><br><span class="line">	<span class="comment">//当前存储的行数，因为现在一张表只用一个文件来存储故这样是也可以的。</span></span><br><span class="line">	<span class="keyword">uint32_t</span> num_rows = pager-&gt;file_length / ROW_SIZE;</span><br><span class="line">	Table* table = (Table*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Table));</span><br><span class="line">	table-&gt;pager = pager;</span><br><span class="line">	table-&gt;num_rows = num_rows;</span><br><span class="line">	<span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Pager* <span class="title">pager_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		int fd = open(filename,</span></span><br><span class="line"><span class="comment">		O_RDWR |      // Read/Write mode</span></span><br><span class="line"><span class="comment">		O_CREAT,  // Create file if it does not exist</span></span><br><span class="line"><span class="comment">		S_IWUSR |     // User write permission</span></span><br><span class="line"><span class="comment">		S_IRUSR   // User read permission</span></span><br><span class="line"><span class="comment">		);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//Read/Write mode Create file if it does not exist</span></span><br><span class="line">	<span class="keyword">int</span> fd = _open(filename, O_RDWR | O_CREAT, _S_IREAD | _S_IWRITE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Unable to open file\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//long  文件中的偏移地址从0到seek_end的长度即为文件的长度</span></span><br><span class="line">	<span class="comment">//returns the offset, in bytes, of the new position from the beginning of the file</span></span><br><span class="line">	<span class="comment">//将文件指针从 SEEK_END向后移动0为，并返回新的文件指针相对于文件起始 SEEK_SET 的偏移量，即文件大小</span></span><br><span class="line">	<span class="keyword">off_t</span> file_length = _lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="comment">//初始化pager</span></span><br><span class="line">	Pager* pager = (Pager*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Pager));</span><br><span class="line">	pager-&gt;file_descriptor = fd;</span><br><span class="line">	pager-&gt;file_length = file_length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; TABLE_MAX_PAGES; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将某一页存储到硬盘中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pager_flush</span><span class="params">(Pager* pager, <span class="keyword">uint32_t</span> page_num, <span class="keyword">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pager-&gt;pages[page_num] == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Tried to flush null page\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//SEEK_SET: Beginning of the file.  将文件指针指向对应位置，下一次操控文件就从这里开始了</span></span><br><span class="line">	<span class="keyword">off_t</span> offset = _lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);</span><br><span class="line">	<span class="keyword">if</span> (offset == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error seeking: %d\n&quot;</span>, errno);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从当前文件指针位置写入 大小为size的内存 内存起始为pager-&gt;pages[page_num]</span></span><br><span class="line">	<span class="keyword">size_t</span> bytes_written = _write(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);</span><br><span class="line">	<span class="keyword">if</span> (bytes_written == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error writing: %d\n&quot;</span>, errno);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭数据库连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">db_close</span><span class="params">(Table* table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Pager* pager = table-&gt;pager;</span><br><span class="line">	<span class="comment">//满的 page</span></span><br><span class="line">	<span class="keyword">uint32_t</span> num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; num_full_pages; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//判断page是否在内存中，不在的话就从内存中更新到硬盘上。并释放内存</span></span><br><span class="line">		<span class="keyword">if</span> (pager-&gt;pages[i] == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pager_flush</span>(pager, i, PAGE_SIZE);</span><br><span class="line">		<span class="built_in">free</span>(pager-&gt;pages[i]);</span><br><span class="line">		pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// There may be a partial page to write to the end of the file</span></span><br><span class="line">	<span class="comment">// This should not be needed after we switch to a B-tree</span></span><br><span class="line">	<span class="keyword">uint32_t</span> num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;</span><br><span class="line">	<span class="keyword">if</span> (num_additional_rows &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> page_num = num_full_pages;</span><br><span class="line">		<span class="comment">//剩下不足一个page的行所在的page_num</span></span><br><span class="line">		<span class="keyword">if</span> (pager-&gt;pages[page_num] != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">pager_flush</span>(pager, page_num, num_additional_rows * ROW_SIZE);</span><br><span class="line">			<span class="built_in">free</span>(pager-&gt;pages[page_num]);</span><br><span class="line">			pager-&gt;pages[page_num] = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> result = _close(pager-&gt;file_descriptor);</span><br><span class="line">	<span class="keyword">if</span> (result == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error closing db file.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; TABLE_MAX_PAGES; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">void</span>* page = pager-&gt;pages[i];</span><br><span class="line">		<span class="keyword">if</span> (page)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(page);</span><br><span class="line">			pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(pager);</span><br><span class="line">	<span class="built_in">free</span>(table);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_table</span><span class="params">(Table* table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; table-&gt;pager-&gt;pages[i]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(table-&gt;pager-&gt;pages[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(table-&gt;pager);</span><br><span class="line">	<span class="built_in">free</span>(table);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_row</span><span class="params">(Row* row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;| id: %u username: %s email: %s |\n&quot;</span>, row-&gt;id, row-&gt;username, row-&gt;email);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指向表的开头 第一行</span></span><br><span class="line"><span class="function">Cursor* <span class="title">table_start</span><span class="params">(Table* table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cursor* cursor = (Cursor*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Cursor));</span><br><span class="line">	cursor-&gt;table = table;</span><br><span class="line">	cursor-&gt;row_num = <span class="number">0</span>;</span><br><span class="line">	cursor-&gt;end_of_table = (table-&gt;num_rows == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> cursor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指向当前要插入的一行</span></span><br><span class="line"><span class="function">Cursor* <span class="title">table_end</span><span class="params">(Table* table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cursor* cursor = (Cursor*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Cursor));</span><br><span class="line">	cursor-&gt;table = table;</span><br><span class="line">	cursor-&gt;row_num = table-&gt;num_rows;</span><br><span class="line">	cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> cursor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新 cursor</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cursor_advance</span><span class="params">(Cursor* cursor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cursor-&gt;row_num += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows)</span><br><span class="line">	&#123;</span><br><span class="line">		cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-c-1"><a href="#main-c-1" class="headerlink" title="main.c"></a>main.c</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CDB.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Must supply a database filename.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>* filename = argv[<span class="number">1</span>];</span><br><span class="line">	Table* table = <span class="built_in">db_open</span>(filename);</span><br><span class="line">	InputBuffer* input_buffer = <span class="built_in">new_input_buffer</span>();</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">print_prompt</span>();</span><br><span class="line">		<span class="built_in">read_input</span>(input_buffer);</span><br><span class="line">		<span class="comment">//判断是否有输入，若是回车直接 continue</span></span><br><span class="line">		<span class="keyword">if</span> (input_buffer-&gt;input_length == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//以 . 开头则为非 sql 命令</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (input_buffer-&gt;buffer[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">do_meta_command</span>(input_buffer, table))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//退出</span></span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (META_COMMAND_EXIT):</span><br><span class="line">				<span class="comment">//printf(&quot;META_COMMAND_EXIT&quot;);</span></span><br><span class="line">				<span class="built_in">close_input_buffer</span>(input_buffer);</span><br><span class="line">				<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//此命令可以解析</span></span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (META_COMMAND_SUCCESS):</span><br><span class="line">				<span class="comment">//printf(&quot;META_COMMAND_SUCCESS&quot;);</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//命令不可解析</span></span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (META_COMMAND_UNRECOGNIZED_COMMAND):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Unrecognized command &#x27;%s&#x27;\n&quot;</span>, input_buffer-&gt;buffer);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//sql命令</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (input_buffer-&gt;buffer[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//进行预处理  即判断 insert create 等命令</span></span><br><span class="line">			Statement statement;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">prepare_statement</span>(input_buffer, &amp;statement))</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (PREPARE_SUCCESS):</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (PREPARE_STRING_TOO_LONG):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;String is too long.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span>(PREPARE_NEGATIVE_ID):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;your id id negative.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span>(PREPARE_TOO_MANY_PARAMETER):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;too many parameter.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (PREPARE_UNRECOGNIZED_STATEMENT):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Unrecognized keyword at start of &#x27;%s&#x27;.\n&quot;</span>, input_buffer-&gt;buffer);</span><br><span class="line">				<span class="comment">//break 会break switch本身， 而continue 会continue 上一层，而忽略掉 switch</span></span><br><span class="line">				<span class="comment">//这里直接continue 到while(true)</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span>(PREPARE_SYNTAX_ERROR):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Syntax error. Could not parse statement.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">execute_statement</span>(&amp;statement, table))</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (EXECUTE_SUCCESS):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Executed.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">case</span></span> (EXECUTE_TABLE_FULL):</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Error: Table full.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三步-使用-B-TREE"><a href="#第三步-使用-B-TREE" class="headerlink" title="第三步 使用 B TREE"></a>第三步 使用 B TREE</h2>]]></content>
      <categories>
        <category>project</category>
        <category>CDB</category>
      </categories>
      <tags>
        <tag>CDB</tag>
        <tag>database</tag>
        <tag>项目</tag>
        <tag>自制轮子</tag>
        <tag>计算机底层</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 二 线性表</title>
    <url>/2021/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表-新的实现"><a href="#线性表-新的实现" class="headerlink" title="线性表 新的实现"></a>线性表 新的实现</h1><p><strong>更新日期：202107021044</strong></p>
<p>链表在ADT一节中已经实现过了，不过实现的并不是特别的完善，只是一个ADT的使用例子而已，现在正式地将链表进行实现。<br><strong>本系列参考数据结构严蔚敏c语言版、c primer plus、STL进行实现</strong></p>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><ol>
<li>构造一个空线性表</li>
<li>销毁一个线性表</li>
<li>清空线性表</li>
<li>判断线性表是否为空</li>
<li>获得线性表中元素的个数</li>
<li>获得特定位置元素</li>
<li>返回第一个满足关系的元素位置</li>
<li>返回某元素的前驱</li>
<li>返回某元素的后继</li>
<li>再特定位置插入元素</li>
<li>删除特定位置的元素</li>
<li>使用特定的函数遍历所有元素</li>
</ol>
<h2 id="线性表的顺序实现"><a href="#线性表的顺序实现" class="headerlink" title="线性表的顺序实现"></a>线性表的顺序实现</h2><h3 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h3><p>由于c语言不支持c++那样的引用操作，所以我的实现和教材上略有不同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性表 重新实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; Item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinearList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//存放元素</span></span><br><span class="line">    Item *items;</span><br><span class="line">    <span class="comment">//当前长度</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="comment">//当前分配的存储容量</span></span><br><span class="line">    <span class="keyword">int</span> listsize;</span><br><span class="line">&#125; * LinearList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitLinearList</span><span class="params">(LinearList(*List), <span class="keyword">int</span> initsize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyLinearList</span><span class="params">(LinearList(*List))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ClearLinearList</span><span class="params">(LinearList(*List))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EmptyLinearList</span><span class="params">(LinearList(*List))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//full</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FullLinearList</span><span class="params">(LinearList(*List))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetItemLinearList</span><span class="params">(LinearList(*List), <span class="keyword">int</span> location, Item *itemsave)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位第一个满足条件的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateLinearList</span><span class="params">(LinearList(*List), <span class="keyword">bool</span> (*fun)(Item item))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertLinearList</span><span class="params">(LinearList(*List), <span class="keyword">int</span> location, Item *item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteLinearList</span><span class="params">(LinearList(*List), <span class="keyword">int</span> location)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseLinearList</span><span class="params">(LinearList(*List), <span class="keyword">void</span> (*fun)(Item item))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AutoFillLinearList</span><span class="params">(LinearList(*List))</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linearlist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitLinearList</span><span class="params">(LinearList(*List), <span class="keyword">int</span> initsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据下面的论断更正后 List 是指向 LinearList 的指针。</span></span><br><span class="line">    <span class="comment">//malloc (*List)    因为这里重新给 (*List) 分配内存了，所以 现在的List 不指向传进来的参数的List的指向，所以相当于这一切的初始化白做了。</span></span><br><span class="line">    <span class="comment">//这就是为什么书上的函数都是直接取变量的地址了，这样在函数中再反取地址就可以直接更改源数据了。</span></span><br><span class="line">    <span class="comment">//也可以在函数中自己重新定义一个一样的数据，完成之后赋值给传进来的参数，但是这样在有些情况写太费了，不好。</span></span><br><span class="line">    (*List) = (struct LinearList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LinearList));</span><br><span class="line">    <span class="comment">//malloc items</span></span><br><span class="line">    (*List)-&gt;items = (Item *)<span class="built_in">malloc</span>(initsize * <span class="keyword">sizeof</span>(Item));</span><br><span class="line">    <span class="keyword">if</span> (!(*List)-&gt;items)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你要的空间太大了，分配不了\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        (*List)-&gt;length = <span class="number">0</span>;</span><br><span class="line">        (*List)-&gt;listsize = initsize;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化成功,容量为%d\n&quot;</span>, (*List)-&gt;listsize);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyLinearList</span><span class="params">(LinearList(*List))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>((*List)-&gt;items);</span><br><span class="line">    (*List)-&gt;items = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>((*List));</span><br><span class="line">    (*List) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((*List) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;销毁成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;销毁失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ClearLinearList</span><span class="params">(LinearList(*List))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*List)-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;清空成功\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EmptyLinearList</span><span class="params">(LinearList(*List))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*List)-&gt;length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FullLinearList</span><span class="params">(LinearList(*List))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*List)-&gt;length == (*List)-&gt;listsize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;满了\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetItemLinearList</span><span class="params">(LinearList(*List), <span class="keyword">int</span> location, Item *itemsave)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">0</span> || location &gt;= (*List)-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;范围超限\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *itemsave = (*List)-&gt;items[location];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位第一个满足条件的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateLinearList</span><span class="params">(LinearList(*List), <span class="keyword">bool</span> (*fun)(Item item))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (*List)-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fun((*List)-&gt;items[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;第一个满足条件的元素在%d\n&quot;</span>, i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;没有元素满足条件\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入  这个函数有问题 内存</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertLinearList</span><span class="params">(LinearList(*List), <span class="keyword">int</span> location, Item *item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;InsertLinearList\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (FullLinearList(List))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//自动申请扩容</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;满了，自动申请扩容.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (List == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;List is NULL\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*List == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*List is NULL\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((*List)-&gt;items == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(*List)-&gt;items is NULL\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (*List)-&gt;items = (Item *)<span class="built_in">realloc</span>((*List)-&gt;items, ((*List)-&gt;listsize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(Item));</span><br><span class="line">        <span class="keyword">if</span> ((*List)-&gt;items)</span><br><span class="line">        &#123;</span><br><span class="line">            (*List)-&gt;listsize++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;自动申请扩容, 成功,当前容量为%d\n&quot;</span>, (*List)-&gt;listsize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;自动申请扩容, 失败，插入失败\n&quot;</span>);</span><br><span class="line">            (*List)-&gt;items = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (*List)-&gt;length++;</span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        location = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location &gt;= (*List)-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        location = (*List)-&gt;length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (*List)-&gt;length - <span class="number">1</span>; i &gt;= location + <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        (*List)-&gt;items[i] = (*List)-&gt;items[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    (*List)-&gt;items[location] = *item;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入成功,当前容量为%d,可用容量为%d\n&quot;</span>, (*List)-&gt;listsize, (*List)-&gt;listsize - (*List)-&gt;length);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteLinearList</span><span class="params">(LinearList(*List), <span class="keyword">int</span> location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">0</span> || location &gt;= (*List)-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除的范围错误\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = location; i &lt;= (*List)-&gt;length - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            (*List)-&gt;items[i] = (*List)-&gt;items[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        (*List)-&gt;length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseLinearList</span><span class="params">(LinearList(*List), <span class="keyword">void</span> (*fun)(Item item))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (*List)-&gt;length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fun((*List)-&gt;items[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AutoFillLinearList</span><span class="params">(LinearList(*List))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listsize = (*List)-&gt;listsize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= listsize * <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        srand((<span class="keyword">double</span>)time(<span class="literal">NULL</span>) * i);</span><br><span class="line">        Item item;</span><br><span class="line">        item.value = rand() % ((*List)-&gt;listsize);</span><br><span class="line">        item.value = i;</span><br><span class="line">        InsertLinearList(List, i, &amp;item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">KuoRong</span><span class="params">(LinearList *List)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FullLinearList(List))</span><br><span class="line">    &#123;</span><br><span class="line">        (*List)-&gt;items = (Item *)<span class="built_in">realloc</span>((*List)-&gt;items, (*List)-&gt;listsize + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((*List)-&gt;items)</span><br><span class="line">        &#123;</span><br><span class="line">            (*List)-&gt;listsize++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;自动申请扩容, 成功,当前容量为%d\n&quot;</span>, (*List)-&gt;listsize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;自动申请扩容, 失败，插入失败\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (*List)-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linearlist.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun1</span><span class="params">(Item item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.value &gt;= <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(Item item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;item: %d\n&quot;</span>, item.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinearList List = <span class="literal">NULL</span>;</span><br><span class="line">    Item itemsave;</span><br><span class="line">    InitLinearList(&amp;List, <span class="number">10</span>);</span><br><span class="line">    AutoFillLinearList(&amp;List);</span><br><span class="line">    GetItemLinearList(&amp;List, <span class="number">1</span>, &amp;itemsave);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;item: %d\n&quot;</span>, itemsave.value);</span><br><span class="line">    TraverseLinearList(&amp;List, (*fun2));</span><br><span class="line">    DestroyLinearList(&amp;List);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="线性表的链性实现"><a href="#线性表的链性实现" class="headerlink" title="线性表的链性实现"></a>线性表的链性实现</h2><h3 id="接口说明-1"><a href="#接口说明-1" class="headerlink" title="接口说明"></a>接口说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AUTOFILLSIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; Item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Item item;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//先实现单向链表</span></span><br><span class="line">    <span class="comment">//struct Node * prev;</span></span><br><span class="line">&#125; Node, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ClearLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EmptyLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//full</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FullLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetItemLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>), <span class="keyword">int</span> location, Item *itemsave)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位第一个满足条件的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>), <span class="keyword">bool</span> (*fun)(Item item))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>), <span class="keyword">int</span> location, Item *item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>), <span class="keyword">int</span> location)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>), <span class="keyword">void</span> (*fun)(Item item))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AutoFillLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口实现-1"><a href="#接口实现-1" class="headerlink" title="接口实现"></a>接口实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linklist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*<span class="built_in">list</span>) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化LinkList成功\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p = (*<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LinkList q = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    (*<span class="built_in">list</span>) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;销毁LinkList成功\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ClearLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DestroyLinkList(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EmptyLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">list</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表不空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//full</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FullLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;满了\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetItemLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>), <span class="keyword">int</span> location, Item *itemsave)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p = (*<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= location - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到这个元素\n&quot;</span>);</span><br><span class="line">            itemsave = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//现在p指向location元素</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到这个元素\n&quot;</span>);</span><br><span class="line">        <span class="comment">//直接改变itemsave时改变形参，对外面的实参没有任何影响。</span></span><br><span class="line">        <span class="comment">//itemsave = NULL;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里itemsave肯定要提前申请好内存</span></span><br><span class="line">        <span class="comment">//为了兼容性，直接改变itemsave的指向即可，不需要其事先拥有内存。</span></span><br><span class="line">        <span class="comment">//直接改变itemsave时改变形参，对外面的实参没有任何影响。  只有 *itemsave=    才会有作用。</span></span><br><span class="line">        <span class="comment">//假如要不申请内存 直接改变传入的实参的指针指向的话需要使用二重指针。不过这样有点麻烦了。不如申请内存了事</span></span><br><span class="line">        *itemsave = p-&gt;item;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了，第%d元素的值为%d\n&quot;</span>, location, p-&gt;item.value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位第一个满足条件的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>), <span class="keyword">bool</span> (*fun)(Item item))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p = (*<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">int</span> location = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fun(p-&gt;item))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;第一个满足条件的元素为第%d\n&quot;</span>, location);</span><br><span class="line">            <span class="keyword">return</span> location;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;没有满足条件的元素\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p = (*<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>), <span class="keyword">int</span> location, Item *item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FullLinkList(<span class="built_in">list</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;满了，无法插入\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList <span class="keyword">new</span> = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">new</span>-&gt;item = *item;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    LinkList p = (*<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">//本为空</span></span><br><span class="line">    <span class="keyword">if</span> (EmptyLinkList(<span class="built_in">list</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        (*<span class="built_in">list</span>) = <span class="keyword">new</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//头插 要移动头节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        location = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//new-&gt;next=p;</span></span><br><span class="line">        <span class="comment">//p=new;</span></span><br><span class="line">        <span class="keyword">new</span>-&gt;next = (*<span class="built_in">list</span>);</span><br><span class="line">        (*<span class="built_in">list</span>) = <span class="keyword">new</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾插</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location &gt;= CountLinkList(<span class="built_in">list</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        location = CountLinkList(<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中间插</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (location != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            location--;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插到p后面</span></span><br><span class="line">        <span class="keyword">new</span>-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>), <span class="keyword">int</span> location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (EmptyLinkList(<span class="built_in">list</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空，无法删除\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        location = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location &gt;= CountLinkList(<span class="built_in">list</span>) - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        location = CountLinkList(<span class="built_in">list</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第零个元素</span></span><br><span class="line">    <span class="keyword">if</span> (location == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        location = <span class="number">0</span>;</span><br><span class="line">        LinkList p = (*<span class="built_in">list</span>);</span><br><span class="line">        (*<span class="built_in">list</span>) = (*<span class="built_in">list</span>)-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location &lt;= CountLinkList(<span class="built_in">list</span>) - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LinkList p = (*<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">while</span> (location != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            location--;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除p-&gt;next</span></span><br><span class="line">        LinkList del = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(del);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>), <span class="keyword">void</span> (*fun)(Item item))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p = (*<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fun(p-&gt;item);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AutoFillLinkList</span><span class="params">(LinkList(*<span class="built_in">list</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= AUTOFILLSIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Item item;</span><br><span class="line">        item.value = i;</span><br><span class="line">        InsertLinkList(<span class="built_in">list</span>, i, &amp;item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口使用-1"><a href="#接口使用-1" class="headerlink" title="接口使用"></a>接口使用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linklist.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Item item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;item: %d\n&quot;</span>, item.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList <span class="built_in">list</span>;</span><br><span class="line">    Item itemsave; <span class="comment">//= (Item *)malloc(sizeof(Item));</span></span><br><span class="line">    InitLinkList(&amp;<span class="built_in">list</span>);</span><br><span class="line">    AutoFillLinkList(&amp;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于是值传递，所以传入指针的值，在函数中进行更改不会改变实参的数据。</span></span><br><span class="line">    GetItemLinkList(&amp;<span class="built_in">list</span>, <span class="number">2</span>, &amp;itemsave);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;item: %d\n&quot;</span>, itemsave.value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TraverseLinkList(&amp;list,(*fun));</span></span><br><span class="line">    <span class="comment">//DeleteLinkList(&amp;list,5);</span></span><br><span class="line">    <span class="comment">//TraverseLinkList(&amp;list,(*fun));</span></span><br><span class="line">    <span class="comment">//DestroyLinkList(&amp;list);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="旧的实现"><a href="#旧的实现" class="headerlink" title="旧的实现"></a>旧的实现</h1><p>我觉得之前的这个实现不优雅，所以重现实现一遍，旧代码封存。</p>
<h2 id="线性表的ADT"><a href="#线性表的ADT" class="headerlink" title="线性表的ADT"></a>线性表的ADT</h2><ol>
<li>构造一个空的线性表 </li>
<li>销毁—个线性表</li>
<li>清空一个线性表中的所有元素，重置为空表 </li>
<li>判断是否为空表 </li>
<li>判断是否已满 </li>
<li>确定元素个数 </li>
<li>返回表的容量 </li>
<li>增加容量 </li>
<li>减少容量</li>
<li>将容量减少到当前实际使用的大小 </li>
<li>得到线性表第i个元素的值</li>
<li>返回第一个满足特定要求的元素的位置 定位元素 </li>
<li>返回最后一个满足特定要求的元素的位置 定位元素 </li>
<li>返回某元素的前驱 15. 返回一个元素的后继</li>
<li>在第i个位置之前插入新的元素，使其称为新的第i个元素 </li>
<li>删除第i个元素</li>
<li>使用特定的函数遍历线性表中每一个元素 </li>
<li>对线性表进行排序，排序规则为默认的升序 </li>
<li>对线性表进行排序，自定义排序规则 </li>
<li>将两个线性表合并</li>
<li>将一个线性表复制为另一个线性表</li>
</ol>
<p><strong>其实链表最重要的是学会链表的思想，即使用指针将处于分散内存的数据连接起来，以及相关数据结点的定义和操作，学会了这些才能为之后的树和图打下基础，也可以自己实现更加高级的数据结构</strong></p>
<h2 id="线性表的顺序实现-1"><a href="#线性表的顺序实现-1" class="headerlink" title="线性表的顺序实现"></a>线性表的顺序实现</h2><h3 id="接口说明-2"><a href="#接口说明-2" class="headerlink" title="接口说明"></a>接口说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性表的顺序实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITEM_COUNT 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是链表的数据部分</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; Item;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序性的链表中的一个结点的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//位置 指名是第几个元素</span></span><br><span class="line">    <span class="keyword">int</span> location;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序性的链表的定义 List 是指向顺序表的一个指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//存储数据</span></span><br><span class="line">    Item *items;</span><br><span class="line">    <span class="comment">//存储的数据大小</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//最大可以容纳的数据大小</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">ListStruct</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> ListStruct *List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空的顺序表</span></span><br><span class="line"><span class="comment">//输入链表，希望获取的容量的大小。</span></span><br><span class="line"><span class="comment">//成功则返回true,反之则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Initialize</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个顺序表</span></span><br><span class="line"><span class="comment">//输入一个顺序表，释放其所有内存</span></span><br><span class="line"><span class="comment">//成功则返回true,反之则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Destroy</span><span class="params">(List *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空一个顺序表</span></span><br><span class="line"><span class="comment">//清空一个顺序表，但是不要释放其内存</span></span><br><span class="line"><span class="comment">//成功则返回true,反之则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Clear</span><span class="params">(List *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空表</span></span><br><span class="line"><span class="comment">//空表则返回true,反之则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(List *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否已满</span></span><br><span class="line"><span class="comment">//满则返回true,反之则返回false</span></span><br><span class="line"><span class="comment">//对于顺序表来讲满的话就不能添加元素了，因为申请的内存已经确定了，</span></span><br><span class="line"><span class="comment">//但是链表还可以增加，因为可以再申请内存</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Full</span><span class="params">(List *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定元素个数</span></span><br><span class="line"><span class="comment">//返回元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Count</span><span class="params">(List *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定当前容量</span></span><br><span class="line"><span class="comment">//返回当前容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Capacity</span><span class="params">(List *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加容量为</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddCapacityTo</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> addcapacity)</span></span>;</span><br><span class="line"><span class="comment">//减少容量为</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SubCapacityTo</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> subcapacity)</span></span>;</span><br><span class="line"><span class="comment">//将容量减少到当前实际使用的大小</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Shrink_To_Fit</span><span class="params">(List *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到第i个元素 成功返回true</span></span><br><span class="line"><span class="comment">//将得到的item返回给 item_to_save</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">At</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> i, Item *item_to_save)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一个满足要求的元素的位置，并保存这个元素</span></span><br><span class="line"><span class="comment">//将得到的item返回给 item_to_save    位置返回给location</span></span><br><span class="line"><span class="comment">//若不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateFirst</span><span class="params">(List *<span class="built_in">list</span>, Item *item_to_save, <span class="keyword">bool</span> (*fun)(Item item))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回最后一个满足要求的元素的位置，并保存这个元素</span></span><br><span class="line"><span class="comment">//将得到的item返回给 item_to_save    位置返回给location</span></span><br><span class="line"><span class="comment">//若不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateLast</span><span class="params">(List *<span class="built_in">list</span>, Item *item_to_save, <span class="keyword">bool</span> (*fun)(Item item))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回元素node的前驱 存放在Node*previous</span></span><br><span class="line"><span class="comment">//若没有则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Previous</span><span class="params">(List *<span class="built_in">list</span>, Node *node, Node *previous)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回元素node的后继 存放在Node*success</span></span><br><span class="line"><span class="comment">//若没有则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Success</span><span class="params">(List *<span class="built_in">list</span>, Node *node, Node *success)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置之前插入新的元素，使其称为新的第i个元素</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> location, Item item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个元素</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> location)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用特定的函数遍历顺序表中的每一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">void</span> (*fun)(Item item))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对线性表进行升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort_Up</span><span class="params">(List *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//对线性表进行降序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort_Down</span><span class="params">(List *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//自定义函数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort_DIY</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">bool</span> (*fun)(Item cur, Item next))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个线性表(简单拼接不排序)返回新的list</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Merge</span><span class="params">(List *list1, List *list2, List *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制线性表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Copy</span><span class="params">(List *list_tobe_copied, List *List_copied_to)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="接口实现-2"><a href="#接口实现-2" class="headerlink" title="接口实现"></a>接口实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序性的链表的定义 List 是指向顺序表的一个指针</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    //存储数据</span></span><br><span class="line"><span class="comment">    Item *items;</span></span><br><span class="line"><span class="comment">    //存储的数据大小</span></span><br><span class="line"><span class="comment">    int size;</span></span><br><span class="line"><span class="comment">    //最大可以容纳的数据大小</span></span><br><span class="line"><span class="comment">    int capacity;</span></span><br><span class="line"><span class="comment">&#125; *List;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//初始化一个空的顺序表</span></span><br><span class="line"><span class="comment">//输入链表，希望获取的容量的大小。</span></span><br><span class="line"><span class="comment">//成功则返回true,反之则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Initialize</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//List是指向顺序表的指针，list是指向该指针的指针</span></span><br><span class="line">    (*<span class="built_in">list</span>) = (ListStruct *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListStruct));</span><br><span class="line">    (*<span class="built_in">list</span>)-&gt;capacity = capacity;</span><br><span class="line">    (*<span class="built_in">list</span>)-&gt;size = <span class="number">0</span>;</span><br><span class="line">    (*<span class="built_in">list</span>)-&gt;items = (Item *)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(Item));</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">list</span>)-&gt;items != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化成功！！！   表的可用容量为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;capacity);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化失败！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个顺序表</span></span><br><span class="line"><span class="comment">//输入一个顺序表，释放其所有内存</span></span><br><span class="line"><span class="comment">//成功则返回true,反之则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Destroy</span><span class="params">(List *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>((*<span class="built_in">list</span>)-&gt;items);</span><br><span class="line">    <span class="built_in">free</span>(*<span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;销毁顺序表成功！！！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空一个顺序表</span></span><br><span class="line"><span class="comment">//清空一个顺序表，但是不要释放其内存</span></span><br><span class="line"><span class="comment">//成功则返回true,反之则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Clear</span><span class="params">(List *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*<span class="built_in">list</span>)-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已清空表，当前表中元素个数为%d,表的可用容量为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;size, (*<span class="built_in">list</span>)-&gt;capacity - (*<span class="built_in">list</span>)-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空表</span></span><br><span class="line"><span class="comment">//空表则返回true,反之则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(List *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">list</span>)-&gt;size == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空表！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不是空表！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否已满</span></span><br><span class="line"><span class="comment">//满则返回true,反之则返回false</span></span><br><span class="line"><span class="comment">//对于顺序表来讲满的话就不能添加元素了，因为申请的内存已经确定了，</span></span><br><span class="line"><span class="comment">//但是链表还可以增加，因为可以再申请内存</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Full</span><span class="params">(List *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">list</span>)-&gt;size == (*<span class="built_in">list</span>)-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;满了！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;还没有满！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//确定元素个数</span></span><br><span class="line"><span class="comment">//返回元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Count</span><span class="params">(List *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前表中元素个数为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> (*<span class="built_in">list</span>)-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定表的容量</span></span><br><span class="line"><span class="comment">//返回表的容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Capacity</span><span class="params">(List *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;表的容量为%d ,表的可用容量为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;capacity, (*<span class="built_in">list</span>)-&gt;capacity - (*<span class="built_in">list</span>)-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> (*<span class="built_in">list</span>)-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加容量为</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddCapacityTo</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> addcapacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curcapacity = (*<span class="built_in">list</span>)-&gt;capacity;</span><br><span class="line">    <span class="keyword">if</span> (addcapacity &gt;= curcapacity)</span><br><span class="line">    &#123;</span><br><span class="line">        (*<span class="built_in">list</span>)-&gt;items = (Item *)<span class="built_in">realloc</span>((*<span class="built_in">list</span>)-&gt;items, addcapacity * <span class="keyword">sizeof</span>(Item));</span><br><span class="line">        (*<span class="built_in">list</span>)-&gt;capacity = addcapacity;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;容量增加成功！！！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表的容量为%d ,表的可用容量为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;capacity, (*<span class="built_in">list</span>)-&gt;capacity - (*<span class="built_in">list</span>)-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;容量增加函数不可以减小容量\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表的容量为%d ,表的可用容量为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;capacity, (*<span class="built_in">list</span>)-&gt;capacity - (*<span class="built_in">list</span>)-&gt;size);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减少容量为</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SubCapacityTo</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> subcapacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curcapacity = (*<span class="built_in">list</span>)-&gt;capacity;</span><br><span class="line">    <span class="keyword">if</span> (subcapacity &lt;= curcapacity &amp;&amp; subcapacity &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        (*<span class="built_in">list</span>)-&gt;items = (Item *)<span class="built_in">realloc</span>((*<span class="built_in">list</span>)-&gt;items, subcapacity * <span class="keyword">sizeof</span>(Item));</span><br><span class="line">        (*<span class="built_in">list</span>)-&gt;capacity = subcapacity;</span><br><span class="line">        <span class="keyword">if</span> ((*<span class="built_in">list</span>)-&gt;size &gt; subcapacity)</span><br><span class="line">        &#123;</span><br><span class="line">            (*<span class="built_in">list</span>)-&gt;size = subcapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;容量减少成功！！！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表的容量为%d ,表的可用容量为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;capacity, (*<span class="built_in">list</span>)-&gt;capacity - (*<span class="built_in">list</span>)-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (subcapacity &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;容量只可以为正数\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表的容量为%d ,表的可用容量为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;capacity, (*<span class="built_in">list</span>)-&gt;capacity - (*<span class="built_in">list</span>)-&gt;size);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;容量减少函数不可以增加容量\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表的容量为%d ,表的可用容量为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;capacity, (*<span class="built_in">list</span>)-&gt;capacity - (*<span class="built_in">list</span>)-&gt;size);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将容量减少到当前实际使用的大小</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Shrink_To_Fit</span><span class="params">(List *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*<span class="built_in">list</span>)-&gt;items = (Item *)<span class="built_in">realloc</span>((*<span class="built_in">list</span>)-&gt;items, (*<span class="built_in">list</span>)-&gt;size * <span class="keyword">sizeof</span>(Item));</span><br><span class="line">    <span class="comment">//表为空的情况下fit也应该成立</span></span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">list</span>)-&gt;items != <span class="literal">NULL</span> || ((*<span class="built_in">list</span>)-&gt;items == <span class="literal">NULL</span> &amp;&amp; (*<span class="built_in">list</span>)-&gt;size == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        (*<span class="built_in">list</span>)-&gt;capacity = (*<span class="built_in">list</span>)-&gt;size;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fit成功！！！表的容量为%d ,表的可用容量为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;capacity, (*<span class="built_in">list</span>)-&gt;capacity - (*<span class="built_in">list</span>)-&gt;size);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fit失败！！！表的容量为%d ,表的可用容量为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;capacity, (*<span class="built_in">list</span>)-&gt;capacity - (*<span class="built_in">list</span>)-&gt;size);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到第i个元素 成功返回true</span></span><br><span class="line"><span class="comment">//将得到的item返回给 item_to_save</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">At</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> location, Item *item_to_save)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">0</span> || location &gt;= (*<span class="built_in">list</span>)-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AT超限！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *item_to_save = (*<span class="built_in">list</span>)-&gt;items[location];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这就是你AT的元素\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一个满足要求的元素的位置，并保存这个元素</span></span><br><span class="line"><span class="comment">//将得到的item返回给 item_to_save    位置返回给location</span></span><br><span class="line"><span class="comment">//若不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateFirst</span><span class="params">(List *<span class="built_in">list</span>, Item *item_to_save, <span class="keyword">bool</span> (*fun)(Item item))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> location = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (*<span class="built_in">list</span>)-&gt;size - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fun((*<span class="built_in">list</span>)-&gt;items[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            location = i;</span><br><span class="line">            *item_to_save = (*<span class="built_in">list</span>)-&gt;items[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (location != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了，第%d个元素满足条件\n&quot;</span>, location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到满足条件的元素\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> location;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回最后一个满足要求的元素的位置，并保存这个元素</span></span><br><span class="line"><span class="comment">//将得到的item返回给 item_to_save    位置返回给location</span></span><br><span class="line"><span class="comment">//若不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateLast</span><span class="params">(List *<span class="built_in">list</span>, Item *item_to_save, <span class="keyword">bool</span> (*fun)(Item item))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> location = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (*<span class="built_in">list</span>)-&gt;size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fun((*<span class="built_in">list</span>)-&gt;items[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            location = i;</span><br><span class="line">            *item_to_save = (*<span class="built_in">list</span>)-&gt;items[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (location != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了，第%d个元素满足条件\n&quot;</span>, location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到满足条件的元素\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> location;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回元素node的前驱 存放在Node*previous</span></span><br><span class="line"><span class="comment">//若没有则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Previous</span><span class="params">(List *<span class="built_in">list</span>, Node *node, Node *previous)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;location &gt;= <span class="number">1</span> &amp;&amp; node-&gt;location &lt;= (*<span class="built_in">list</span>)-&gt;size - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        previous-&gt;location = node-&gt;location - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了前驱！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有前驱！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回元素node的后继 存放在Node*success</span></span><br><span class="line"><span class="comment">//若没有则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Success</span><span class="params">(List *<span class="built_in">list</span>, Node *node, Node *success)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;location &gt;= <span class="number">0</span> &amp;&amp; node-&gt;location &lt;= (*<span class="built_in">list</span>)-&gt;size - <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        success-&gt;location = node-&gt;location + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了后继！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有后继！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置之前插入新的元素，使其称为新的第i个元素</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> location, Item item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*<span class="built_in">list</span>)-&gt;size == (*<span class="built_in">list</span>)-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;满了，不能插入！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location &lt; <span class="number">0</span> || location &gt; (*<span class="built_in">list</span>)-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((*<span class="built_in">list</span>)-&gt;size &lt; (*<span class="built_in">list</span>)-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (*<span class="built_in">list</span>)-&gt;size; i != location; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            (*<span class="built_in">list</span>)-&gt;items[i] = (*<span class="built_in">list</span>)-&gt;items[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        (*<span class="built_in">list</span>)-&gt;items[location] = item;</span><br><span class="line">        (*<span class="built_in">list</span>)-&gt;size++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入成功！！！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表的大小为%d ,表的容量为%d ,表的可用容量为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;size, (*<span class="built_in">list</span>)-&gt;capacity, (*<span class="built_in">list</span>)-&gt;capacity - (*<span class="built_in">list</span>)-&gt;size);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个元素</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">int</span> location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">0</span> || location &gt;= (*<span class="built_in">list</span>)-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = location; i &lt;= (*<span class="built_in">list</span>)-&gt;size - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            (*<span class="built_in">list</span>)-&gt;items[i] = (*<span class="built_in">list</span>)-&gt;items[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        (*<span class="built_in">list</span>)-&gt;size--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功！！！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表的大小为%d ,表的容量为%d ,表的可用容量为%d\n&quot;</span>, (*<span class="built_in">list</span>)-&gt;size, (*<span class="built_in">list</span>)-&gt;capacity, (*<span class="built_in">list</span>)-&gt;capacity - (*<span class="built_in">list</span>)-&gt;size);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用特定的函数遍历顺序表中的每一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">void</span> (*fun)(Item item))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (*<span class="built_in">list</span>)-&gt;size - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fun((*<span class="built_in">list</span>)-&gt;items[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对线性表进行升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort_Up</span><span class="params">(List *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (*<span class="built_in">list</span>)-&gt;size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - <span class="number">1</span> - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*<span class="built_in">list</span>)-&gt;items[j].value &gt; (*<span class="built_in">list</span>)-&gt;items[j - <span class="number">1</span>].value)</span><br><span class="line">            &#123;</span><br><span class="line">                Item temp = (*<span class="built_in">list</span>)-&gt;items[j];</span><br><span class="line">                (*<span class="built_in">list</span>)-&gt;items[j] = (*<span class="built_in">list</span>)-&gt;items[j - <span class="number">1</span>];</span><br><span class="line">                (*<span class="built_in">list</span>)-&gt;items[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对线性表进行降序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort_Down</span><span class="params">(List *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (*<span class="built_in">list</span>)-&gt;size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - <span class="number">1</span> - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*<span class="built_in">list</span>)-&gt;items[j].value &lt; (*<span class="built_in">list</span>)-&gt;items[j - <span class="number">1</span>].value)</span><br><span class="line">            &#123;</span><br><span class="line">                Item temp = (*<span class="built_in">list</span>)-&gt;items[j];</span><br><span class="line">                (*<span class="built_in">list</span>)-&gt;items[j] = (*<span class="built_in">list</span>)-&gt;items[j - <span class="number">1</span>];</span><br><span class="line">                (*<span class="built_in">list</span>)-&gt;items[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义函数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort_DIY</span><span class="params">(List *<span class="built_in">list</span>, <span class="keyword">bool</span> (*fun)(Item cur, Item next))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (*<span class="built_in">list</span>)-&gt;size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fun((*<span class="built_in">list</span>)-&gt;items[j], (*<span class="built_in">list</span>)-&gt;items[j + <span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                Item temp = (*<span class="built_in">list</span>)-&gt;items[j];</span><br><span class="line">                (*<span class="built_in">list</span>)-&gt;items[j] = (*<span class="built_in">list</span>)-&gt;items[j + <span class="number">1</span>];</span><br><span class="line">                (*<span class="built_in">list</span>)-&gt;items[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个线性表(简单拼接不排序)返回新的list</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Merge</span><span class="params">(List *list1, List *list2, List *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = (*<span class="built_in">list</span>)-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> size1 = (*list1)-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> size2 = (*list2)-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> capacity = (*<span class="built_in">list</span>)-&gt;capacity;</span><br><span class="line">    <span class="keyword">int</span> capacity1 = (*list1)-&gt;capacity;</span><br><span class="line">    <span class="keyword">int</span> capacity2 = (*list2)-&gt;capacity;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; size1 + size2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目的表太小了！！！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        (*<span class="built_in">list</span>)-&gt;size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size1 - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            (*<span class="built_in">list</span>)-&gt;items[cur++] = (*list1)-&gt;items[i];</span><br><span class="line">            (*<span class="built_in">list</span>)-&gt;size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size2 - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            (*<span class="built_in">list</span>)-&gt;items[cur++] = (*list2)-&gt;items[i];</span><br><span class="line">            (*<span class="built_in">list</span>)-&gt;size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制线性表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Copy</span><span class="params">(List *list_tobe_copied, List *List_copied_to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size1 = (*list_tobe_copied)-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> size2 = (*List_copied_to)-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> capacity1 = (*list_tobe_copied)-&gt;capacity;</span><br><span class="line">    <span class="keyword">int</span> capacity2 = (*List_copied_to)-&gt;capacity;</span><br><span class="line">    <span class="keyword">if</span> (capacity2 &lt; size1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目标顺序表容量太小了，装不下！！！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Clear(List_copied_to);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size1 - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            (*List_copied_to)-&gt;size++;</span><br><span class="line">            (*List_copied_to)-&gt;items[i] = (*list_tobe_copied)-&gt;items[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口使用-2"><a href="#接口使用-2" class="headerlink" title="接口使用"></a>接口使用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;list.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CAPACITY 100</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun1</span><span class="params">(Item item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.value &gt;= <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(Item item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素： %d\n&quot;</span>, item.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun_sort</span><span class="params">(Item item1, Item item2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item1.value &gt; item2.value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List mylist;</span><br><span class="line">    Item myitem1;</span><br><span class="line">    myitem1.value = <span class="number">0</span>;</span><br><span class="line">    Item item_to_save;</span><br><span class="line">    Node node1;</span><br><span class="line">    node1.location = <span class="number">1</span>;</span><br><span class="line">    Node nodeprevious;</span><br><span class="line">    Node nodesuccess;</span><br><span class="line">    Initialize(&amp;mylist, MAX_CAPACITY);</span><br><span class="line">    <span class="comment">//Destroy(&amp;mylist);</span></span><br><span class="line">    Clear(&amp;mylist);</span><br><span class="line">    Insert(&amp;mylist, <span class="number">0</span>, myitem1);</span><br><span class="line">    Delete(&amp;mylist, <span class="number">0</span>);</span><br><span class="line">    Empty(&amp;mylist);</span><br><span class="line">    Full(&amp;mylist);</span><br><span class="line">    Count(&amp;mylist);</span><br><span class="line">    Capacity(&amp;mylist);</span><br><span class="line">    AddCapacityTo(&amp;mylist, MAX_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    SubCapacityTo(&amp;mylist, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//Shrink_To_Fit(&amp;mylist);</span></span><br><span class="line">    At(&amp;mylist, <span class="number">0</span>, &amp;myitem1);</span><br><span class="line">    LocateFirst(&amp;mylist, &amp;item_to_save, (*fun1));</span><br><span class="line">    LocateLast(&amp;mylist, &amp;item_to_save, (*fun1));</span><br><span class="line">    Previous(&amp;mylist, &amp;node1, &amp;nodeprevious);</span><br><span class="line">    Success(&amp;mylist, &amp;node1, &amp;nodesuccess);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        myitem1.value = i;</span><br><span class="line">        Insert(&amp;mylist, <span class="number">0</span>, myitem1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Sort_Up(&amp;mylist);</span></span><br><span class="line">    Sort_DIY(&amp;mylist, (*fun_sort));</span><br><span class="line">    Traverse(&amp;mylist, (*fun2));</span><br><span class="line"></span><br><span class="line">    List mylist1;</span><br><span class="line">    List mylist2;</span><br><span class="line">    Initialize(&amp;mylist1, <span class="number">10</span>);</span><br><span class="line">    Initialize(&amp;mylist2, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        srand((<span class="keyword">int</span>)time(<span class="literal">NULL</span>) * i);</span><br><span class="line">        myitem1.value = rand() % <span class="number">100</span>;</span><br><span class="line">        Insert(&amp;mylist1, <span class="number">0</span>, myitem1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        srand((<span class="keyword">int</span>)time(<span class="literal">NULL</span>) * i);</span><br><span class="line">        myitem1.value = rand() % <span class="number">10</span>;</span><br><span class="line">        Insert(&amp;mylist2, <span class="number">0</span>, myitem1);</span><br><span class="line">    &#125;</span><br><span class="line">    AddCapacityTo(&amp;mylist, <span class="number">100</span>);</span><br><span class="line">    Merge(&amp;mylist1, &amp;mylist2, &amp;mylist);</span><br><span class="line">    Traverse(&amp;mylist, (*fun2));</span><br><span class="line"></span><br><span class="line">    List mylist3;</span><br><span class="line">    Initialize(&amp;mylist3, <span class="number">100</span>);</span><br><span class="line">    Copy(&amp;mylist, &amp;mylist3);</span><br><span class="line">    Traverse(&amp;mylist3, (*fun2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线性表的链性实现-1"><a href="#线性表的链性实现-1" class="headerlink" title="线性表的链性实现"></a>线性表的链性实现</h2><h3 id="接口说明-3"><a href="#接口说明-3" class="headerlink" title="接口说明"></a>接口说明</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list.h</span></span><br><span class="line"><span class="comment">//线性表的链性实现</span></span><br><span class="line">#<span class="keyword">include</span> &lt;stdbool.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;stdint.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;<span class="built_in">string</span>.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是链表的数据部分</span></span><br><span class="line">typedef <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> value;</span><br><span class="line">&#125; Item;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序性的链表中的一个结点的定义</span></span><br><span class="line"><span class="keyword">struct</span> node</span><br><span class="line">&#123;</span><br><span class="line">    Item item;</span><br><span class="line">    <span class="keyword">struct</span> node *next;</span><br><span class="line">    <span class="keyword">struct</span> node *prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef <span class="keyword">struct</span> node Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//List指针指向Node结点</span></span><br><span class="line">typedef Node *List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空的顺序表</span></span><br><span class="line"><span class="comment">//输入链表，希望获取的容量的大小。</span></span><br><span class="line"><span class="comment">//成功则返回true,反之则返回false</span></span><br><span class="line"><span class="built_in">bool</span> <span class="constructor">Initialize(List <span class="operator">*</span><span class="params">list</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个链表</span></span><br><span class="line"><span class="comment">//输入一个链表，释放其所有内存</span></span><br><span class="line"><span class="comment">//成功则返回true,反之则返回false</span></span><br><span class="line"><span class="built_in">bool</span> <span class="constructor">Destroy(List <span class="operator">*</span><span class="params">list</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空表</span></span><br><span class="line"><span class="comment">//空表则返回true,反之则返回false</span></span><br><span class="line"><span class="built_in">bool</span> <span class="constructor">Empty(List <span class="operator">*</span><span class="params">list</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否已满</span></span><br><span class="line"><span class="comment">//满则返回true,反之则返回false</span></span><br><span class="line"><span class="comment">//对于顺序表来讲满的话就不能添加元素了，因为申请的内存已经确定了，</span></span><br><span class="line"><span class="comment">//但是链表还可以增加，因为可以再申请内存</span></span><br><span class="line"><span class="built_in">bool</span> <span class="constructor">Full(List <span class="operator">*</span><span class="params">list</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定元素个数</span></span><br><span class="line"><span class="comment">//返回元素的个数</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">Count(List <span class="operator">*</span><span class="params">list</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到第i个元素 成功返回true</span></span><br><span class="line"><span class="comment">//将得到的item返回给 item_to_save</span></span><br><span class="line"><span class="built_in">bool</span> <span class="constructor">At(List <span class="operator">*</span><span class="params">list</span>, <span class="params">int</span> <span class="params">i</span>, Item <span class="operator">*</span><span class="params">item_to_save</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一个满足要求的元素的位置，并保存这个元素</span></span><br><span class="line"><span class="comment">//将得到的item返回给 item_to_save    位置返回给location</span></span><br><span class="line"><span class="comment">//若不存在则返回-1</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">LocateFirst(List <span class="operator">*</span><span class="params">list</span>, Item <span class="operator">*</span><span class="params">item_to_save</span>, <span class="params">bool</span> (<span class="operator">*</span><span class="params">fun</span>)</span>(Item item));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回最后一个满足要求的元素的位置，并保存这个元素</span></span><br><span class="line"><span class="comment">//将得到的item返回给 item_to_save    位置返回给location</span></span><br><span class="line"><span class="comment">//若不存在则返回-1</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">LocateLast(List <span class="operator">*</span><span class="params">list</span>, Item <span class="operator">*</span><span class="params">item_to_save</span>, <span class="params">bool</span> (<span class="operator">*</span><span class="params">fun</span>)</span>(Item item));</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置之前插入新的元素，使其称为新的第i个元素</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="built_in">bool</span> <span class="constructor">Insert(List <span class="operator">*</span><span class="params">list</span>, <span class="params">int</span> <span class="params">location</span>, Item <span class="params">item</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个元素</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="built_in">bool</span> <span class="constructor">Delete(List <span class="operator">*</span><span class="params">list</span>, <span class="params">int</span> <span class="params">location</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用特定的函数遍历顺序表中的每一个元素</span></span><br><span class="line">void <span class="constructor">Traverse(List <span class="operator">*</span><span class="params">list</span>, <span class="params">void</span> (<span class="operator">*</span><span class="params">fun</span>)</span>(Item item));</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义函数排序</span></span><br><span class="line">void <span class="constructor">Sort_DIY(List <span class="operator">*</span><span class="params">list</span>, <span class="params">bool</span> (<span class="operator">*</span><span class="params">fun</span>)</span>(Item cur, Item next));</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个线性表(简单拼接不排序)返回新的list</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="built_in">bool</span> <span class="constructor">Merge(List <span class="operator">*</span><span class="params">list1</span>, List <span class="operator">*</span><span class="params">list2</span>, List <span class="operator">*</span><span class="params">list</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制线性表</span></span><br><span class="line"><span class="built_in">bool</span> <span class="constructor">Copy(List <span class="operator">*</span><span class="params">list_tobe_copied</span>, List <span class="operator">*</span>List_copied_to)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="接口实现-3"><a href="#接口实现-3" class="headerlink" title="接口实现"></a>接口实现</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list.c</span></span><br><span class="line"><span class="comment">#include &quot;list.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空的顺序表</span></span><br><span class="line"><span class="comment">//输入链表，希望获取的容量的大小。</span></span><br><span class="line"><span class="comment">//成功则返回true,反之则返回false</span></span><br><span class="line"><span class="keyword">bool</span> Initialize(<span class="keyword">List</span> *<span class="keyword">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="keyword">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;初始化成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;初始化失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个链表</span></span><br><span class="line"><span class="comment">//输入一个链表，释放其所有内存</span></span><br><span class="line"><span class="comment">//成功则返回true,反之则返回false</span></span><br><span class="line"><span class="keyword">bool</span> Destroy(<span class="keyword">List</span> *<span class="keyword">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先找到链表的头</span></span><br><span class="line">    <span class="keyword">List</span> head = *(<span class="keyword">list</span>);</span><br><span class="line">    <span class="comment">//若为空则说明链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;prev != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;到了head\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        free(head-&gt;prev);</span><br><span class="line">    &#125;</span><br><span class="line">    free(head);</span><br><span class="line">    *<span class="keyword">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    printf(<span class="string">&quot;链表已经销毁了\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空表</span></span><br><span class="line"><span class="comment">//空表则返回true,反之则返回false</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">Empty</span>(<span class="keyword">List</span> *<span class="keyword">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先找到链表的头</span></span><br><span class="line">    <span class="keyword">List</span> head = *(<span class="keyword">list</span>);</span><br><span class="line">    <span class="comment">//若为空则说明链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;链表空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;链表不空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否已满</span></span><br><span class="line"><span class="comment">//满则返回true,反之则返回false</span></span><br><span class="line"><span class="comment">//对于顺序表来讲满的话就不能添加元素了，因为申请的内存已经确定了，</span></span><br><span class="line"><span class="comment">//但是链表还可以增加，因为可以再申请内存</span></span><br><span class="line"><span class="keyword">bool</span> Full(<span class="keyword">List</span> *<span class="keyword">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Node *test;</span><br><span class="line">    test = (Node *)malloc(sizeof(Node));</span><br><span class="line">    <span class="keyword">if</span> (test != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;还可以申请空间，所以链表不满\n&quot;</span>);</span><br><span class="line">        free(test);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;不可以申请空间，所以链表满了\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定元素个数</span></span><br><span class="line"><span class="comment">//返回元素的个数</span></span><br><span class="line"><span class="keyword">int</span> Count(<span class="keyword">List</span> *<span class="keyword">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">List</span> head = *<span class="keyword">list</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;元素个数为0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;prev != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;元素个数为%d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到第i个元素 成功返回true</span></span><br><span class="line"><span class="comment">//将得到的item返回给 item_to_save</span></span><br><span class="line"><span class="keyword">bool</span> At(<span class="keyword">List</span> *<span class="keyword">list</span>, <span class="keyword">int</span> i, Item *item_to_save)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> count = Count(<span class="keyword">list</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= count)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;范围超标\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经过上面的判断，现在的链表肯定不空。</span></span><br><span class="line">    <span class="keyword">List</span> head = *(<span class="keyword">list</span>);</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;prev != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = i;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;第%d个元素为%d\n&quot;</span>, n, head-&gt;item.value);</span><br><span class="line">    *item_to_save = head-&gt;item;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一个满足要求的元素的位置，并保存这个元素</span></span><br><span class="line"><span class="comment">//将得到的item返回给 item_to_save    位置返回给location</span></span><br><span class="line"><span class="comment">//若不存在则返回-1</span></span><br><span class="line"><span class="keyword">int</span> LocateFirst(<span class="keyword">List</span> *<span class="keyword">list</span>, Item *item_to_save, <span class="keyword">bool</span> (*fun)(Item item))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">List</span> head = *<span class="keyword">list</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;没有找到。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;prev != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> location = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fun(head-&gt;item))</span><br><span class="line">        &#123;</span><br><span class="line">            *item_to_save = head-&gt;item;</span><br><span class="line">            printf(<span class="string">&quot;找到了，在第%d个元素\n&quot;</span>, location);</span><br><span class="line">            <span class="keyword">return</span> location;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        location++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;没有找到。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回最后一个满足要求的元素的位置，并保存这个元素</span></span><br><span class="line"><span class="comment">//将得到的item返回给 item_to_save    位置返回给location</span></span><br><span class="line"><span class="comment">//若不存在则返回-1</span></span><br><span class="line"><span class="keyword">int</span> LocateLast(<span class="keyword">List</span> *<span class="keyword">list</span>, Item *item_to_save, <span class="keyword">bool</span> (*fun)(Item item))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">List</span> tail = *<span class="keyword">list</span>;</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;没有找到。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> location = Count(<span class="keyword">list</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tail != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fun(tail-&gt;item))</span><br><span class="line">        &#123;</span><br><span class="line">            *item_to_save = tail-&gt;item;</span><br><span class="line">            printf(<span class="string">&quot;找到了，在第%d个元素\n&quot;</span>, location);</span><br><span class="line">            <span class="keyword">return</span> location;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail-&gt;prev;</span><br><span class="line">        location--;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;没有找到。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置之前插入新的元素，使其称为新的第i个元素</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="keyword">bool</span> Insert(<span class="keyword">List</span> *<span class="keyword">list</span>, <span class="keyword">int</span> location, Item item)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">&quot;插入到第%d个\n&quot;</span>, location);</span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">0</span> || location &gt; Count(<span class="keyword">list</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;插入的范围超限\n&quot;);</span></span><br><span class="line">        location = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location &gt; Count(<span class="keyword">list</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;插入的范围超限\n&quot;);</span></span><br><span class="line">        location = Count(<span class="keyword">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">List</span> head = *<span class="keyword">list</span>;</span><br><span class="line">    <span class="keyword">List</span> <span class="keyword">new</span> = (<span class="keyword">List</span>)malloc(sizeof(Node));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;满了,无法插入\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span>-&gt;item = item;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//链表本为空  空就是虚无缥缈的，所以找到一个新的元素给它安家</span></span><br><span class="line">        *<span class="keyword">list</span> = <span class="keyword">new</span>;</span><br><span class="line">        printf(<span class="string">&quot;插入成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表本来就不空</span></span><br><span class="line">    <span class="keyword">while</span> (head-&gt;prev != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    *<span class="keyword">list</span> = head;</span><br><span class="line">    <span class="keyword">int</span> i = location;</span><br><span class="line">    <span class="keyword">List</span> p = head;</span><br><span class="line">    <span class="comment">//头插</span></span><br><span class="line">    <span class="keyword">if</span> (location == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = p;</span><br><span class="line">        p-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾插</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location = Count(<span class="keyword">list</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;prev = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插在中间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i--;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插在p前面</span></span><br><span class="line">        p-&gt;prev-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;prev = p-&gt;prev;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = p;</span><br><span class="line">        p-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;插入成功\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个元素</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="keyword">bool</span> Delete(<span class="keyword">List</span> *<span class="keyword">list</span>, <span class="keyword">int</span> location)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">0</span> || location &gt;= Count(<span class="keyword">list</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;删除的范围超限\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经过上面的判断，现在的链表肯定不空。</span></span><br><span class="line">    <span class="keyword">List</span> head = *(<span class="keyword">list</span>);</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;prev != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    *<span class="keyword">list</span> = head;</span><br><span class="line">    <span class="keyword">int</span> n = location;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除第一个</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;prev == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *<span class="keyword">list</span> = head-&gt;next;</span><br><span class="line">        free(head);</span><br><span class="line">        printf(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">        Count(<span class="keyword">list</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;prev-&gt;next = head-&gt;next;</span><br><span class="line">        free(head);</span><br><span class="line">        printf(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">        Count(<span class="keyword">list</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用特定的函数遍历顺序表中的每一个元素</span></span><br><span class="line"><span class="keyword">void</span> Traverse(<span class="keyword">List</span> *<span class="keyword">list</span>, <span class="keyword">void</span> (*fun)(Item item))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">List</span> head = *<span class="keyword">list</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;空，无法遍历\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;prev != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fun(head-&gt;item);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义函数排序</span></span><br><span class="line"><span class="keyword">void</span> Sort_DIY(<span class="keyword">List</span> *<span class="keyword">list</span>, <span class="keyword">bool</span> (*fun)(Item cur, Item next))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">List</span> head = *<span class="keyword">list</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;prev != <span class="literal">NULL</span>)</span><br><span class="line">        head = head-&gt;prev;</span><br><span class="line">    <span class="keyword">List</span> p = head;</span><br><span class="line">    <span class="keyword">List</span> l1 = head;</span><br><span class="line">    <span class="keyword">List</span> l2 = head;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        l2 = head;</span><br><span class="line">        <span class="keyword">while</span> (l2-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fun(l2-&gt;item, l2-&gt;next-&gt;item))</span><br><span class="line">            &#123;</span><br><span class="line">                Item item = l2-&gt;item;</span><br><span class="line">                l2-&gt;item = l2-&gt;next-&gt;item;</span><br><span class="line">                l2-&gt;next-&gt;item = item;</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个线性表(简单拼接不排序)返回新的list</span></span><br><span class="line"><span class="comment">//成功则返回true</span></span><br><span class="line"><span class="keyword">bool</span> Merge(<span class="keyword">List</span> *list1, <span class="keyword">List</span> *list2, <span class="keyword">List</span> *<span class="keyword">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Destroy(<span class="keyword">list</span>);</span><br><span class="line">    <span class="keyword">List</span> p = *<span class="keyword">list</span>;</span><br><span class="line">    <span class="keyword">List</span> p1 = *list1;</span><br><span class="line">    <span class="keyword">List</span> p2 = *list2;</span><br><span class="line">    <span class="keyword">while</span> (p2-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1-&gt;prev != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p1 = p1-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;next = p1;</span><br><span class="line">    *<span class="keyword">list</span> = p2;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制线性表</span></span><br><span class="line"><span class="keyword">bool</span> Copy(<span class="keyword">List</span> *list_tobe_copied, <span class="keyword">List</span> *List_copied_to)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">List</span> l1 = *list_tobe_copied;</span><br><span class="line">    <span class="keyword">List</span> l2 = *List_copied_to;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Count(&amp;l1) - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(&amp;l2, i, l1-&gt;item);</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口使用-3"><a href="#接口使用-3" class="headerlink" title="接口使用"></a>接口使用</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line">#<span class="keyword">include</span> <span class="string">&quot;list.c&quot;</span></span><br><span class="line">#<span class="keyword">include</span> &lt;time.h&gt;</span><br><span class="line"><span class="built_in">bool</span> fun1(Item item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.value<span class="operator"> == </span><span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">void fun2(Item item)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">&quot;ITEM：%d\n&quot;</span>, item.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bool</span> fun3(Item item1, Item item2)</span><br><span class="line">&#123;</span><br><span class="line">    return (item1.value &gt; item2.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成一个随机的链表</span></span><br><span class="line">List <span class="constructor">RandomList(<span class="params">int</span> <span class="params">size</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List <span class="built_in">list</span>;</span><br><span class="line">    Item item;</span><br><span class="line">    <span class="constructor">Initialize(&amp;<span class="params">list</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= size - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        srand((<span class="built_in">int</span>)time(NULL)<span class="operator"> * </span>i);</span><br><span class="line">        item.value = rand<span class="literal">()</span> % <span class="number">10000</span>;</span><br><span class="line">        <span class="constructor">Insert(&amp;<span class="params">list</span>, <span class="params">i</span>, <span class="params">item</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List <span class="built_in">list</span> = <span class="constructor">RandomList(1000000)</span>;</span><br><span class="line">    <span class="comment">//List list1 = RandomList(10);</span></span><br><span class="line">    <span class="comment">//List list2 = RandomList(10);</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Item item_to_save;</span></span><br><span class="line"><span class="comment">    Item item;</span></span><br><span class="line"><span class="comment">    item.value=0;</span></span><br><span class="line"><span class="comment">    Initialize(&amp;list);</span></span><br><span class="line"><span class="comment">    Destroy(&amp;list);</span></span><br><span class="line"><span class="comment">    Empty(&amp;list);</span></span><br><span class="line"><span class="comment">    Full(&amp;list);</span></span><br><span class="line"><span class="comment">    Count(&amp;list);</span></span><br><span class="line"><span class="comment">    At(&amp;list,0,&amp;item_to_save);</span></span><br><span class="line"><span class="comment">    LocateFirst(&amp;list,&amp;item_to_save,(*fun1));</span></span><br><span class="line"><span class="comment">    LocateLast(&amp;list,&amp;item_to_save,(*fun1));</span></span><br><span class="line"><span class="comment">    Insert(&amp;list,0,item);</span></span><br><span class="line"><span class="comment">    Delete(&amp;list,0);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//Traverse(&amp;list, (*fun2));</span></span><br><span class="line">    Item item;</span><br><span class="line">    item.value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//while(1)</span></span><br><span class="line">    <span class="constructor">Insert(&amp;<span class="params">list</span>, 0, <span class="params">item</span>)</span>;</span><br><span class="line">    <span class="constructor">Sort_DIY(&amp;<span class="params">list</span>, (<span class="operator">*</span><span class="params">fun3</span>)</span>);</span><br><span class="line">    <span class="constructor">Traverse(&amp;<span class="params">list</span>, (<span class="operator">*</span><span class="params">fun2</span>)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 五 AVL 平衡二叉树</title>
    <url>/2021/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%94-AVL-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="AVL-平衡二叉树"><a href="#AVL-平衡二叉树" class="headerlink" title="AVL 平衡二叉树"></a>AVL 平衡二叉树</h1><p>最近在写一个数据库引擎，需要学习一下 B-TREE 的知识，我一看，之前学习数据结构的时候才学习到 AVL 树，这可不行，得加紧学习了，所以今天的任务就是将AVL树弄明白。</p>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><p>平衡二叉树AVLTree和二叉查找树BSTree差不多，只不过平衡二叉树需要保持平衡，即每一个节点的左右两颗子树的高度小于等于1.这样就使得二叉搜索树保持最好的状态，不至于陷入链表的境地。</p>
<p>平衡二叉树的要点在于怎样保持平衡。要解决这个问题首先要搞清楚不平衡的集中条件。</p>
<h2 id="平衡二叉树的失衡姿态。"><a href="#平衡二叉树的失衡姿态。" class="headerlink" title="平衡二叉树的失衡姿态。"></a>平衡二叉树的失衡姿态。</h2><p><strong>对二叉树的描述我就使用插入顺序来描述了。</strong></p>
<p><strong>LL</strong>、<strong>RR</strong>、<strong>LR</strong>、<strong>RL</strong></p>
<p>B1: 失衡结点<br>B2：失衡因节点，因为这个结点才失衡的。<br>B3：失衡因节点的一个祖宗&amp;&amp;失衡结点的一个孙子。</p>
<p>即寻找B3，既是B2的祖宗（自己可以是自己的祖宗），也是B1的孙子。</p>
<p>然后判断B3是B1的哪一个孙子即可得知是哪种情况。</p>
<p>这样直接判断可行性较低，除非在插入的时候明确知道失衡因子。</p>
<p>要想避开寻找失衡因子，可以从失衡结点向下判断两颗高度最大的子树，由这个方向来判断失衡姿态。</p>
<p>但是这样仍有一个问题就是这种情况：</p>
<p>8，4，2，6</p>
<p>失衡因子有两个 2，6 而且失衡银子本身就是失衡节点的孙子。</p>
<p>这样也有解决方案，在寻找两层高度最大的子树的时候将 大于 换为 大于等于 即可，其余同理。</p>
<p>在纠正姿态的时候可能存在数种不同的姿态错误，这时候应当遵循从左往右，从下往上的原则。</p>
<h3 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _AVLTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _AVLTREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) (a&gt;b)?a:b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//AVL TREE</span></span><br><span class="line"><span class="comment">//AVL 树中的任意两个节点的两个子树的高度差最大为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLTREE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Key;</span><br><span class="line">    <span class="comment">//树的高度，即一颗树的最大层次。 par.height=max(left.height,right.height),若一个节点的左右高度差达到了-2或者2，则这棵树不平衡。</span></span><br><span class="line">    <span class="keyword">int</span> Heigth;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLTREE</span> *<span class="title">Left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLTREE</span> *<span class="title">Right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLTREE</span> *<span class="title">Parent</span>;</span></span><br><span class="line">&#125; * AVLTree, *Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL,</span><br><span class="line">    LR,</span><br><span class="line">    RL,</span><br><span class="line">    RR,</span><br><span class="line">    BALANCED    <span class="comment">//已平衡</span></span><br><span class="line">&#125;UNBALANCED_STATUS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空树</span></span><br><span class="line"><span class="function">AVLTree <span class="title">AVLTree_Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据 key 生成一个树结点</span></span><br><span class="line"><span class="function">AVLTree <span class="title">AVLTree_Create</span><span class="params">(<span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一棵树不平衡的状态</span></span><br><span class="line"><span class="function">UNBALANCED_STATUS <span class="title">AVLTree_judge_unbalance_status</span><span class="params">(AVLTree unbalanced_tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是祖宗 自己也是自己的祖宗。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isancestor</span><span class="params">(AVLTree ancestor,AVLTree son)</span></span>;</span><br><span class="line"><span class="comment">//使树平衡。</span></span><br><span class="line"><span class="function">AVLTree <span class="title">AVLTree_make_it_balance</span><span class="params">(AVLTree tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取AVL树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avltree_height</span><span class="params">(AVLTree tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历&quot;AVL树&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_avltree</span><span class="params">(AVLTree tree)</span></span>;</span><br><span class="line"><span class="comment">// 中序遍历&quot;AVL树&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_avltree</span><span class="params">(AVLTree tree)</span></span>;</span><br><span class="line"><span class="comment">// 后序遍历&quot;AVL树&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder_avltree</span><span class="params">(AVLTree tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update_avltree_heigth</span><span class="params">(AVLTree tree)</span></span>;</span><br><span class="line"><span class="comment">//寻找不平衡的结点</span></span><br><span class="line"><span class="function">AVLTree <span class="title">search_unbalanced_tree</span><span class="params">(AVLTree tree)</span></span>;</span><br><span class="line"><span class="comment">//balance</span></span><br><span class="line"><span class="function">AVLTree <span class="title">balance</span><span class="params">(AVLTree tree)</span></span>;</span><br><span class="line"><span class="comment">//height</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height_avltree</span><span class="params">(AVLTree tree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ll_rotation</span><span class="params">(AVLTree k2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rr_rotation</span><span class="params">(AVLTree k2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_avltree</span><span class="params">(AVLTree tree, <span class="keyword">int</span> key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="function">AVLTree <span class="title">avltree_search</span><span class="params">(AVLTree tree, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"><span class="comment">// (非递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="function">AVLTree <span class="title">iterative_avltree_search</span><span class="params">(AVLTree tree, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最小结点：返回tree为根结点的AVL树的最小结点。</span></span><br><span class="line"><span class="function">AVLTree <span class="title">avltree_minimum</span><span class="params">(AVLTree tree)</span></span>;</span><br><span class="line"><span class="comment">// 查找最大结点：返回tree为根结点的AVL树的最大结点。</span></span><br><span class="line"><span class="function">AVLTree <span class="title">avltree_maximum</span><span class="params">(AVLTree tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结点插入到AVL树中，返回根节点</span></span><br><span class="line"><span class="function">AVLTree <span class="title">avltree_insert</span><span class="params">(AVLTree tree, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除结点(key是节点值)，返回根节点</span></span><br><span class="line"><span class="function">AVLTree <span class="title">avltree_delete</span><span class="params">(AVLTree tree, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁AVL树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_avltree</span><span class="params">(AVLTree tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AVLTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">AVLTree_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">AVLTree_Create</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree tree=(AVLTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct AVLTREE));</span><br><span class="line">    tree-&gt;Key=key;</span><br><span class="line">    tree-&gt;Heigth=<span class="number">0</span>;</span><br><span class="line">    tree-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;Parent=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取AVL树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avltree_height</span><span class="params">(AVLTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tree-&gt;Heigth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历&quot;AVL树&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_avltree</span><span class="params">(AVLTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tree-&gt;Key);</span><br><span class="line">    <span class="built_in">preorder_avltree</span>(tree-&gt;Left);</span><br><span class="line">    <span class="built_in">preorder_avltree</span>(tree-&gt;Right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历&quot;AVL树&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_avltree</span><span class="params">(AVLTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder_avltree</span>(tree-&gt;Left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key: %d height: %d\n&quot;</span>,tree-&gt;Key,tree-&gt;Heigth);</span><br><span class="line">    <span class="built_in">inorder_avltree</span>(tree-&gt;Right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历&quot;AVL树&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder_avltree</span><span class="params">(AVLTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder_avltree</span>(tree-&gt;Left);</span><br><span class="line">    <span class="built_in">postorder_avltree</span>(tree-&gt;Right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tree-&gt;Key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update_avltree_heigth</span><span class="params">(AVLTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> hei_left=<span class="built_in">update_avltree_heigth</span>(tree-&gt;Left);</span><br><span class="line">        <span class="keyword">int</span> hei_right=<span class="built_in">update_avltree_heigth</span>(tree-&gt;Right);</span><br><span class="line">        tree-&gt;Heigth=(<span class="built_in">MAX</span>(hei_left,hei_right))+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;hei_left: %d hei_right: %d height: %d\n&quot;,hei_left,hei_right,tree-&gt;Heigth);</span></span><br><span class="line">        <span class="keyword">return</span> tree-&gt;Heigth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找不平衡的结点</span></span><br><span class="line"><span class="function">AVLTree <span class="title">search_unbalanced_tree</span><span class="params">(AVLTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到引起失衡的节点 自己失衡，但是孩子不失衡。</span></span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update_avltree_heigth</span>(tree);</span><br><span class="line">    <span class="comment">//记得在这之前更新树的高度</span></span><br><span class="line">    <span class="keyword">int</span> hei_left=(tree-&gt;Left)?tree-&gt;Left-&gt;Heigth:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hei_right=(tree-&gt;Right)?tree-&gt;Right-&gt;Heigth:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hei_sub=<span class="built_in">abs</span>(hei_left-hei_right);</span><br><span class="line">    <span class="keyword">if</span>(hei_sub&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//平衡</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">search_unbalanced_tree</span>(tree-&gt;Left)!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search_unbalanced_tree</span>(tree-&gt;Left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">search_unbalanced_tree</span>(tree-&gt;Right)!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search_unbalanced_tree</span>(tree-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hei_sub&gt;=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结点插入到AVL树中，返回根节点</span></span><br><span class="line"><span class="function">AVLTree <span class="title">avltree_insert</span><span class="params">(AVLTree tree, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//插入之后分为四种平衡破坏的状态</span></span><br><span class="line">    AVLTree result=<span class="literal">NULL</span>;</span><br><span class="line">    AVLTree tree_to_insert=<span class="built_in">AVLTree_Create</span>(key);</span><br><span class="line">    AVLTree p=tree;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;Key&lt;=key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果p的右孩子为空则插入到右</span></span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;Right)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;Right=tree_to_insert;</span><br><span class="line">                tree_to_insert-&gt;Parent=p;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p=p-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;Key&gt;=key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;Left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//插入为左孩子</span></span><br><span class="line">                p-&gt;Left=tree_to_insert;</span><br><span class="line">                tree_to_insert-&gt;Parent=p;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//说明树本为空</span></span><br><span class="line">        tree=tree_to_insert;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//result= AVLTree_make_it_balance(tree);</span></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除结点(key是节点值)，返回根节点</span></span><br><span class="line"><span class="function">AVLTree <span class="title">avltree_delete</span><span class="params">(AVLTree tree, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree p=tree;</span><br><span class="line">    AVLTree result=tree;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;Key&lt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;Key&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到了 </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到这个结点 %d \n&quot;</span>,key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//找到了结点进行删除并再次平衡。</span></span><br><span class="line">        <span class="comment">//1. 删除的是头节点按 3 4 行事</span></span><br><span class="line">        <span class="comment">//2. 删除的是叶子则直接free</span></span><br><span class="line">        <span class="comment">//3. 删除的结点只有一个孩子则继承其位置</span></span><br><span class="line">        <span class="comment">//4. 删除的结点两个孩子都有，则若其为左孩子，则将其右孩子插入其左孩子的最右边。若其为右孩子，则将其左孩子插入其右孩子的最左边</span></span><br><span class="line">        AVLTree tree_to_del=p;</span><br><span class="line">        AVLTree pre_root=<span class="built_in">AVLTree_Create</span>(<span class="number">0</span>);</span><br><span class="line">        pre_root-&gt;Left=tree;</span><br><span class="line">        tree-&gt;Parent=pre_root;</span><br><span class="line">        <span class="comment">//现在设一个傀儡 pre_root 这样头节点和其他结点都一样了</span></span><br><span class="line">        <span class="comment">//1. 叶子没有孩子</span></span><br><span class="line">        <span class="keyword">if</span>((!tree_to_del-&gt;Left)&amp;&amp;(!tree_to_del-&gt;Right))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tree_to_del-&gt;Parent-&gt;Left==tree_to_del)</span><br><span class="line">                tree_to_del-&gt;Parent-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span>(tree_to_del-&gt;Parent-&gt;Right==tree_to_del)</span><br><span class="line">                tree_to_del-&gt;Parent-&gt;Right=<span class="literal">NULL</span>;    </span><br><span class="line">            <span class="built_in">free</span>(tree_to_del);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((tree_to_del-&gt;Left!=<span class="literal">NULL</span>)&amp;&amp;(tree_to_del-&gt;Right==<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//只有左孩子</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(tree_to_del-&gt;Parent-&gt;Left==tree_to_del)</span><br><span class="line">                tree_to_del-&gt;Parent-&gt;Left=tree_to_del-&gt;Left;</span><br><span class="line">            <span class="keyword">if</span>(tree_to_del-&gt;Parent-&gt;Right==tree_to_del)</span><br><span class="line">                tree_to_del-&gt;Parent-&gt;Right=tree_to_del-&gt;Left;</span><br><span class="line">                </span><br><span class="line">            tree_to_del-&gt;Left-&gt;Parent=tree_to_del-&gt;Parent; </span><br><span class="line">            tree_to_del-&gt;Left-&gt;Heigth--;</span><br><span class="line">            <span class="built_in">free</span>(tree_to_del);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((tree_to_del-&gt;Left==<span class="literal">NULL</span>)&amp;&amp;(tree_to_del-&gt;Right!=<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//只有右孩子</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(tree_to_del-&gt;Parent-&gt;Left==tree_to_del)</span><br><span class="line">                tree_to_del-&gt;Parent-&gt;Left=tree_to_del-&gt;Right;</span><br><span class="line">            <span class="keyword">if</span>(tree_to_del-&gt;Parent-&gt;Right==tree_to_del)</span><br><span class="line">                tree_to_del-&gt;Parent-&gt;Right=tree_to_del-&gt;Right;</span><br><span class="line">            </span><br><span class="line">            tree_to_del-&gt;Right-&gt;Parent=tree_to_del-&gt;Parent; </span><br><span class="line">            tree_to_del-&gt;Right-&gt;Heigth--;</span><br><span class="line">            <span class="built_in">free</span>(tree_to_del);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//两个孩子都有</span></span><br><span class="line">            <span class="comment">//若其为左孩子，则将其右孩子插入其左孩子的最右边。若其为右孩子，则将其左孩子插入其右孩子的最左边</span></span><br><span class="line">            <span class="keyword">if</span>(tree_to_del-&gt;Parent-&gt;Left==tree_to_del)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//我觉得不管删除的结点时左孩子还是右孩子，都让其左孩子替代其位置，其右孩子插入到左孩子的最右边</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//寻找左孩子的最右边</span></span><br><span class="line">                AVLTree MAX_Right=tree_to_del-&gt;Left;</span><br><span class="line">                <span class="keyword">while</span>(MAX_Right-&gt;Right)</span><br><span class="line">                &#123;</span><br><span class="line">                    MAX_Right=MAX_Right-&gt;Right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将右孩子插入进去</span></span><br><span class="line">                MAX_Right-&gt;Right=tree_to_del-&gt;Right;</span><br><span class="line">                tree_to_del-&gt;Right-&gt;Parent=MAX_Right;</span><br><span class="line">                <span class="comment">//更新其深度信息。 略</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//放置左孩子</span></span><br><span class="line">                <span class="keyword">if</span>(tree_to_del-&gt;Parent-&gt;Left==tree_to_del)</span><br><span class="line">                    tree_to_del-&gt;Parent-&gt;Left=tree_to_del-&gt;Left;</span><br><span class="line">                <span class="keyword">if</span>(tree_to_del-&gt;Parent-&gt;Right==tree_to_del)</span><br><span class="line">                    tree_to_del-&gt;Parent-&gt;Right=tree_to_del-&gt;Left;</span><br><span class="line">                tree_to_del-&gt;Left-&gt;Parent=tree_to_del-&gt;Parent; </span><br><span class="line">                tree_to_del-&gt;Left-&gt;Heigth--;</span><br><span class="line">                <span class="comment">//现在其左孩子已经坐上了他的位置。</span></span><br><span class="line">                <span class="built_in">free</span>(tree_to_del);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头归原主</span></span><br><span class="line">        tree=pre_root-&gt;Left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除完成，需要判断不平衡的状态并进行修正。</span></span><br><span class="line">    <span class="comment">//result=AVLTree_make_it_balance(tree);</span></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一棵树不平衡的状态</span></span><br><span class="line"><span class="function">UNBALANCED_STATUS <span class="title">AVLTree_judge_unbalance_status</span><span class="params">(AVLTree unbalanced_tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LL, LR, RL, RR, balanceD  </span></span><br><span class="line">    AVLTree tree=unbalanced_tree;</span><br><span class="line">    <span class="comment">//B1: 失衡结点</span></span><br><span class="line">    <span class="comment">//B2：失衡因节点，因为这个结点才失衡的。</span></span><br><span class="line">    <span class="comment">//B3：失衡因节点的一个祖宗&amp;&amp;失衡结点的一个孙子。</span></span><br><span class="line">    <span class="comment">//即寻找B3，既是B2的祖宗（自己可以是自己的祖宗），也是B1的孙子。</span></span><br><span class="line">    <span class="comment">//然后判断B3是B1的哪一个孙子即可得知是哪种情况。</span></span><br><span class="line">    <span class="comment">//向下找两层高度最大的子树，其方向就是不平衡的状态。</span></span><br><span class="line">    <span class="comment">//加等于号为了防止判断不出来 不如这种情况 10 5 1 7 </span></span><br><span class="line">    <span class="comment">//L</span></span><br><span class="line">    <span class="comment">//height_avltree</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">height_avltree</span>(tree-&gt;Left)&gt;=<span class="built_in">height_avltree</span>(tree-&gt;Right))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//L</span></span><br><span class="line">        AVLTree tree_l=tree-&gt;Left;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">height_avltree</span>(tree_l-&gt;Left)&gt;=<span class="built_in">height_avltree</span>(tree_l-&gt;Right))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> LL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">height_avltree</span>(tree_l-&gt;Left)&lt;<span class="built_in">height_avltree</span>(tree_l-&gt;Right))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> LR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//R</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">height_avltree</span>(tree-&gt;Left)&lt;<span class="built_in">height_avltree</span>(tree-&gt;Right))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//L</span></span><br><span class="line">        AVLTree tree_r=tree-&gt;Right;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">height_avltree</span>(tree_r-&gt;Left)&gt;<span class="built_in">height_avltree</span>(tree_r-&gt;Right))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> RL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">height_avltree</span>(tree_r-&gt;Left)&lt;=<span class="built_in">height_avltree</span>(tree_r-&gt;Right))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> RR;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BALANCED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使树平衡。</span></span><br><span class="line"><span class="function">AVLTree <span class="title">AVLTree_make_it_balance</span><span class="params">(AVLTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree result=tree;</span><br><span class="line">    <span class="comment">//设一个傀儡头节点</span></span><br><span class="line">    AVLTree preroot=<span class="built_in">AVLTree_Create</span>(<span class="number">0</span>);</span><br><span class="line">    preroot-&gt;Left=tree;</span><br><span class="line">    tree-&gt;Parent=preroot;</span><br><span class="line">    <span class="comment">//更新高度</span></span><br><span class="line">    <span class="built_in">update_avltree_heigth</span>(tree);</span><br><span class="line">    <span class="comment">//寻找不平衡的结点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">search_unbalanced_tree</span>(tree))</span><br><span class="line">    &#123;</span><br><span class="line">        AVLTree unbalanced_tree=<span class="built_in">search_unbalanced_tree</span>(tree);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;结点：%d 不平衡\n&quot;</span>,unbalanced_tree-&gt;Key);</span><br><span class="line">        <span class="comment">//更新高度成功，现在肯可能造成不平衡的只有tree_to_insert,所以判断其父节点的高度信息即可。</span></span><br><span class="line">        <span class="comment">//插入完成，需要判断不平衡的状态并进行修正。</span></span><br><span class="line">        UNBALANCED_STATUS status=<span class="built_in">AVLTree_judge_unbalance_status</span>(unbalanced_tree);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//status=LR;</span></span><br><span class="line">        <span class="keyword">if</span>(status==LL)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ll\n&quot;</span>);</span><br><span class="line">            <span class="built_in">ll_rotation</span>(unbalanced_tree);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(status==LR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;lr\n&quot;</span>);</span><br><span class="line">            <span class="comment">//绕两次，</span></span><br><span class="line">            AVLTree k1=unbalanced_tree-&gt;Left;</span><br><span class="line">            AVLTree k2=unbalanced_tree;</span><br><span class="line">            <span class="built_in">rr_rotation</span>(k1);</span><br><span class="line">            <span class="built_in">ll_rotation</span>(k2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(status==RR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;rr\n&quot;</span>);</span><br><span class="line">            <span class="built_in">rr_rotation</span>(unbalanced_tree);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(status==RL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;rl\n&quot;</span>);</span><br><span class="line">            <span class="comment">//绕两次</span></span><br><span class="line">            AVLTree k1=unbalanced_tree-&gt;Right;</span><br><span class="line">            AVLTree k2=unbalanced_tree;</span><br><span class="line">            <span class="built_in">ll_rotation</span>(k1);</span><br><span class="line">            <span class="built_in">rr_rotation</span>(k2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;balance\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;树平衡\n&quot;</span>);</span><br><span class="line">    result=preroot-&gt;Left;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">balance</span><span class="params">(AVLTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">search_unbalanced_tree</span>(tree))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//update_avltree_heigth(tree);</span></span><br><span class="line">        tree=<span class="built_in">AVLTree_make_it_balance</span>(tree);</span><br><span class="line">        <span class="comment">//print_avltree(tree,tree-&gt;Key,0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//height</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height_avltree</span><span class="params">(AVLTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> tree-&gt;Heigth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ll_rotation</span><span class="params">(AVLTree k2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//k1替代k2,k1的右孩子变成k2的左孩子,k2变成k1的右孩子，。</span></span><br><span class="line">    AVLTree k1 = k2-&gt;Left;</span><br><span class="line">    <span class="keyword">if</span> (k2-&gt;Parent-&gt;Left == k2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//k2是左孩子</span></span><br><span class="line">        k2-&gt;Parent-&gt;Left = k1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        k2-&gt;Parent-&gt;Right = k1;</span><br><span class="line">    &#125;</span><br><span class="line">    k1-&gt;Parent=k2-&gt;Parent;</span><br><span class="line">    k2-&gt;Left = k1-&gt;Right;</span><br><span class="line">    <span class="keyword">if</span> (k1-&gt;Right)</span><br><span class="line">        k1-&gt;Right-&gt;Parent = k2;</span><br><span class="line">    k2-&gt;Left=k1-&gt;Right;</span><br><span class="line">    k2-&gt;Parent = k1;</span><br><span class="line">    k1-&gt;Right = k2;</span><br><span class="line">    <span class="comment">//return k1;   </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rr_rotation</span><span class="params">(AVLTree k2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//k1替代k2 k1的左孩子变成k2的右孩子，k2变为k1的左孩子。</span></span><br><span class="line">    AVLTree k1=k2-&gt;Right;</span><br><span class="line">    <span class="keyword">if</span>(k2-&gt;Parent-&gt;Left==k2)</span><br><span class="line">    &#123;</span><br><span class="line">        k2-&gt;Parent-&gt;Left=k1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        k2-&gt;Parent-&gt;Right=k1;</span><br><span class="line">    &#125;</span><br><span class="line">    k1-&gt;Parent=k2-&gt;Parent;</span><br><span class="line">    <span class="keyword">if</span>(k1-&gt;Left)</span><br><span class="line">        k1-&gt;Left-&gt;Parent=k2;</span><br><span class="line">    k2-&gt;Right=k1-&gt;Left;</span><br><span class="line">    k2-&gt;Parent=k1;</span><br><span class="line">    k1-&gt;Left=k2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="function">AVLTree <span class="title">avltree_search</span><span class="params">(AVLTree tree, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tree-&gt;Key==key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了 %d \n&quot;</span>,key);</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;tree-&gt;Key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">avltree_search</span>(tree-&gt;Left,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;tree-&gt;Key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">avltree_search</span>(tree-&gt;Right,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (非递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="function">AVLTree <span class="title">iterative_avltree_search</span><span class="params">(AVLTree tree, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tree-&gt;Key==key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到了 %d \n&quot;</span>,tree-&gt;Key);</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree-&gt;Key&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            tree=tree-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree-&gt;Key&lt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            tree=tree-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最小结点：返回tree为根结点的AVL树的最小结点。</span></span><br><span class="line"><span class="function">AVLTree <span class="title">avltree_minimum</span><span class="params">(AVLTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree min=tree;</span><br><span class="line">    <span class="keyword">if</span>(min==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(min-&gt;Left)</span><br><span class="line">        &#123;</span><br><span class="line">            min=min-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找最大结点：返回tree为根结点的AVL树的最大结点。</span></span><br><span class="line"><span class="function">AVLTree <span class="title">avltree_maximum</span><span class="params">(AVLTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree max=tree;</span><br><span class="line">    <span class="keyword">if</span>(max==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(max-&gt;Right)</span><br><span class="line">        &#123;</span><br><span class="line">            max=max-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_avltree</span><span class="params">(AVLTree tree, <span class="keyword">int</span> key, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2d is root\n&quot;</span>, tree-&gt;Key, key);</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2d is %2d&#x27;s %6s child\n&quot;</span>, tree-&gt;Key, key, direction==<span class="number">1</span>?<span class="string">&quot;right&quot;</span> : <span class="string">&quot;left&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print_avltree</span>(tree-&gt;Left, tree-&gt;Key, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">print_avltree</span>(tree-&gt;Right,tree-&gt;Key,  <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁AVL树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_avltree</span><span class="params">(AVLTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">destroy_avltree</span>(tree-&gt;Left);</span><br><span class="line">    <span class="built_in">destroy_avltree</span>(tree-&gt;Right);</span><br><span class="line">    tree-&gt;Parent=<span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;avltree.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree tree=<span class="built_in">AVLTree_Init</span>();</span><br><span class="line">    tree=<span class="built_in">avltree_insert</span>(tree,<span class="number">10</span>);</span><br><span class="line">    tree=<span class="built_in">avltree_insert</span>(tree,<span class="number">15</span>);</span><br><span class="line">    tree=<span class="built_in">avltree_insert</span>(tree,<span class="number">8</span>);</span><br><span class="line">    tree=<span class="built_in">avltree_insert</span>(tree,<span class="number">7</span>);</span><br><span class="line">    tree=<span class="built_in">avltree_insert</span>(tree,<span class="number">9</span>);</span><br><span class="line">    <span class="comment">//tree=avltree_delete(tree,15);</span></span><br><span class="line">    <span class="built_in">inorder_avltree</span>(tree);</span><br><span class="line">    <span class="built_in">print_avltree</span>(tree,tree-&gt;Key,<span class="number">0</span>);</span><br><span class="line">    tree=<span class="built_in">balance</span>(tree);</span><br><span class="line">    <span class="built_in">print_avltree</span>(tree,tree-&gt;Key,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;search %d \n&quot;</span>,<span class="built_in">avltree_search</span>(tree,<span class="number">10</span>)?<span class="built_in">avltree_search</span>(tree,<span class="number">10</span>)-&gt;Key:<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;search %d \n&quot;</span>,<span class="built_in">iterative_avltree_search</span>(tree,<span class="number">7</span>)?<span class="built_in">iterative_avltree_search</span>(tree,<span class="number">7</span>)-&gt;Key:<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min: %d \n&quot;</span>,<span class="built_in">avltree_minimum</span>(tree)-&gt;Key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min: %d \n&quot;</span>,<span class="built_in">avltree_maximum</span>(tree)-&gt;Key);</span><br><span class="line">    <span class="built_in">destroy_avltree</span>(tree);</span><br><span class="line">    <span class="comment">//printf(&quot;min: %d \n&quot;,avltree_maximum(tree)-&gt;Key);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leedcode 初级算法 树</title>
    <url>/2021/08/04/leedcode-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95-%E6%A0%91/</url>
    <content><![CDATA[<h1 id="leedcode-初级算法-树"><a href="#leedcode-初级算法-树" class="headerlink" title="leedcode 初级算法 树"></a>leedcode 初级算法 树</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x28wnt/">链接</a></p>
<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><h6 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h6><p>求二叉树的最大深度</p>
<h6 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h6><p>使用递归求解即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(struct TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right=<span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (left&gt;=right?left+<span class="number">1</span>:right+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<h6 id="题目解析-方法一"><a href="#题目解析-方法一" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>递归验证即可。</p>
<p>或者中序遍历也可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_right</span><span class="params">(struct TreeNode* root,<span class="keyword">long</span> low,<span class="keyword">long</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&lt;=low||root-&gt;val&gt;=up)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">is_right</span>(root-&gt;left,low,root-&gt;val)&amp;&amp;<span class="built_in">is_right</span>(root-&gt;right,root-&gt;val,up);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(struct TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">is_right</span>(root,LONG_MIN,LONG_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二"><a href="#题目解析-方法二" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>中序遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cur =INT_MIN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,cur);</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValidBST</span>(root-&gt;left))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,cur,root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur &gt;= root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        cur = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValidBST</span>(root-&gt;right))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><h6 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<h6 id="题目解析-方法一-1"><a href="#题目解析-方法一-1" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>中序遍历的方法不可行，形状判定很复杂。</p>
<p>使用递归，若像棵树镜像，则一棵树的左子树必定和另一棵树的右子树镜像。递归判断即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_right</span><span class="params">(struct TreeNode *left, struct TreeNode *right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!left || !right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> ((left-&gt;val == right-&gt;val) &amp;&amp; <span class="built_in">is_right</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">is_right</span>(left-&gt;right, right-&gt;left));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">is_right</span>(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="题目解析-方法二-1"><a href="#题目解析-方法二-1" class="headerlink" title="题目解析 方法二"></a>题目解析 方法二</h6><p>使用队列啊ing递归改为迭代</p>
<p>每次从队列中取出要进行比较的两个结点，不相等的直接返回，相等则按相反顺序插入四个孩子到队列。直到队列为空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        deque&lt;TreeNode *&gt; q;</span><br><span class="line">        q.<span class="built_in">push_back</span>(root);</span><br><span class="line">        q.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *left = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            TreeNode *right = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span> (!left &amp;&amp; !right)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!left || !right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val != right-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//现在 left right 都不空 逆序存入</span></span><br><span class="line">            q.<span class="built_in">push_back</span>(left-&gt;left);</span><br><span class="line">            q.<span class="built_in">push_back</span>(right-&gt;right);</span><br><span class="line">            q.<span class="built_in">push_back</span>(left-&gt;right);</span><br><span class="line">            q.<span class="built_in">push_back</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><h6 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h6><p>层序遍历二叉树</p>
<h6 id="题目解析-方法一-2"><a href="#题目解析-方法一-2" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>根结点入队。key_num记录每一层的个数，出队一个存入数组，入队其孩子。更新key_num。直到队空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode *root)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        deque&lt;TreeNode *&gt; q;</span><br><span class="line">        <span class="keyword">int</span> key_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp_key_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        q.<span class="built_in">push_back</span>(root);</span><br><span class="line">        key_num++;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">            TreeNode *t;</span><br><span class="line">            <span class="keyword">while</span> (key_num &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t = q.<span class="built_in">front</span>();</span><br><span class="line">                v1.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">                key_num--;</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push_back</span>(t-&gt;left);</span><br><span class="line">                    temp_key_num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push_back</span>(t-&gt;right);</span><br><span class="line">                    temp_key_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            key_num = temp_key_num;</span><br><span class="line">            temp_key_num = <span class="number">0</span>;</span><br><span class="line">            v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h4><h6 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h6><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>
<p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<h6 id="题目解析-方法一-3"><a href="#题目解析-方法一-3" class="headerlink" title="题目解析 方法一"></a>题目解析 方法一</h6><p>AVL树插入的时候可能涉及不平衡需要进行旋转，但是现在是从一个确定的数组中插入，故不需要进行旋转，只需要判断插入的顺序即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//TreeNode *root = (TreeNode *)malloc(sizeof(struct TreeNode));</span></span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        root-&gt;val=nums.<span class="built_in">at</span>(nums.<span class="built_in">size</span>() / <span class="number">2</span>);</span><br><span class="line">        root-&gt;left = <span class="built_in">insert</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() / <span class="number">2</span>, root);</span><br><span class="line">        root-&gt;right = <span class="built_in">insert</span>(nums, nums.<span class="built_in">size</span>() / <span class="number">2</span> + <span class="number">1</span>, nums.<span class="built_in">size</span>(), root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">insert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> up, TreeNode *pa)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low != up)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//TreeNode *t = (TreeNode *)malloc(sizeof(struct TreeNode));</span></span><br><span class="line">            TreeNode *t = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">            t-&gt;val=nums.<span class="built_in">at</span>((low + up) / <span class="number">2</span>);</span><br><span class="line">            t-&gt;left = <span class="built_in">insert</span>(nums, low, (low + up) / <span class="number">2</span>, t);</span><br><span class="line">            t-&gt;right = <span class="built_in">insert</span>(nums, (low + up) / <span class="number">2</span> + <span class="number">1</span>, up, t);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
        <category>leedcode</category>
      </categories>
      <tags>
        <tag>leedcode</tag>
        <tag>初级算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 七 红黑树</title>
    <url>/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%83-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h1 id="数据结构-七-红黑树"><a href="#数据结构-七-红黑树" class="headerlink" title="数据结构 七 红黑树"></a>数据结构 七 红黑树</h1><p>听说红黑树很难，不知道究竟有多难，现在来试一下。</p>
<p><a href="https://www.jianshu.com/p/e136ec79235c">参考资料</a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>红黑树是一个自平衡的二叉查找树，每一个结点增加一个标识结点颜色的位（红色或者黑色），通过对任何一条从根节点到叶子的路径上结点着色方式的限制，红黑树保证不存在一条路径会比其他路径长两倍。红黑树不保证绝对的平衡。</p>
<p>nil:指的是红黑树的叶子，但是红黑树的叶子别的树不同，这里的叶子指的是空指针域，可以看作每一个child指针若为null则指向空指针域nil</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li>每一个结点是红的或者黑的。</li>
<li>根节点是黑色的。</li>
<li>空指针域为黑色的。即NULL指针看作黑色。</li>
<li>红色结点的孩子都是黑色的。</li>
<li>对于每一个结点，到以其为根的叶子结点所经过的黑色结点的数目相同。（这里的叶子结点指的是空指针域，以哨兵装入其内）</li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>将当前结点旋转为其右孩子的左孩子，并将其右孩子的左孩子设置为当前节点的右孩子。</p>
<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>将当前结点旋转为其左孩子的右孩子，并将其左孩子的右孩子设置为当前节点的左孩子。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>首先假设插入的结点为红色。因为红色结点不会影响红黑树这一条性质 <strong>对于每一个结点，到其叶子结点的所有路径上黑色结点的数目相同。</strong></p>
<p>插入的结点为根节点或者父节点为黑色则直接插入即可，因为这种情况下不会影响红黑树的成立。</p>
<p>当插入的结点的父节点为红色的是候分以下两种情况。</p>
<ol>
<li><p>父节点和叔叔都是红色的。</p>
</li>
<li><p>父节点是红色，叔叔结点是黑色的或者叔叔结点不存在。</p>
</li>
</ol>
<p>对于第一种情况，这样处理：</p>
<blockquote>
<p>将父亲和叔叔设置为黑色，将祖父设置为红色 递归处理父节点。<br>祖父节点必为黑色，这种情况下破坏了性质4，红色结点的孩子都是黑色，所以需要将父节点进行变色为黑色来满足这条限制，但是这样的话祖父节点到其下叶节点的黑色节点数量就不一样了，所以顺便也将叔叔结点变为黑色。这样以祖父节点为根的红黑树平衡了，但是由于叔叔和父亲结点都变成了黑色，所以祖父的祖先节点就不平衡了，因为这导致了祖父这一条路上的黑色结点数量加一了，但是又考虑到祖父节点为黑色，现在父亲结点和叔叔又都是黑色，所以顺势将祖父结点变为红色不就可以了吗。于是祖父这一棵树完全平衡了，只有一点就是祖父的颜色可能不对劲，曾祖父如果是红色的话就不行，所以将祖父当作当前的结点递归进行处理。<strong>这种多个变量同是作用并且恰如其分地造成想要的结果真是精妙呀，不知道这棵树的发明者是怎样想到的</strong>。</p>
</blockquote>
<p>对于第二种情况（第一种情况递归之后也可能进入这种情况），父亲和叔叔都是红色，分为以下四种情况。分别进行处理                  </p>
<p>祖父结点必为黑色,所以需要找到一种方法使得祖父节点这棵树满足条件而且变化要少。想到可以以父节点代替祖父。这样颜色和黑色结点数量都满足了。</p>
<ol>
<li>父节点是祖父节点的左孩子 <ol>
<li>当前节点是父节点的左孩子。  父节点设为黑色 祖父节点设为红色 对祖父节点进行右旋</li>
<li>当前节点是父节点的右孩子。  将父节点设为当前节点并进行左旋。递归进行。（其实就是转化为上面这种情况）</li>
</ol>
</li>
<li>父节点是祖父节点的右孩子 <ol>
<li>当前节点是父节点的左孩子。  将父节点设为当前结点并进行右旋 递归（其实就是转化为下面这种情况）</li>
<li>当前节点是父节点的右孩子。  父节点设为黑色 祖父设为红色 并对祖父进行左旋</li>
</ol>
</li>
</ol>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在红黑树中当结点为空是，其颜色看作黑色。</p>
<p>首先按照二叉搜索树一样进行删除，之后进行fix_up即可。</p>
<p>BSTree 删除方法：</p>
<ol>
<li>若删除结点时叶子的话，直接删除。</li>
<li>若有左孩子，则使用左子树的最大值代替，递归直到叶子。</li>
<li>若有右孩子，则使用右子树的最小值代替，递归直到叶子。</li>
</ol>
<p>fix_up: 现在我们已经将要删除的结点换为一个叶子节点了。记为 del_tree 但是在正式删除之前还需要先旋转着色确保删除之后树的平衡 记当前正在处理平衡的结点为 cur_tree </p>
<ol>
<li>结点为根节点，直接返回。结点为红色，设为黑色，直接返回。若兄弟结点为空，则如果父结点为红色则父结点变为黑色，直接返回。若父结点为黑色，则递归处理父结点。</li>
<li>结点为黑色<ol>
<li>结点为其父节点的左孩子<ol>
<li>兄弟结点是红色<blockquote>
<p>父节点设为红色 兄弟结点设为黑色 对父节点进行左旋 递归处理当前结点</p>
</blockquote>
</li>
<li>兄弟结点为黑色<ol>
<li>兄弟结点的右孩子为红色，左孩子任意<blockquote>
<p>将兄弟颜色设为为父节点的颜色 父节点设为黑色 兄弟结点的右孩子设为黑色 对父节点进行左旋  结束</p>
</blockquote>
</li>
<li>兄弟结点的右孩子为黑色或者不存在，左孩子为红色 <blockquote>
<p>兄弟设为红色 兄弟的左孩子设为黑色 对兄弟结点进行右旋 此时得到上面这种情况 当前处理结点不变 递归</p>
</blockquote>
</li>
<li>兄弟结点的孩子都是黑色 <blockquote>
<p>将兄弟结点设为红色 父节点设为当前结点 递归</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li>结点为其父节点的右孩子<ol>
<li>兄弟结点为红色<blockquote>
<p>父节点设为红色 兄弟结点设为黑色 对父节点进行右旋 递归处理当前结点</p>
</blockquote>
</li>
<li>兄弟结点为黑色<ol>
<li>兄弟结点的左孩子为红色 右孩子任意 <blockquote>
<p>将兄弟结点设为父节点的颜色 父节点设为黑色 兄弟结点的左孩子 对父节点进行右旋  结束</p>
</blockquote>
</li>
<li>兄弟结点的左孩子为黑或者不存在，右孩子为红  <blockquote>
<p>兄弟结点设为红色 兄弟结点的右孩子设为黑色 对兄弟结点进行左旋 当前处理结点不变 递归</p>
</blockquote>
</li>
<li>兄弟结点的孩子都是黑色 <blockquote>
<p>兄弟结点设为红色 父节点设为当前结点 递归</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 红黑树</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BRTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BRTREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    RED,</span><br><span class="line">    BLACK</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BRTREE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BRTREE</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BRTREE</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BRTREE</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span> <span class="title">color</span>;</span></span><br><span class="line">&#125; * BRTree, BRTree_Node;</span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">init</span><span class="params">(BRTree tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">create_node</span><span class="params">(<span class="keyword">int</span> key, BRTree parent, BRTree left, BRTree right, <span class="keyword">enum</span> COLOR color)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BRTree tree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BRTree tree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(BRTree tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">search</span><span class="params">(BRTree tree, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将树层序遍历打印出来</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_brtree</span><span class="params">(BRTree tree, <span class="keyword">int</span> dir, <span class="keyword">int</span> last_key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">insert</span><span class="params">(BRTree tree, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">fix_up</span><span class="params">(BRTree tree, BRTree tree_cur)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="function">BRTree <span class="title">l_rotation</span><span class="params">(BRTree tree, BRTree cur)</span></span>;</span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function">BRTree <span class="title">r_rotation</span><span class="params">(BRTree tree, BRTree cur)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">delete_brtree</span><span class="params">(BRTree tree, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">fix_up_del</span><span class="params">(BRTree tree, BRTree cur_tree)</span></span>;</span><br><span class="line"><span class="function">BRTree <span class="title">delete_node</span><span class="params">(BRTree tree, BRTree del_tree)</span></span>;</span><br><span class="line"><span class="function">BRTree <span class="title">successor</span><span class="params">(BRTree tree)</span></span>;</span><br><span class="line"><span class="function">BRTree <span class="title">maximum</span><span class="params">(BRTree tree)</span></span>;</span><br><span class="line"><span class="function">BRTree <span class="title">minimum</span><span class="params">(BRTree tree)</span></span>;</span><br><span class="line"><span class="comment">//从 leaf 到 root 的路径上的black结点数量。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">black_num</span><span class="params">(BRTree root, BRTree leaf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_balck_num</span><span class="params">(BRTree root, BRTree leaf, std::vector&lt;<span class="keyword">int</span>&gt; &amp;balck)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_balck_num_valid</span><span class="params">(BRTree tree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(BRTree tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BRTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">init</span><span class="params">(BRTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">create_node</span><span class="params">(<span class="keyword">int</span> key = <span class="number">-1</span>, BRTree parent = <span class="literal">NULL</span>, BRTree left = <span class="literal">NULL</span>, BRTree right = <span class="literal">NULL</span>, <span class="keyword">enum</span> COLOR color = RED)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BRTree tree = (BRTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct BRTREE));</span><br><span class="line">    tree-&gt;color = color;</span><br><span class="line">    tree-&gt;key = key;</span><br><span class="line">    tree-&gt;left = left;</span><br><span class="line">    tree-&gt;right = right;</span><br><span class="line">    tree-&gt;parent = parent;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BRTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tree-&gt;key);</span><br><span class="line">        <span class="built_in">preorder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BRTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inorder</span>(tree-&gt;left);</span><br><span class="line">        <span class="comment">//if (tree-&gt;left &amp;&amp; tree-&gt;right &amp;&amp; tree-&gt;left-&gt;color == RED &amp;&amp; tree-&gt;right-&gt;color == RED &amp;&amp; tree-&gt;color == RED)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, tree-&gt;key);</span><br><span class="line">        <span class="built_in">inorder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(BRTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">postorder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">postorder</span>(tree-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tree-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">search</span><span class="params">(BRTree tree, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == tree-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; tree-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(tree-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span> (key &gt; tree-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(tree-&gt;right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将树层序遍历打印出来</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_brtree</span><span class="params">(BRTree tree, <span class="keyword">int</span> dir, <span class="keyword">int</span> last_key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree &amp;&amp; dir == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;树空\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根节点</span></span><br><span class="line">        <span class="keyword">if</span> (dir == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d root&quot;</span>, tree-&gt;key);</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;color == RED)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; RED\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; BLACK\n&quot;</span>);</span><br><span class="line">            <span class="built_in">print_brtree</span>(tree-&gt;left, <span class="number">-1</span>, tree-&gt;key);</span><br><span class="line">            <span class="built_in">print_brtree</span>(tree-&gt;right, <span class="number">1</span>, tree-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (dir == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is %d &#x27;s left&quot;</span>, tree-&gt;key, last_key);</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;color == RED)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; RED\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; BLACK\n&quot;</span>);</span><br><span class="line">            <span class="built_in">print_brtree</span>(tree-&gt;left, <span class="number">-1</span>, tree-&gt;key);</span><br><span class="line">            <span class="built_in">print_brtree</span>(tree-&gt;right, <span class="number">1</span>, tree-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (dir == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is %d &#x27;s right&quot;</span>, tree-&gt;key, last_key);</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;color == RED)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; RED\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; BLACK\n&quot;</span>);</span><br><span class="line">            <span class="built_in">print_brtree</span>(tree-&gt;left, <span class="number">-1</span>, tree-&gt;key);</span><br><span class="line">            <span class="built_in">print_brtree</span>(tree-&gt;right, <span class="number">1</span>, tree-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">insert</span><span class="params">(BRTree tree, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//首先生成一个结点，染成红色并按照 BStree一样插入进去。</span></span><br><span class="line">    BRTree pos = tree;</span><br><span class="line">    BRTree tree_to_insert = <span class="built_in">create_node</span>(key);</span><br><span class="line">    <span class="comment">//查找插入位置</span></span><br><span class="line">    <span class="comment">//空树</span></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根节点的颜色为黑色</span></span><br><span class="line">        tree_to_insert-&gt;color = BLACK;</span><br><span class="line">        <span class="keyword">return</span> tree_to_insert;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非空树</span></span><br><span class="line">    pos = tree;</span><br><span class="line">    <span class="keyword">while</span> (pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == pos-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; pos-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pos-&gt;left = tree_to_insert;</span><br><span class="line">                tree_to_insert-&gt;parent = pos;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pos = pos-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span> (key &gt; pos-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pos-&gt;right = tree_to_insert;</span><br><span class="line">                tree_to_insert-&gt;parent = pos;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pos = pos-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入成功，进行调整到合格的红黑树。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fix_up</span>(tree, tree_to_insert);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">fix_up</span><span class="params">(BRTree tree, BRTree tree_cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调整树直到符合红黑树的要求。</span></span><br><span class="line">    <span class="keyword">if</span> (!tree || !tree_cur)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    <span class="comment">//cur为根节点将其颜色变为黑色直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tree_cur-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree_cur-&gt;color = BLACK;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父节点是根节点则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    <span class="comment">//1. 父节点是黑色 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;color == BLACK)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    <span class="comment">//2. 父节点是红色</span></span><br><span class="line">    <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;color == RED)</span><br><span class="line">    &#123;</span><br><span class="line">        BRTree grandpa = tree_cur-&gt;parent-&gt;parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//叔叔结点存在才可能是红色，否则为黑色</span></span><br><span class="line">        <span class="keyword">if</span> (grandpa-&gt;left &amp;&amp; grandpa-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1. 父节点和叔叔结点都是红色</span></span><br><span class="line">            <span class="keyword">if</span> (grandpa-&gt;left-&gt;color == RED &amp;&amp; grandpa-&gt;right-&gt;color == RED)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将父节点 叔叔 设为黑色 将祖父节点设为红色，递归继续处理祖父结点</span></span><br><span class="line">                grandpa-&gt;left-&gt;color = BLACK;</span><br><span class="line">                grandpa-&gt;right-&gt;color = BLACK;</span><br><span class="line">                grandpa-&gt;color = RED;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">fix_up</span>(tree, grandpa);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2. 父节点红 和叔叔结点黑</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (grandpa-&gt;left-&gt;color == BLACK || grandpa-&gt;right-&gt;color == BLACK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当前结点的父节点是祖父节点的左孩子</span></span><br><span class="line">                <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;parent-&gt;left == tree_cur-&gt;parent)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 当前结点是父节点的左孩子</span></span><br><span class="line">                    <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;left == tree_cur)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 父节点设为黑色 祖父节点设为红色 对祖父节点进行右旋</span></span><br><span class="line">                        tree_cur-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                        tree_cur-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                        tree = <span class="built_in">r_rotation</span>(tree, tree_cur-&gt;parent-&gt;parent);</span><br><span class="line">                        <span class="keyword">return</span> tree;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当前结点是父节点的右孩子</span></span><br><span class="line">                    <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;right == tree_cur)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 将父节点设为当前节点并进行左旋。递归进行。</span></span><br><span class="line">                        tree_cur = tree_cur-&gt;parent;</span><br><span class="line">                        tree = <span class="built_in">l_rotation</span>(tree, tree_cur);</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">fix_up</span>(tree, tree_cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前结点的父节点是祖父节点的右孩子</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;parent-&gt;right == tree_cur-&gt;parent)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 当前结点是父节点的左孩子</span></span><br><span class="line">                    <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;left == tree_cur)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 将父节点设为当前结点并进行右旋 递归</span></span><br><span class="line">                        tree_cur = tree_cur-&gt;parent;</span><br><span class="line">                        tree = <span class="built_in">r_rotation</span>(tree, tree_cur);</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">fix_up</span>(tree, tree_cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当前结点是父节点的右孩子</span></span><br><span class="line">                    <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;right == tree_cur)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 父节点设为黑色 祖父设为红色 并对祖父进行左旋</span></span><br><span class="line">                        tree_cur-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                        tree_cur-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                        tree = <span class="built_in">l_rotation</span>(tree, tree_cur-&gt;parent-&gt;parent);</span><br><span class="line">                        <span class="keyword">return</span> tree;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//叔叔结点不存在 为黑色</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前结点的父节点是祖父节点的左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;parent-&gt;left == tree_cur-&gt;parent)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当前结点是父节点的左孩子</span></span><br><span class="line">                <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;left == tree_cur)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 父节点设为黑色 祖父节点设为红色 对祖父节点进行右旋</span></span><br><span class="line">                    tree_cur-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                    tree_cur-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                    tree = <span class="built_in">r_rotation</span>(tree, tree_cur-&gt;parent-&gt;parent);</span><br><span class="line">                    <span class="keyword">return</span> tree;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前结点是父节点的右孩子</span></span><br><span class="line">                <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;right == tree_cur)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 将父节点设为当前节点并进行左旋。递归进行。</span></span><br><span class="line">                    tree_cur = tree_cur-&gt;parent;</span><br><span class="line">                    tree = <span class="built_in">l_rotation</span>(tree, tree_cur);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">fix_up</span>(tree, tree_cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前结点的父节点是祖父节点的右孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;parent-&gt;right == tree_cur-&gt;parent)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当前结点是父节点的左孩子</span></span><br><span class="line">                <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;left == tree_cur)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 将父节点设为当前结点并进行右旋 递归</span></span><br><span class="line">                    tree_cur = tree_cur-&gt;parent;</span><br><span class="line">                    tree = <span class="built_in">r_rotation</span>(tree, tree_cur);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">fix_up</span>(tree, tree_cur);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前结点是父节点的右孩子</span></span><br><span class="line">                <span class="keyword">if</span> (tree_cur-&gt;parent-&gt;right == tree_cur)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 父节点设为黑色 祖父设为红色 并对祖父进行左旋</span></span><br><span class="line">                    tree_cur-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                    tree_cur-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                    tree = <span class="built_in">l_rotation</span>(tree, tree_cur-&gt;parent-&gt;parent);</span><br><span class="line">                    <span class="keyword">return</span> tree;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="function">BRTree <span class="title">l_rotation</span><span class="params">(BRTree tree, BRTree cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree || !cur)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    <span class="comment">//设置傀儡头节点使根节点是其左孩子</span></span><br><span class="line">    BRTree preroot = <span class="built_in">create_node</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, tree);</span><br><span class="line">    tree-&gt;parent = preroot;</span><br><span class="line">    <span class="comment">//左旋 将当前结点旋转为其右孩子的左孩子，并将其右孩子的左孩子设置为当前节点的右孩子。</span></span><br><span class="line">    BRTree root = cur;</span><br><span class="line">    BRTree right = root-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (!right)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;parent-&gt;left == root)</span><br><span class="line">        root-&gt;parent-&gt;left = right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;parent-&gt;right == root)</span><br><span class="line">        root-&gt;parent-&gt;right = right;</span><br><span class="line">    right-&gt;parent = root-&gt;parent;</span><br><span class="line"></span><br><span class="line">    root-&gt;parent = right;</span><br><span class="line">    root-&gt;right = right-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (right-&gt;left)</span><br><span class="line">        right-&gt;left-&gt;parent = root;</span><br><span class="line">    right-&gt;left = root;</span><br><span class="line"></span><br><span class="line">    tree = preroot-&gt;left;</span><br><span class="line">    tree-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(preroot);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function">BRTree <span class="title">r_rotation</span><span class="params">(BRTree tree, BRTree cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree || !cur)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    <span class="comment">//设置傀儡头节点使根节点是其左孩子</span></span><br><span class="line">    BRTree preroot = <span class="built_in">create_node</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, tree);</span><br><span class="line">    tree-&gt;parent = preroot;</span><br><span class="line">    <span class="comment">//右旋 将当前结点旋转为其左孩子的右孩子，并将其左孩子的右孩子设置为当前节点的左孩子。</span></span><br><span class="line">    BRTree root = cur;</span><br><span class="line">    BRTree left = root-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (!left)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;parent-&gt;left == root)</span><br><span class="line">        root-&gt;parent-&gt;left = left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;parent-&gt;right == root)</span><br><span class="line">        root-&gt;parent-&gt;right = left;</span><br><span class="line">    left-&gt;parent = root-&gt;parent;</span><br><span class="line"></span><br><span class="line">    root-&gt;parent = left;</span><br><span class="line">    root-&gt;left = left-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (left-&gt;right)</span><br><span class="line">        left-&gt;right-&gt;parent = root;</span><br><span class="line">    left-&gt;right = root;</span><br><span class="line"></span><br><span class="line">    tree = preroot-&gt;left;</span><br><span class="line">    tree-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(preroot);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function">BRTree <span class="title">delete_brtree</span><span class="params">(BRTree tree, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BRTree del_tree = <span class="built_in">search</span>(tree, key);</span><br><span class="line">    <span class="keyword">if</span> (!del_tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败 没有找到 %d\n&quot;</span>, key);</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到真正要删除的结点</span></span><br><span class="line">    del_tree = <span class="built_in">delete_node</span>(tree, del_tree);</span><br><span class="line">    <span class="comment">//删除前修正 确保删除后树平衡</span></span><br><span class="line">    tree = <span class="built_in">fix_up_del</span>(tree, del_tree);</span><br><span class="line">    <span class="comment">//删除del_tree</span></span><br><span class="line">    <span class="keyword">if</span> (!del_tree-&gt;parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(del_tree);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (del_tree-&gt;parent-&gt;left == del_tree)</span><br><span class="line">        del_tree-&gt;parent-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (del_tree-&gt;parent-&gt;right == del_tree)</span><br><span class="line">        del_tree-&gt;parent-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(del_tree);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除修正 这里负责旋转，即确保删除后树平衡 但是不删除树</span></span><br><span class="line"><span class="function">BRTree <span class="title">fix_up_del</span><span class="params">(BRTree tree, BRTree cur_tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cur_tree-&gt;parent)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    BRTree pa = cur_tree-&gt;parent;</span><br><span class="line">    BRTree bro = pa-&gt;left == cur_tree ? pa-&gt;right : pa-&gt;left;</span><br><span class="line">    <span class="comment">//1. 结点为红色 设为黑色 直接删除</span></span><br><span class="line">    <span class="keyword">if</span> (cur_tree-&gt;color == RED)</span><br><span class="line">    &#123;</span><br><span class="line">        cur_tree-&gt;color = BLACK;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//兄弟结点为空</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!bro)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_tree-&gt;parent-&gt;color == RED)</span><br><span class="line">        &#123;</span><br><span class="line">            cur_tree-&gt;parent-&gt;color = BLACK;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fix_up_del</span>(tree, cur_tree-&gt;parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前结点为黑色</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur_tree-&gt;color == BLACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前结点是左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (pa-&gt;left == cur_tree)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//兄弟结点为红</span></span><br><span class="line">            <span class="keyword">if</span> (bro-&gt;color == RED)</span><br><span class="line">            &#123;</span><br><span class="line">                bro-&gt;color = BLACK;</span><br><span class="line">                pa-&gt;color = RED;</span><br><span class="line">                tree = <span class="built_in">l_rotation</span>(tree, pa);</span><br><span class="line">                <span class="comment">//return tree;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">fix_up_del</span>(tree, cur_tree);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//兄弟结点为黑</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bro-&gt;color == BLACK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//兄弟结点的右子结点是红结点，左子结点任意颜色</span></span><br><span class="line">                <span class="keyword">if</span> (bro-&gt;right &amp;&amp; bro-&gt;right-&gt;color == RED)</span><br><span class="line">                &#123;</span><br><span class="line">                    bro-&gt;color = pa-&gt;color;</span><br><span class="line">                    pa-&gt;color = BLACK;</span><br><span class="line">                    bro-&gt;right-&gt;color = BLACK;</span><br><span class="line">                    tree = <span class="built_in">l_rotation</span>(tree, pa);</span><br><span class="line">                    <span class="keyword">return</span> tree;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//兄弟结点的右子结点为黑结点，左子结点为红结点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((bro-&gt;left &amp;&amp; bro-&gt;left-&gt;color == RED) &amp;&amp; (!bro-&gt;right || (bro-&gt;right &amp;&amp; bro-&gt;right-&gt;color == BLACK)))</span><br><span class="line">                &#123;</span><br><span class="line">                    bro-&gt;color = RED;</span><br><span class="line">                    bro-&gt;left-&gt;color = BLACK;</span><br><span class="line">                    tree = <span class="built_in">r_rotation</span>(tree, bro);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">fix_up_del</span>(tree, cur_tree);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bro-&gt;color = RED;</span><br><span class="line">                    cur_tree = pa;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">fix_up_del</span>(tree, cur_tree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前结点是右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (pa-&gt;right == cur_tree)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//兄弟结点为红</span></span><br><span class="line">            <span class="keyword">if</span> (bro-&gt;color == RED)</span><br><span class="line">            &#123;</span><br><span class="line">                bro-&gt;color = BLACK;</span><br><span class="line">                pa-&gt;color = RED;</span><br><span class="line">                tree = <span class="built_in">r_rotation</span>(tree, pa);</span><br><span class="line">                <span class="comment">//return tree;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">fix_up_del</span>(tree, cur_tree);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//兄弟结点为黑</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bro-&gt;color == BLACK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//兄弟结点的左子结点是红结点，右子结点任意颜色</span></span><br><span class="line">                <span class="keyword">if</span> (bro-&gt;left &amp;&amp; bro-&gt;left-&gt;color == RED)</span><br><span class="line">                &#123;</span><br><span class="line">                    bro-&gt;color = pa-&gt;color;</span><br><span class="line">                    pa-&gt;color = BLACK;</span><br><span class="line">                    bro-&gt;left-&gt;color = BLACK;</span><br><span class="line">                    tree = <span class="built_in">r_rotation</span>(tree, pa);</span><br><span class="line">                    <span class="keyword">return</span> tree;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//兄弟结点的左子结点为黑结点，右子结点为红结点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (bro-&gt;right &amp;&amp; bro-&gt;left &amp;&amp; bro-&gt;left-&gt;color == BLACK &amp;&amp; bro-&gt;right-&gt;color == RED)</span><br><span class="line">                &#123;</span><br><span class="line">                    bro-&gt;color = RED;</span><br><span class="line">                    bro-&gt;right-&gt;color = BLACK;</span><br><span class="line">                    tree = <span class="built_in">l_rotation</span>(tree, bro);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">fix_up_del</span>(tree, cur_tree);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bro-&gt;color = RED;</span><br><span class="line">                    cur_tree = pa;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">fix_up_del</span>(tree, cur_tree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点 返回最后删除的结点</span></span><br><span class="line"><span class="function">BRTree <span class="title">delete_node</span><span class="params">(BRTree tree, BRTree del_tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 叶节点 直接删除</span></span><br><span class="line">    <span class="keyword">if</span> (!del_tree-&gt;left &amp;&amp; !del_tree-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> del_tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若右左孩子 使用左子树中最大的</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (del_tree-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        BRTree su = <span class="built_in">maximum</span>(del_tree-&gt;left);</span><br><span class="line">        del_tree-&gt;key = su-&gt;key;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delete_node</span>(tree, su);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若有右子树 使用右子树中最小的</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (del_tree-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        BRTree su = <span class="built_in">minimum</span>(del_tree-&gt;right);</span><br><span class="line">        del_tree-&gt;key = su-&gt;key;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delete_node</span>(tree, su);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> del_tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BRTree <span class="title">successor</span><span class="params">(BRTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//若有右孩子，则取右孩子的最小值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">minimum</span>(tree-&gt;right);</span><br><span class="line">    <span class="comment">//没有右孩子向上遍历直到为父节点的左孩子，返回父节点 若父节点为空则返回空</span></span><br><span class="line">    <span class="keyword">while</span> (tree &amp;&amp; tree-&gt;parent-&gt;right == tree)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = tree-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!tree)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> tree-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BRTree <span class="title">maximum</span><span class="params">(BRTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    <span class="keyword">while</span> (tree-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BRTree <span class="title">minimum</span><span class="params">(BRTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    <span class="keyword">while</span> (tree-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从 leaf 到 root 的路径上的black结点数量。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">black_num</span><span class="params">(BRTree root, BRTree leaf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!leaf || !root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = root-&gt;color == BLACK ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (leaf != root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leaf-&gt;color == BLACK)</span><br><span class="line">            count++;</span><br><span class="line">        leaf = leaf-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存一棵树到其所有叶子的黑色节点数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_balck_num</span><span class="params">(BRTree root, BRTree leaf, std::vector&lt;<span class="keyword">int</span>&gt; &amp;balck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leaf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">save_balck_num</span>(root, leaf-&gt;left, balck);</span><br><span class="line">        <span class="keyword">if</span> (!leaf-&gt;right &amp;&amp; !leaf-&gt;left)</span><br><span class="line">            balck.<span class="built_in">push_back</span>(<span class="built_in">black_num</span>(root, leaf));</span><br><span class="line">        <span class="built_in">save_balck_num</span>(root, leaf-&gt;right, balck);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_balck_num_valid</span><span class="params">(BRTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree)</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">save_balck_num</span>(tree, tree, v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= v.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (v.<span class="built_in">at</span>(i) != v.<span class="built_in">at</span>(<span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check_balck_num_valid</span>(tree-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check_balck_num_valid</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(BRTree tree)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BRTree.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 10000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RANGE 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v; <span class="comment">//= &#123;91, 23, 74, 26, 15, 94, 13, 21, 10, 52, 60, 92, 73, 8, 47, 69, 80, 97, 48, 55&#125;;</span></span><br><span class="line">    BRTree tree;</span><br><span class="line">    tree = <span class="built_in">init</span>(tree);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAX_NUM - <span class="number">1</span>; i += <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="built_in">rand</span>() % RANGE;</span><br><span class="line">        <span class="comment">//int key = v.at(i);</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">search</span>(tree, key))</span><br><span class="line">        &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(key);</span><br><span class="line">            tree = <span class="built_in">insert</span>(tree, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">//print_brtree(tree, 0, -1);</span></span><br><span class="line">    <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">//inorder(tree);</span></span><br><span class="line">    <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= v.<span class="built_in">size</span>() - <span class="number">1</span>; i += <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;删除 %d \n&quot;, v.at(i));</span></span><br><span class="line">        tree = <span class="built_in">delete_brtree</span>(tree, v.<span class="built_in">at</span>(i));</span><br><span class="line">        <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">//print_brtree(tree, 0, -1);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_balck_num_valid</span>(tree))</span><br><span class="line">            ; <span class="comment">//printf(&quot;-------------------------------------合法--------------------------------\n&quot;);</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------不合法--------------------------------\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= v.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, v.<span class="built_in">at</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">//print_brtree(tree, 0, -1);</span></span><br><span class="line">    <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt;= v.size() - 1; i++)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//printf(&quot;%d, &quot;, v.at(i));</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;text pass&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构</category>
        <category>红黑树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 八 图</title>
    <url>/2021/08/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%85%AB-%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="数据结构-八-图"><a href="#数据结构-八-图" class="headerlink" title="数据结构 八 图"></a>数据结构 八 图</h1><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><h3 id="无向图的邻接矩阵实现"><a href="#无向图的邻接矩阵实现" class="headerlink" title="无向图的邻接矩阵实现"></a>无向图的邻接矩阵实现</h3><h4 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无向图 邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GRAPH_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GRAPH_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERTEX_MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VERTEX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">&#125; * Vertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GRAPH</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//顶点集合</span></span><br><span class="line">    <span class="comment">//顶点数量</span></span><br><span class="line">    <span class="comment">//边的数量</span></span><br><span class="line">    <span class="comment">//边的集合 使用邻接矩阵或者邻接表进行表示</span></span><br><span class="line">    Vertex vertex[VERTEX_MAX];</span><br><span class="line">    <span class="keyword">int</span> vertex_num;</span><br><span class="line">    <span class="keyword">int</span> edge_num;</span><br><span class="line">    <span class="keyword">int</span> matrix[VERTEX_MAX][VERTEX_MAX];</span><br><span class="line">&#125; * Graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图不可以是一个空图</span></span><br><span class="line"><span class="comment">//初始化一个图</span></span><br><span class="line"><span class="function">Graph <span class="title">init</span><span class="params">(<span class="keyword">int</span> vertex_num)</span></span>;</span><br><span class="line"><span class="comment">//自动随机填充图 vertex_num 个顶点</span></span><br><span class="line"><span class="function">Graph <span class="title">random_fill_graph</span><span class="params">(Graph graph, <span class="keyword">int</span> vertex_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的遍历</span></span><br><span class="line"><span class="comment">//深度优先搜索 DFS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph graph)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_Vertex</span><span class="params">(Graph graph, <span class="keyword">int</span> v_seq, <span class="keyword">int</span> is_sacn[VERTEX_MAX])</span></span>;</span><br><span class="line"><span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph graph)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;graph.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图不可以是一个空图</span></span><br><span class="line"><span class="comment">//初始化一个图</span></span><br><span class="line"><span class="function">Graph <span class="title">init</span><span class="params">(<span class="keyword">int</span> vertex_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph graph = (Graph)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct _GRAPH));</span><br><span class="line">    graph-&gt;edge_num = <span class="number">0</span>;</span><br><span class="line">    graph-&gt;vertex_num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(graph-&gt;matrix, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(graph-&gt;matrix));</span><br><span class="line">    graph = <span class="built_in">random_fill_graph</span>(graph, vertex_num);</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Graph <span class="title">random_fill_graph</span><span class="params">(Graph graph, <span class="keyword">int</span> vertex_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> totle_vertex_num = vertex_num + graph-&gt;vertex_num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vertex_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="built_in">rand</span>() % VERTEX_MAX;</span><br><span class="line">        Vertex v = (Vertex)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct _VERTEX));</span><br><span class="line">        <span class="keyword">if</span> (!v)</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        v-&gt;key = key;</span><br><span class="line">        graph-&gt;vertex[graph-&gt;vertex_num] = v;</span><br><span class="line">        <span class="keyword">int</span> source = graph-&gt;vertex_num++;</span><br><span class="line">        <span class="keyword">int</span> degree = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (totle_vertex_num &gt; <span class="number">1</span>)</span><br><span class="line">            degree = <span class="built_in">rand</span>() % (totle_vertex_num - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= degree; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> destination = <span class="built_in">rand</span>() % (totle_vertex_num - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (destination != source)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph-&gt;matrix[source][destination] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    graph-&gt;matrix[source][destination] = <span class="number">1</span>;</span><br><span class="line">                    graph-&gt;matrix[destination][source] = <span class="number">1</span>;</span><br><span class="line">                    graph-&gt;edge_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图的遍历</span></span><br><span class="line"><span class="comment">//深度优先搜索 DFS 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DFS\n&quot;</span>);</span><br><span class="line">    <span class="comment">//任意找一个顶点开始进行递归深度搜索。</span></span><br><span class="line">    <span class="keyword">int</span> is_sacn[VERTEX_MAX];</span><br><span class="line">    <span class="built_in">memset</span>(is_sacn, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(is_sacn));</span><br><span class="line">    <span class="built_in">DFS_Vertex</span>(graph, <span class="number">0</span>, is_sacn);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_Vertex</span><span class="params">(Graph graph, <span class="keyword">int</span> v_seq, <span class="keyword">int</span> is_sacn[VERTEX_MAX])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果没有被扫描过则输出</span></span><br><span class="line">    <span class="comment">//扫描其所有相连的 访问一个没有被访问过的 若所有与之相连接的结点都被访问过 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!is_sacn[v_seq])</span><br><span class="line">    &#123;</span><br><span class="line">        is_sacn[v_seq] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, graph-&gt;vertex[v_seq]-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= graph-&gt;vertex_num - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph-&gt;matrix[v_seq][i] == <span class="number">1</span> &amp;&amp; !is_sacn[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS_Vertex</span>(graph, i, is_sacn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_none_recursive</span><span class="params">(Graph graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DFS_none_recursive\n&quot;</span>);</span><br><span class="line">    <span class="comment">//将遇到的每一个未访问过的结点放入栈中 依次弹出访问 直到栈空</span></span><br><span class="line">    <span class="keyword">int</span> is_scan[VERTEX_MAX];</span><br><span class="line">    <span class="built_in">memset</span>(is_scan, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(is_scan));</span><br><span class="line">    std::stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> seq = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//访问这个结点 可能有多个结点与该节点相连则该节点就入栈多次 但是访问一次即可</span></span><br><span class="line">        <span class="keyword">if</span> (!is_scan[seq])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, graph-&gt;vertex[seq]-&gt;key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        is_scan[seq] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将这个结点所连接的节点中未访问过的结点push</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= graph-&gt;vertex_num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph-&gt;matrix[seq][i] == <span class="number">1</span> &amp;&amp; !is_scan[i])</span><br><span class="line">                s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BFS\n&quot;</span>);</span><br><span class="line">    <span class="comment">//层次搜索 和树一样</span></span><br><span class="line">    std::deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> is_scan[VERTEX_MAX];</span><br><span class="line">    <span class="built_in">memset</span>(is_scan, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(is_scan));</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> seq = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (!is_scan[seq])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, graph-&gt;vertex[seq]-&gt;key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        is_scan[seq] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将下一层入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= graph-&gt;vertex_num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph-&gt;matrix[seq][i] == <span class="number">1</span> &amp;&amp; !is_scan[i])</span><br><span class="line">                q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;graph.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph graph = <span class="built_in">init</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">DFS</span>(graph);</span><br><span class="line">    <span class="built_in">DFS_none_recursive</span>(graph);</span><br><span class="line">    <span class="built_in">BFS</span>(graph);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无向图的邻接表实现"><a href="#无向图的邻接表实现" class="headerlink" title="无向图的邻接表实现"></a>无向图的邻接表实现</h3><h4 id="接口声明-1"><a href="#接口声明-1" class="headerlink" title="接口声明"></a>接口声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无向图 邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GRAPH_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GRAPH_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERTEX_MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> seq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ENODE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; * Enode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VERTEX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;          <span class="comment">//顶点数据</span></span><br><span class="line">    Enode first_edge; <span class="comment">//该顶点的第一个弧</span></span><br><span class="line">&#125; * Vertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GRAPH</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//邻接表 图中存放顶点 每一个顶点有一个链表将自己相连的顶点存储到链表中</span></span><br><span class="line">    <span class="comment">//顶点数目</span></span><br><span class="line">    <span class="comment">//边的数目</span></span><br><span class="line">    <span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">int</span> vertex_num;</span><br><span class="line">    <span class="keyword">int</span> edge_num;</span><br><span class="line">    Vertex vertex[VERTEX_MAX];</span><br><span class="line">&#125; * Graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图不可以是一个空图</span></span><br><span class="line"><span class="comment">//初始化一个图</span></span><br><span class="line"><span class="function">Graph <span class="title">init</span><span class="params">(<span class="keyword">int</span> vertex_num)</span></span>;</span><br><span class="line"><span class="comment">//自动随机填充图 vertex_num 个顶点</span></span><br><span class="line"><span class="function">Graph <span class="title">random_fill_graph</span><span class="params">(Graph graph, <span class="keyword">int</span> vertex_num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append_table</span><span class="params">(Graph graph, <span class="keyword">int</span> source, <span class="keyword">int</span> insert)</span></span>;</span><br><span class="line"><span class="comment">//图的遍历</span></span><br><span class="line"><span class="comment">//深度优先搜索 DFS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph graph)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_Vertex</span><span class="params">(Graph graph, <span class="keyword">int</span> v_seq, <span class="keyword">int</span> is_scan[VERTEX_MAX])</span></span>;</span><br><span class="line"><span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph graph)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_Vertex</span><span class="params">(Graph graph, <span class="keyword">int</span> v_seq, <span class="keyword">int</span> is_scan[VERTEX_MAX])</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="接口定义-1"><a href="#接口定义-1" class="headerlink" title="接口定义"></a>接口定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;graph.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图不可以是一个空图</span></span><br><span class="line"><span class="comment">//初始化一个图</span></span><br><span class="line"><span class="function">Graph <span class="title">init</span><span class="params">(<span class="keyword">int</span> vertex_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph graph = (Graph)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct _GRAPH));</span><br><span class="line">    graph-&gt;edge_num = <span class="number">0</span>;</span><br><span class="line">    graph-&gt;vertex_num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(graph-&gt;vertex, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(graph-&gt;vertex));</span><br><span class="line">    graph = <span class="built_in">random_fill_graph</span>(graph, vertex_num);</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Graph <span class="title">random_fill_graph</span><span class="params">(Graph graph, <span class="keyword">int</span> vertex_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">//int totle_vertex_num = vertex_num + graph-&gt;vertex_num;</span></span><br><span class="line">    <span class="comment">//随机产生一个顶点 随机产生一个度 随机产生每一个度连接的顶点 更新顶点的邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vertex_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> source = graph-&gt;vertex_num++;</span><br><span class="line">        graph-&gt;vertex[source] = (Vertex)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct _VERTEX));</span><br><span class="line">        graph-&gt;vertex[source]-&gt;first_edge = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> destination = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="built_in">rand</span>() % VERTEX_MAX;</span><br><span class="line">        graph-&gt;vertex[source]-&gt;key = key;</span><br><span class="line">        <span class="keyword">int</span> degree = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (source != <span class="number">0</span>)</span><br><span class="line">            degree = <span class="built_in">rand</span>() % (source) + <span class="number">1</span>; <span class="comment">//1 - source-1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= degree; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            destination = <span class="built_in">rand</span>() % (source);</span><br><span class="line">            <span class="comment">//更新source的邻接表</span></span><br><span class="line">            <span class="built_in">append_table</span>(graph, source, destination);</span><br><span class="line">            <span class="comment">//更新destination的邻接表</span></span><br><span class="line">            <span class="built_in">append_table</span>(graph, destination, source);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append_table</span><span class="params">(Graph graph, <span class="keyword">int</span> source, <span class="keyword">int</span> insert)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将 source 的邻接表插入一位 insert</span></span><br><span class="line">    Enode p = graph-&gt;vertex[source]-&gt;first_edge;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        Enode e = (Enode)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct _ENODE));</span><br><span class="line">        e-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        e-&gt;seq = insert;</span><br><span class="line">        graph-&gt;vertex[source]-&gt;first_edge = e;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p不空，append</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;seq == insert)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="comment">//邻接表中已经存在 insert 了，不需要存入</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;seq == insert)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Enode e = (Enode)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct _ENODE));</span><br><span class="line">    e-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    e-&gt;seq = insert;</span><br><span class="line">    p-&gt;next = e;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图的遍历</span></span><br><span class="line"><span class="comment">//深度优先搜索 DFS 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DFS\n&quot;</span>);</span><br><span class="line">    <span class="comment">//从0开始遍历邻接表</span></span><br><span class="line">    <span class="keyword">int</span> is_scan[VERTEX_MAX];</span><br><span class="line">    <span class="built_in">memset</span>(is_scan, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(is_scan));</span><br><span class="line">    <span class="built_in">DFS_Vertex</span>(graph, <span class="number">0</span>, is_scan);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_Vertex</span><span class="params">(Graph graph, <span class="keyword">int</span> v_seq, <span class="keyword">int</span> is_scan[VERTEX_MAX])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果没有被扫描过则输出</span></span><br><span class="line">    <span class="comment">//扫描其所有相连的 访问一个没有被访问过的 若所有与之相连接的结点都被访问过 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!is_scan[v_seq])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, graph-&gt;vertex[v_seq]-&gt;key);</span><br><span class="line">    is_scan[v_seq] = <span class="number">1</span>;</span><br><span class="line">    Enode p = graph-&gt;vertex[v_seq]-&gt;first_edge;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历邻接表</span></span><br><span class="line">        <span class="keyword">if</span> (!is_scan[p-&gt;seq])</span><br><span class="line">            <span class="built_in">DFS_Vertex</span>(graph, p-&gt;seq, is_scan);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_none_recursive</span><span class="params">(Graph graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DFS_none_recursive\n&quot;</span>);</span><br><span class="line">    <span class="comment">//将遇到的每一个未访问过的结点放入栈中 依次弹出访问 直到栈空</span></span><br><span class="line">    <span class="keyword">int</span> is_scan[VERTEX_MAX];</span><br><span class="line">    <span class="built_in">memset</span>(is_scan, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(is_scan));</span><br><span class="line">    std::stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> seq = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!is_scan[seq])</span><br><span class="line">        &#123;</span><br><span class="line">            is_scan[seq] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, graph-&gt;vertex[seq]-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将临界表内元素全部push</span></span><br><span class="line">        Enode p = graph-&gt;vertex[seq]-&gt;first_edge;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!is_scan[p-&gt;seq])</span><br><span class="line">                s.<span class="built_in">push</span>(p-&gt;seq);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先搜索 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BFS\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> is_scan[VERTEX_MAX];</span><br><span class="line">    <span class="built_in">memset</span>(is_scan, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(is_scan));</span><br><span class="line">    std::deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> seq = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (!is_scan[seq])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, graph-&gt;vertex[seq]-&gt;key);</span><br><span class="line">        is_scan[seq] = <span class="number">1</span>;</span><br><span class="line">        Enode p = graph-&gt;vertex[seq]-&gt;first_edge;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!is_scan[p-&gt;seq])</span><br><span class="line">                q.<span class="built_in">push_back</span>(p-&gt;seq);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口使用-1"><a href="#接口使用-1" class="headerlink" title="接口使用"></a>接口使用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;graph.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph graph = <span class="built_in">init</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">DFS</span>(graph);</span><br><span class="line">    <span class="built_in">DFS_none_recursive</span>(graph);</span><br><span class="line">    <span class="built_in">BFS</span>(graph);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图的相关算法"><a href="#图的相关算法" class="headerlink" title="图的相关算法"></a>图的相关算法</h2><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><strong>AOV网</strong></p>
<blockquote>
<p>若使用DAG图（有向无环图）表示一个工程（施工的先后顺序，项目依赖），顶点表示活动，使用有向边&lt;a,b&gt;表示活动a先于活动b。这种网称为AOV网，其中a是b的后继，b是a的前驱。</p>
</blockquote>
<p><strong>拓扑排序</strong></p>
<blockquote>
<p>在图论中，由一个DAG图的顶点组成的序列，当满足如下条件的时候，称为该图的一个拓扑排序。</p>
<ol>
<li>每一个顶点只出现一次。</li>
<li>若在序列中A在B的前面，则图中不存在从B到A的路径。</li>
</ol>
</blockquote>
<p><strong>拓扑排序的步骤</strong></p>
<blockquote>
<p>1.在AOV网中选择一个没有前驱的结点，输出并删掉相关的边。<br>2.重复直到网空或者不存在没有前驱的结点。</p>
</blockquote>
<p><strong>逆拓扑排序</strong></p>
<p>顾名思义即将拓扑排序逆着来。</p>
<p>选择一个只有前驱没有后继的结点，输出并删除其入度的边，重复直到完成。</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><blockquote>
<ul>
<li>一个连通图的生成树包含图中的所有顶点，并且只包含尽可能少的边。对于生成树来说，若砍去一条边则生成树不连通，若加上一条边则会形成回路。</li>
<li>对于一个带权的图来讲，最小生成树即为所有生成树中路径权值的和最小的那一颗。</li>
</ul>
</blockquote>
<blockquote>
<ol>
<li>最小生成树不唯一</li>
<li>最小生成树的权值和唯一</li>
</ol>
</blockquote>
<h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h4><p>树中顶点集合TD，图中顶点集合GD，图中边的集合GE，树中边的集合TE。</p>
<p>初始树的集合为空，从图中任取一个顶点加入树的顶点集。从该顶点集所连的所有边中选择满足以下条件的边。</p>
<blockquote>
<ol>
<li>该边未被加入树中</li>
<li>将该边加入树不会造成回路。</li>
<li>该边的权值为所有可选边中最小的</li>
</ol>
</blockquote>
<p>将该边及其对应的顶点加入树中，重复直至所有顶点都已经加入到了树中。</p>
<h4 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h4><p>树中顶点集合TD，图中顶点集合GD，图中边的集合GE，树中边的集合TE。</p>
<p>prim算法是选择顶点，kruskal算法是选择边。</p>
<p>依次将权值最小的边及其两端顶点加入树中。该边也要满足以下条件</p>
<blockquote>
<ol>
<li>该边未被加入树中</li>
<li>将该边加入树不会造成回路。</li>
<li>该边的权值为所有可选边中最小的</li>
</ol>
</blockquote>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>最短路径是两个点之间所经权值最下的一条路径。当图中所有路径的权值一样的时候可以使用广度优先搜索。当带权图的权值不一样的时候使用以下两种算法。</p>
<p>最短路径算法依赖于这条性质：</p>
<blockquote>
<p>两点之间的最短路径包含了路径上其他顶点的最短路径。</p>
</blockquote>
<h4 id="dijkstra-算法"><a href="#dijkstra-算法" class="headerlink" title="dijkstra 算法"></a>dijkstra 算法</h4><p>单源点最短路径</p>
<p><strong>迪杰斯特拉算法思想</strong></p>
<blockquote>
<p>每一个顶点都知道自己到源点的最短路径，不直接和源点相连的顶点距离设为无穷远，直接相连的设为弧的权值。每一次选择一个新的结点，该结点要满足是所有可选择的新结点中距源点最近的一条。求出其路径长度。现在相当于多了一个知道自己最短路径长度的顶点，其他顶点根据自己的信息改变自己的最短长度。</p>
</blockquote>
<p><strong>算法说明</strong></p>
<p>假设要求结点距离结点0的最短路径。源结点为结点0。顶点集合为v</p>
<ol>
<li>设置一个数组dist存储每一个结点到源结点的最短路径值。<ol>
<li>源节点到自身的路径长度设为0。</li>
<li>若不相连则设为正无穷。</li>
</ol>
</li>
<li>设置一个path数组存储每一个结点到源节点的最短路径上的前驱。</li>
<li>设置一个集合s存储当前已经确定的最短路径的结点，初始元素为源节点本身。v=v-s，为方便计算路径，初始v不用减去源点。</li>
<li>从集合v中选取一个结点j加入s（第一次选取的结点肯定为源点本身），要求满足：<ol>
<li>dist[j]=min{dist[i]},其中i为v中所有顶点。</li>
</ol>
</li>
<li>v=v-s</li>
<li>对于v中的顶点以j为依据更新最短路径长度。<ol>
<li>dist[i] = dist[i] &lt; dist[j] + arcs[i][j]?dist[i]:dist[j] + arcs[i][j];</li>
<li>即能不能根据j寻一条更短的道儿。</li>
<li>将path[i]=j, 即顶点i的最短路径的前驱经过j.</li>
</ol>
</li>
<li>重复直到v空。</li>
</ol>
<h4 id="floyd-算法"><a href="#floyd-算法" class="headerlink" title="floyd 算法"></a>floyd 算法</h4><p>顶点对最短路径</p>
<p><strong>弗洛伊德算法思想</strong></p>
<blockquote>
<p>弗洛伊德算法要求出每对顶点的最短距离，依次选取每一个顶点作为中转结点，以此来更新dist[][]</p>
</blockquote>
<p><strong>算法说明</strong></p>
<ol>
<li>设置一个方阵存储每一对顶点的最短距离dist[][]，初始化为：<ol>
<li>若两个顶点之间有弧则为弧长</li>
<li>没有弧为正无穷。</li>
<li>自己到自己的距离为0.</li>
</ol>
</li>
<li>依次选取每一个顶点k作为中转结点<ol>
<li>遍历所有顶点对更新最短距离。设当前顶点对为 &lt;i,j&gt;<ol>
<li>dist[i][j]=  dist[i][j] &lt; dist[i][k] + dist[k][j] ?  dist[i][j] : dist[i][k] + dist[k][j];</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p><strong>AOE网</strong></p>
<p>在带权有向图中，以顶点代表事件，以有向边代表活动，以边上的权值代表活动的开销。称之为右边表示活动的网络，简称AOE网。</p>
<blockquote>
<ol>
<li>只有在入度弧代表的活动全部完成之后才可以顶点代表的时间。</li>
<li>只有顶点代表的事件发生之后才可以开始出度弧代表的活动。</li>
</ol>
</blockquote>
<p><strong>事件的最早发生时间ve(k)</strong><br>从源点到顶点k的最长路径长度。</p>
<p>ve(源点)=0          </p>
<p>ve(k)=max(ve(i)+weight(i,k)); i为k的前驱            </p>
<p><strong>事件的最迟发生时间vl(k)</strong></p>
<p>vl(汇点)=ve(汇点)</p>
<p>vl(k)=min(vl(j) - weight(k,j)); k为j的前驱</p>
<p><strong>活动ai最早发生时间e(i)</strong></p>
<p>e(i)=ve(k) (边&lt;k,j&gt;代表活动ai)</p>
<p><strong>活动ai最迟发生时间l(i)</strong></p>
<p>l(i)=vl(j)-weight(k,j) (边&lt;k,j&gt;代表活动ai)</p>
<p><strong>活动ai可拖延时间d(i)</strong><br>d(i)=l(i)=d(i)</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 九 堆</title>
    <url>/2021/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B9%9D-%E5%A0%86/</url>
    <content><![CDATA[<h1 id="数据结构-九-堆"><a href="#数据结构-九-堆" class="headerlink" title="数据结构 九 堆"></a>数据结构 九 堆</h1><h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><p>heap,可以看作一棵树，只不过在性质方面和树不一样。</p>
<h2 id="堆的性质"><a href="#堆的性质" class="headerlink" title="堆的性质"></a>堆的性质</h2><ol>
<li>堆是一颗完全树。</li>
<li>堆的父结点值总是大于等于（最大堆）或者总是小于等于（最小堆）其孩子结点的值。</li>
</ol>
<h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p><strong>以最大堆为例</strong></p>
<ul>
<li>二叉堆满足堆的定义，二叉堆是一个完全二叉树。</li>
<li>当将一个数组看成一个堆的时候，若从零开始，则 2n+1 2n+2 为 n 的孩子。</li>
</ul>
<h3 id="二叉堆的算法"><a href="#二叉堆的算法" class="headerlink" title="二叉堆的算法"></a>二叉堆的算法</h3><h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><p>堆的调整算法即将堆中一个子树进行调整，令其满足堆的定义。这种调整的方法如下。</p>
<blockquote>
<ol>
<li>若根的值小于孩子的值，则令其与较大的孩子进行交换</li>
<li>令交换后的结点作为新根重复1直到没有孩子或者比孩子的值要大。</li>
</ol>
</blockquote>
<p>新建一个堆，将一个无序的数组调整为一个堆，算法如下：</p>
<blockquote>
<ol>
<li>从最后一个非叶子结点向前遍历直到根节点</li>
<li>对每一个结点进行上述的调整算法。</li>
</ol>
</blockquote>
<p>若对一个已经成序的堆进行调整只需要调整一个改变的结点即可，因为此时只有要处理的结点无序，其余结点都有序。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><blockquote>
<ol>
<li>将插入到数据插入的二叉堆的最后面</li>
<li>将该结点的值和其父结点进行比较，若大于其父结点的值则与父结点交换，递归直到无法上浮。</li>
</ol>
</blockquote>
<p>堆的一个重要应用就是堆排序，即将一个数组看成一个堆，进行排序。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote>
<ol>
<li>使用数组最后一个结点覆盖要删除的结点完成删除</li>
<li>对该结点进行调整。</li>
</ol>
</blockquote>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>使用堆排序，即将数组调整为最大堆之后将堆顶与堆尾元素互换，即将最大的元素放在数组尾部。调整堆。重复直到完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = end - begin;</span><br><span class="line">    <span class="comment">//首先建立大根堆，即对 n/2 - 1 为根的子树进行调整。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">heap_adjust</span>(begin, end, i, num);</span><br><span class="line">    <span class="comment">//循环输出最大值，并调整堆。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = begin[<span class="number">0</span>];</span><br><span class="line">        begin[<span class="number">0</span>] = begin[num - i - <span class="number">1</span>];</span><br><span class="line">        begin[num - i - <span class="number">1</span>] = temp;</span><br><span class="line">        <span class="built_in">heap_adjust</span>(begin, end, <span class="number">0</span>, num - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调整heap的一个子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_adjust</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end, <span class="keyword">int</span> seq, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将树根与其最大的孩子进行交换，递归直到叶子。</span></span><br><span class="line">    <span class="keyword">int</span> temp = begin[seq];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = seq * <span class="number">2</span> + <span class="number">1</span>; i &lt; len; i = i * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//指向大的孩子</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; begin[i] &lt; begin[i + <span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; begin[i])</span><br><span class="line">        &#123;</span><br><span class="line">            begin[seq] = begin[i];</span><br><span class="line">            seq = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt;= begin[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    begin[seq] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 六 B-tree &amp;&amp; B+tree</title>
    <url>/2021/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%85%AD-B-tree&amp;&amp;B+tree/</url>
    <content><![CDATA[<h1 id="Btree"><a href="#Btree" class="headerlink" title="Btree"></a>Btree</h1><p>终于学完了AVL树，现在开始学习BTree，为数据库做准备。</p>
<p>参考资料 <a href="https://segmentfault.com/a/1190000020416577">https://segmentfault.com/a/1190000020416577</a></p>
<h2 id="BTree的定义"><a href="#BTree的定义" class="headerlink" title="BTree的定义"></a>BTree的定义</h2><p>阶数M，每个结点所能够包含的关键数的数目有一个上下界，用M来限定。M&gt;=2 也成为Btree的最小度数</p>
<p><strong>min:</strong> 每一个非根节点至少由M-1个关键字，每一个非根内节点至少有M个子女，如果树非空，则根节点至少包含一个关键字。</p>
<p><strong>max:</strong> 每个结点最多包含2M-1个关键字，所以一个内节点最多有2M个子女，如果一个结点恰好有2M-1个关键字则称其为满的。</p>
<p>M=2的Btree是最简单的，这时一个内结点可以包含2-3-4个子女，称为一颗2-3-4树，但是在实际使用中常常使用大得多的M值。</p>
<p>BTree要求每一个内节点至少是半满。</p>
<p><strong>在数据结构课本中以及考研中对Btree的定义和算法导论中的定义有些许不同，如下：</strong></p>
<blockquote>
<p>阶数M为非根结点孩子的最大值而不是算法导论中的非根节点孩子的最小值。<br>我不喜欢课本和考研，所以我推崇算法导论的定义。以下实现都是基于算法导论的定义。</p>
<ol>
<li>树中每一个结点至多含有m颗子树，至少含有m/2向上取整个子树</li>
</ol>
</blockquote>
<h2 id="BTree的性质"><a href="#BTree的性质" class="headerlink" title="BTree的性质"></a>BTree的性质</h2><ol>
<li>根节点的key数量可以为1到2*M</li>
<li>非根节点的key的数量在M到2*M</li>
<li>每一个节点的孩子数量必须为其key数量加一，保证每一个key左右各一个孩子。</li>
<li>BTree是自平衡的，无论在什么情况下都是平衡的，子树的高度永远一致。</li>
<li></li>
</ol>
<h2 id="BTree-中的算法"><a href="#BTree-中的算法" class="headerlink" title="BTree 中的算法"></a>BTree 中的算法</h2><h3 id="查询算法"><a href="#查询算法" class="headerlink" title="查询算法"></a>查询算法</h3><p>从根节点进行递归查询直到找到或者确认不存在，遍历置每一个结点时，查询是否为比该结点的最小还要小或者比最大还要大，然后查询节点内是否存在该关键字，否则便利该节点的key,找到两个key使得要查找的关键字介于两者之间。</p>
<h3 id="后继和前驱"><a href="#后继和前驱" class="headerlink" title="后继和前驱"></a>后继和前驱</h3><p>这里只说后继。所谓后继就是中序遍历中后面的那一个key</p>
<ol>
<li>首先由传入的key寻找到对应的结点以及index.</li>
<li>若这个结点是叶子结点且不是叶子中最后一个，则其后面的key为其后继。</li>
<li>若这个结点是叶子结点且为叶子中的最后一个，则递归向上遍历，直到找到一个结点的父节点不是其节点中的最后一个孩子为止，则返回其父节点中对应节点的后面一个孩子。若寻找不到的话返回空。</li>
<li>若为非叶子结点，则其肯定有后继，即为其以右面的那个孩子为根的最小key.关于寻找最大最小key就不赘述了。</li>
</ol>
<h3 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h3><p>插入算法是难点所在，这里我的实现并不优雅，由于现在没有时间重制就将就看吧。</p>
<ol>
<li>首先由BTree的性质可知，每一次的插入都应该插入到叶子结点。</li>
<li>在预插入之后，判断插入之后的结点的key数量合不合格，若合格则返回。</li>
<li>数量超标则将结点分裂。</li>
<li>分裂方法：<ol>
<li>将中间的key上浮到父节点，将剩余的key分裂问两个key个数为M的child插入到父节点的对应位置。</li>
<li>若父节点空，则声明一个父节点并且这个父节点是新的树根。这就是为什么根节点的key数量可以为1了。</li>
</ol>
</li>
<li>递归向上浮动，直到某一个结点可以吃得下，不用分裂，返回。</li>
</ol>
<h3 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h3><p>写插入算法的时候觉得难，是因为当时没有搞懂BTree的性质，现在将BTree完全实现了一遍就很是明白BTree的性质了。</p>
<p>删除结点要比插入结点复杂，但是弄懂之后也不觉得什么了。</p>
<ol>
<li>查询目标结点和key的index</li>
<li>若要删除的结点为叶子，且删除之后数量大于等于M（若此时根节点也是叶子结点且删除根节点则无此顾虑），则直接删除。</li>
<li>若删除的结点为叶子节点（非根节点）但是删除之后数量小于M，则：<ol>
<li>先删除该key</li>
<li>判断其兄弟结点（由性质可知兄弟结点都是叶子）有没有key数量大于M的，若有的话则借过来。循环着使用根节点跳跃进行。</li>
<li>若没有key数量大于M的，借不了，则与其相邻的一个兄弟和对应的父节点的一个key进行合并，由于只有根节点的key最小可以有一个，所以其与父节点结点合并之后最多只少一个key。</li>
<li>合并之后判断父节点是否合格（根节点或者key数量大于等于M），合格则返回</li>
<li>不合格的话向父结点借key进行合并。规则如下<ol>
<li>确定要进行合并的两个孩子和父节点中的key。</li>
<li>若这三者的key加起来小于等于2*M则进行合并，否则的话说明另一个兄弟有多余的key可以借出来。</li>
<li>若有一个兄弟有多余的key，则进行轮换。具体看代码。</li>
</ol>
</li>
<li>递归进行5直到不需要借或者父节点是根节点且只有一个key</li>
<li>5递归执行完之后判断是否合格（key数量合格或者其为根节点）</li>
<li>不合格则说明此时根节点只有一个key，其中一个孩子需要key。这时将其合并即可。<ol>
<li>这里仍然分为总结点数小于等于2*M或者大于</li>
<li>若小于等于则合并为一个根</li>
<li>若大于则进行轮换。具体看代码。</li>
</ol>
</li>
</ol>
</li>
<li>若删除的是非叶子结点，则递归的使用后继进行替代，然后删除后继，直到叶子结点，在进行上面两步对叶子的操作。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="BTree-h"><a href="#BTree-h" class="headerlink" title="BTree.h"></a>BTree.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BSTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BSTREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ungigned long long int</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> M</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_KEY_NUM = <span class="number">2</span> * M;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_CHILD_NUM = <span class="number">2</span> * M + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTREE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key_num;                    <span class="comment">//键的数量</span></span><br><span class="line">    <span class="keyword">int</span> child_num;                  <span class="comment">//孩子数量 孩子数量永远等于key的数量加一</span></span><br><span class="line">    <span class="keyword">int</span> key[<span class="number">2</span> * M + <span class="number">1</span>];             <span class="comment">//键  冗余一位，child同理</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTREE</span> *<span class="title">child</span>[2 * <span class="title">M</span> + 2];</span> <span class="comment">//最多拥有 2M+1个孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTREE</span> *<span class="title">parent</span>;</span>           <span class="comment">//父节点</span></span><br><span class="line">    <span class="keyword">bool</span> isleaf;</span><br><span class="line">    <span class="comment">//BTree在实际运用中还需要存储值，但是这里就不用了。</span></span><br><span class="line">&#125; Node, *BTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空树</span></span><br><span class="line"><span class="function">BTree <span class="title">BTree_Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BTree tree)</span></span>;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BTree tree)</span></span>;</span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(BTree tree)</span></span>;</span><br><span class="line"><span class="comment">//打印Btree</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_btree</span><span class="params">(BTree tree, <span class="keyword">int</span> key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"><span class="comment">// (递归实现)查找&quot;b树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="function">BTree <span class="title">search</span><span class="params">(BTree tree, <span class="keyword">int</span> key, <span class="keyword">int</span> *index)</span></span>;</span><br><span class="line"><span class="comment">// (非递归实现)查找&quot;b树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="function">BTree <span class="title">search_iterative</span><span class="params">(BTree tree, <span class="keyword">int</span> key, <span class="keyword">int</span> *index)</span></span>;</span><br><span class="line"><span class="comment">// 查找最小结点</span></span><br><span class="line"><span class="function">BTree <span class="title">minimum</span><span class="params">(BTree tree, <span class="keyword">int</span> *index)</span></span>;</span><br><span class="line"><span class="comment">// 查找最大结点</span></span><br><span class="line"><span class="function">BTree <span class="title">maximum</span><span class="params">(BTree tree, <span class="keyword">int</span> *index)</span></span>;</span><br><span class="line"><span class="comment">// 将结点插入</span></span><br><span class="line"><span class="function">BTree <span class="title">insert</span><span class="params">(BTree tree, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"><span class="comment">//将一个值插入一个结点，返回更新过后的树</span></span><br><span class="line"><span class="function">BTree <span class="title">insert_into_node</span><span class="params">(BTree tree, BTree node_to_insert, <span class="keyword">int</span> key, <span class="keyword">bool</span> is_key_to_up, <span class="keyword">int</span> index, BTree tree_left, BTree tree_right)</span></span>;</span><br><span class="line"><span class="comment">// 删除结点</span></span><br><span class="line"><span class="function">BTree <span class="title">delete_btree</span><span class="params">(BTree tree, <span class="keyword">bool</span> useindex, BTree del_tree, <span class="keyword">int</span> del_key_index, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"><span class="comment">//后继</span></span><br><span class="line"><span class="function">BTree <span class="title">success_btree</span><span class="params">(BTree tree, <span class="keyword">bool</span> useindex, BTree tree_source, <span class="keyword">int</span> *index_source, <span class="keyword">int</span> key, <span class="keyword">int</span> *index_success)</span></span>;</span><br><span class="line"><span class="comment">//孩子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">childindex</span><span class="params">(BTree pa, BTree son)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">borrow_direction</span><span class="params">(BTree tree)</span></span>;</span><br><span class="line"><span class="comment">//交换左侧</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">l_exchange</span><span class="params">(BTree tree, <span class="keyword">int</span> index_key)</span></span>;</span><br><span class="line"><span class="comment">//交换左侧</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">r_exchange</span><span class="params">(BTree tree, <span class="keyword">int</span> index_key)</span></span>;</span><br><span class="line"><span class="function">BTree <span class="title">merge_onekey</span><span class="params">(BTree tree)</span></span>;</span><br><span class="line"><span class="function">BTree <span class="title">merge</span><span class="params">(BTree tree)</span></span>;</span><br><span class="line"><span class="function">BTree <span class="title">borrow_from_parent</span><span class="params">(BTree tree)</span></span>;</span><br><span class="line"><span class="function">BTree <span class="title">merge_root</span><span class="params">(BTree tree)</span></span>;</span><br><span class="line"><span class="comment">//协调两个孩子的节点数量 多的给少的一个，这其中当然也要通过parent-&gt;key进行交换</span></span><br><span class="line"><span class="function">BTree <span class="title">balance_two_child</span><span class="params">(BTree tree, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">BTree <span class="title">merge_parent</span><span class="params">(BTree tree, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 销毁b树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(BTree tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<h4 id="BTree-c"><a href="#BTree-c" class="headerlink" title="BTree.c"></a>BTree.c</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct BTREE</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int key_num;//键的数量</span></span><br><span class="line"><span class="comment">    int key[2*M+1];//键,有一个冗余的键用来预插入</span></span><br><span class="line"><span class="comment">    BTREE * child[2*M+1];//最多拥有 2M+1个孩子</span></span><br><span class="line"><span class="comment">    bool isleaf;</span></span><br><span class="line"><span class="comment">    //BTree在实际运用中还需要存储值，但是这里就不用了。</span></span><br><span class="line"><span class="comment">&#125;Node,*BTree;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空树</span></span><br><span class="line"><span class="function">BTree <span class="title">BTree_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;tree-&gt;key_num %d\n&quot;,tree-&gt;key_num);</span></span><br><span class="line">        <span class="comment">//打印结点内的第一个值，打印结点的第一个孩子结点，依次打印后面的值和结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tree-&gt;key_num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot; %d&quot;, tree-&gt;key[i]);</span></span><br><span class="line">            <span class="built_in">preorder</span>(tree-&gt;child[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">preorder</span>(tree-&gt;child[tree-&gt;key_num]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印结点内的第一个值，打印结点的第一个孩子结点，依次打印后面的值和结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tree-&gt;key_num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">inorder</span>(tree-&gt;child[i]);</span><br><span class="line">            <span class="comment">//printf(&quot; %d&quot;, tree-&gt;key[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorder</span>(tree-&gt;child[tree-&gt;key_num]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(BTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//后序遍历，</span></span><br><span class="line">        <span class="built_in">postorder</span>(tree-&gt;child[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tree-&gt;key_num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">postorder</span>(tree-&gt;child[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//printf(&quot; %d&quot;, tree-&gt;key[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_btree</span><span class="params">(BTree tree, <span class="keyword">int</span> key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (递归实现)查找&quot;b树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="function">BTree <span class="title">search</span><span class="params">(BTree tree, <span class="keyword">int</span> key, <span class="keyword">int</span> *index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> child_index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tree-&gt;key[<span class="number">0</span>] &gt; key)</span><br><span class="line">            child_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tree-&gt;key[tree-&gt;key_num - <span class="number">1</span>] &lt; key)</span><br><span class="line">            child_index = tree-&gt;key_num;</span><br><span class="line">        <span class="comment">//只有一个结点判断是否相等</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tree-&gt;key_num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;key[i] == key)</span><br><span class="line">            &#123;</span><br><span class="line">                *index = i;</span><br><span class="line">                <span class="keyword">return</span> tree;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两个或以上结点判断出口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tree-&gt;key_num - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = tree-&gt;key[i];</span><br><span class="line">            <span class="keyword">int</span> right = tree-&gt;key[i + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//printf(&quot;key: %d left: %d right: %d \n&quot;,key,left,right);</span></span><br><span class="line">            <span class="keyword">if</span> (left == key)</span><br><span class="line">            &#123;</span><br><span class="line">                *index = i;</span><br><span class="line">                <span class="keyword">return</span> tree;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right == key)</span><br><span class="line">            &#123;</span><br><span class="line">                *index = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> tree;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((left &lt; key) &amp;&amp; (key &lt; right))</span><br><span class="line">            &#123;</span><br><span class="line">                child_index = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(tree-&gt;child[child_index], key, index);</span><br><span class="line">    &#125;</span><br><span class="line">    *index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (非递归实现)查找&quot;b树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="function">BTree <span class="title">search_iterative</span><span class="params">(BTree tree, <span class="keyword">int</span> key, <span class="keyword">int</span> *index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> child_index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tree-&gt;key[<span class="number">0</span>] &gt; key)</span><br><span class="line">            child_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tree-&gt;key[tree-&gt;key_num - <span class="number">1</span>] &lt; key)</span><br><span class="line">            child_index = tree-&gt;key_num;</span><br><span class="line">        <span class="comment">//只有一个结点判断是否相等</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tree-&gt;key_num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;key[i] == key)</span><br><span class="line">            &#123;</span><br><span class="line">                *index = i;</span><br><span class="line">                <span class="keyword">return</span> tree;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tree-&gt;key_num - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = tree-&gt;key[i];</span><br><span class="line">            <span class="keyword">int</span> right = tree-&gt;key[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (left == key)</span><br><span class="line">            &#123;</span><br><span class="line">                *index = i;</span><br><span class="line">                <span class="keyword">return</span> tree;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right == key)</span><br><span class="line">            &#123;</span><br><span class="line">                *index = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> tree;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((left &lt; key) &amp;&amp; (key &lt; right))</span><br><span class="line">            &#123;</span><br><span class="line">                child_index = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tree = tree-&gt;child[child_index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没找到</span></span><br><span class="line">    *index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最小结点</span></span><br><span class="line"><span class="function">BTree <span class="title">minimum</span><span class="params">(BTree tree, <span class="keyword">int</span> *index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;isleaf == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minimum</span>(tree-&gt;child[<span class="number">0</span>], index);</span><br><span class="line">    &#125;</span><br><span class="line">    *index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找最大结点</span></span><br><span class="line"><span class="function">BTree <span class="title">maximum</span><span class="params">(BTree tree, <span class="keyword">int</span> *index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;isleaf == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maximum</span>(tree-&gt;child[tree-&gt;key_num], index);</span><br><span class="line">    &#125;</span><br><span class="line">    *index = tree-&gt;key_num;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结点插入</span></span><br><span class="line"><span class="function">BTree <span class="title">insert</span><span class="params">(BTree tree, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;insert %d \n&quot;, key);</span></span><br><span class="line">    <span class="comment">//首先找到应该插入的结点,若插入后超载了，则从中间将这个结点一分为二，将中间的结点插入到父节点上，父节点上的插入同理，直到插入成功。</span></span><br><span class="line">    <span class="comment">//空结点直接插入,</span></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = <span class="built_in">insert_into_node</span>(tree, <span class="literal">NULL</span>, key, <span class="literal">false</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//tree不空 则寻找合适的插入点 遍历结点找到合适的插入子节点，重复，直到到达叶子  普通插入只能首选叶子进行插入。</span></span><br><span class="line">    BTree node_to_insert = tree;</span><br><span class="line">    <span class="keyword">while</span> (node_to_insert-&gt;isleaf == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断插入到哪一个child</span></span><br><span class="line">        <span class="keyword">int</span> child_index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//小于最左边的，则插入到 child0</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; node_to_insert-&gt;key[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            child_index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//大于最右边的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node_to_insert-&gt;key[node_to_insert-&gt;key_num - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            child_index = node_to_insert-&gt;key_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从中间找合适的位置</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= node_to_insert-&gt;key_num - <span class="number">2</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> left = node_to_insert-&gt;key[i];</span><br><span class="line">                <span class="keyword">int</span> right = node_to_insert-&gt;key[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> ((left &lt; key) &amp;&amp; (key &lt; right))</span><br><span class="line">                &#123;</span><br><span class="line">                    child_index = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到合适的插入分支，进行插入</span></span><br><span class="line">        node_to_insert = node_to_insert-&gt;child[child_index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经过数个分支，已经到达叶子结点，进行结点级别的插入。node_to_insert</span></span><br><span class="line">    <span class="keyword">if</span> (node_to_insert-&gt;isleaf == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = <span class="built_in">insert_into_node</span>(tree, node_to_insert, key, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将一个值插入一个结点，返回更新过后的树,这里还有插入的是上浮结点的情况。index指的是上浮结点之前所在的结点是要插入到的结点的第几个child</span></span><br><span class="line"><span class="function">BTree <span class="title">insert_into_node</span><span class="params">(BTree tree, BTree node_to_insert, <span class="keyword">int</span> key, <span class="keyword">bool</span> is_key_to_up, <span class="keyword">int</span> index, BTree tree_left, BTree tree_right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//记得每一次产生新的节点之后更新叶子信息。</span></span><br><span class="line">    <span class="comment">//若插入后超载了，则从中间将这个结点一分为二，将中间的结点插入到父节点上，父节点上的插入同理，直到插入成功。</span></span><br><span class="line">    <span class="comment">//若上浮结点且index为-1的话说明是头结点分裂</span></span><br><span class="line">    <span class="comment">//先插入这个结点，再判断是否满</span></span><br><span class="line">    <span class="comment">//node_to_insert==NULL 说明要产生一个新的父节点，当然第一次插入的时候也是如此</span></span><br><span class="line">    <span class="comment">//printf(&quot;insert_into_node %d \n&quot;, key);</span></span><br><span class="line">    <span class="keyword">if</span> (node_to_insert == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = (BTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct BTREE));</span><br><span class="line">        tree-&gt;key[<span class="number">0</span>] = key;</span><br><span class="line">        tree-&gt;key_num = <span class="number">1</span>;</span><br><span class="line">        tree-&gt;child_num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span> * M; i++)</span><br><span class="line">            tree-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//若初始化根节点则都为空，若是后来分裂产生的根节点，则指向传来的参数。</span></span><br><span class="line">        <span class="keyword">if</span> (tree_left)</span><br><span class="line">            tree_left-&gt;parent = tree;</span><br><span class="line">        <span class="keyword">if</span> (tree_right)</span><br><span class="line">            tree_right-&gt;parent = tree;</span><br><span class="line">        tree-&gt;child[<span class="number">0</span>] = tree_left;</span><br><span class="line">        tree-&gt;child[<span class="number">1</span>] = tree_right;</span><br><span class="line">        tree-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//如果不是上浮上来的则为叶子，否则不是叶子</span></span><br><span class="line">        <span class="keyword">if</span> (is_key_to_up)</span><br><span class="line">            tree-&gt;isleaf = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree-&gt;isleaf = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> key_index = <span class="number">-1</span>; <span class="comment">//插入的目标位置</span></span><br><span class="line">    <span class="keyword">if</span> (node_to_insert-&gt;key[<span class="number">0</span>] &gt; key)</span><br><span class="line">    &#123;</span><br><span class="line">        key_index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node_to_insert-&gt;key[node_to_insert-&gt;key_num - <span class="number">1</span>] &lt; key)</span><br><span class="line">    &#123;</span><br><span class="line">        key_index = node_to_insert-&gt;key_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从中间找合适的位置</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= node_to_insert-&gt;key_num - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = node_to_insert-&gt;key[i];</span><br><span class="line">            <span class="keyword">int</span> right = node_to_insert-&gt;key[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ((left &lt; key) &amp;&amp; (key &lt; right))</span><br><span class="line">            &#123;</span><br><span class="line">                key_index = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入到key_index位置，因为有一个冗余的键用于预插入所以可以放心的插入</span></span><br><span class="line">    node_to_insert-&gt;key_num++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = node_to_insert-&gt;key_num - <span class="number">1</span>; i &gt;= key_index + <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        node_to_insert-&gt;key[i] = node_to_insert-&gt;key[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node_to_insert-&gt;key[key_index] = key;</span><br><span class="line">    <span class="comment">//预载入child  只有上升节点才需要更新child</span></span><br><span class="line">    <span class="keyword">if</span> (is_key_to_up)</span><br><span class="line">    &#123;</span><br><span class="line">        node_to_insert-&gt;child_num = node_to_insert-&gt;key_num + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//child[index]指向带上来的左节点，child[index+1]指向右节点，孩子的数量永远等于key的数量加一</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = node_to_insert-&gt;key_num; i &gt;= index + <span class="number">2</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            node_to_insert-&gt;child[i] = node_to_insert-&gt;child[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node_to_insert-&gt;child[key_index] = tree_left;</span><br><span class="line">        node_to_insert-&gt;child[key_index + <span class="number">1</span>] = tree_right;</span><br><span class="line">        tree_left-&gt;parent = node_to_insert;</span><br><span class="line">        tree_right-&gt;parent = node_to_insert;</span><br><span class="line">        <span class="comment">//return tree;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预插入成功，判断是否超载</span></span><br><span class="line">    <span class="comment">//未超载</span></span><br><span class="line">    <span class="keyword">if</span> (node_to_insert-&gt;key_num &lt;= MAX_KEY_NUM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//未超载，去下面判断是否为上浮结点，否的话直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (!is_key_to_up)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超载,将中间的key上浮插入，两边节点各成一家</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle_position = M; <span class="comment">//索引值小于M的为左节点，大于M的为右节点，M为中间节点，上移</span></span><br><span class="line">        <span class="keyword">int</span> key_to_up = node_to_insert-&gt;key[middle_position];</span><br><span class="line">        <span class="comment">//将分裂开的child线分别连接到key_to_up插入的地方的左右</span></span><br><span class="line">        <span class="comment">//这里要注意递归的插入，若当前节点是内部结点还需要进行他的子节点的分配。将中间的子节点分配给右侧的结点，因为不可缺少最左边的child</span></span><br><span class="line">        <span class="comment">//得到 index   指的是上浮结点之前所在的结点是要插入到的结点的第几个child</span></span><br><span class="line">        <span class="keyword">int</span> key_to_up_index = <span class="number">-1</span>; <span class="comment">//若结果是-1，说明没有父节点，这是一个根节点分裂</span></span><br><span class="line">        <span class="comment">//有父节点</span></span><br><span class="line">        <span class="keyword">if</span> (node_to_insert-&gt;parent != <span class="literal">NULL</span>)</span><br><span class="line">        &#123; <span class="comment">//判断index</span></span><br><span class="line">            <span class="keyword">int</span> child_num = node_to_insert-&gt;parent-&gt;key_num + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= child_num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node_to_insert-&gt;parent-&gt;child[i] == node_to_insert)</span><br><span class="line">                &#123;</span><br><span class="line">                    key_to_up_index = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//保留0 - M-1 个key在t_l 剩下的放在右边t_r</span></span><br><span class="line">            BTree t_l = node_to_insert;</span><br><span class="line">            BTree t_r = (BTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct BTREE));</span><br><span class="line">            <span class="keyword">if</span> (!t_r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;内存不足\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            t_r-&gt;key_num = M; <span class="comment">//error: 48344239 原因，电脑内存不够</span></span><br><span class="line">            t_l-&gt;key_num = M;</span><br><span class="line">            <span class="comment">//如果这个结点是因为下层结点上升才分裂的，则为非叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> (is_key_to_up)</span><br><span class="line">            &#123;</span><br><span class="line">                t_r-&gt;isleaf = <span class="literal">false</span>;</span><br><span class="line">                t_l-&gt;isleaf = <span class="literal">false</span>;</span><br><span class="line">                t_r-&gt;child_num = M + <span class="number">1</span>;</span><br><span class="line">                t_l-&gt;child_num = M + <span class="number">1</span>;</span><br><span class="line">                t_r-&gt;parent = node_to_insert-&gt;parent;</span><br><span class="line">                t_l-&gt;parent = node_to_insert-&gt;parent;</span><br><span class="line">                <span class="comment">//非叶子结点，说明其child为满的，并且还有上升结点带来的tree_left 和 tree_right</span></span><br><span class="line">                <span class="comment">//放置child</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_l-&gt;child[i] = node_to_insert-&gt;child[i];</span><br><span class="line">                    t_l-&gt;child[i]-&gt;parent = t_l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= <span class="number">2</span> * M + <span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_r-&gt;child[i - M - <span class="number">1</span>] = node_to_insert-&gt;child[i];</span><br><span class="line">                    t_r-&gt;child[i - M - <span class="number">1</span>]-&gt;parent = t_r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= <span class="number">2</span> * M + <span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_l-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">                    t_r-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//放置key</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M - <span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_l-&gt;key[i] = node_to_insert-&gt;key[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= <span class="number">2</span> * M; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_r-&gt;key[i - M - <span class="number">1</span>] = node_to_insert-&gt;key[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//叶子的分裂 不需要分配child</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                t_r-&gt;isleaf = <span class="literal">true</span>;</span><br><span class="line">                t_l-&gt;isleaf = <span class="literal">true</span>;</span><br><span class="line">                t_r-&gt;child_num = <span class="number">0</span>;</span><br><span class="line">                t_l-&gt;child_num = <span class="number">0</span>;</span><br><span class="line">                t_r-&gt;parent = node_to_insert-&gt;parent;</span><br><span class="line">                t_l-&gt;parent = node_to_insert-&gt;parent;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span> * M + <span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_l-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">                    t_r-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//放置key</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M - <span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_l-&gt;key[i] = node_to_insert-&gt;key[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= <span class="number">2</span> * M; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_r-&gt;key[i - M - <span class="number">1</span>] = node_to_insert-&gt;key[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">insert_into_node</span>(tree, node_to_insert-&gt;parent, key_to_up, <span class="literal">true</span>, key_to_up_index, t_l, t_r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//父节点为空，说明这是一次根节点分裂</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">//保留0 - M-1 个key在t_l 剩下的放在右边t_r</span></span><br><span class="line">            BTree t_l = node_to_insert;</span><br><span class="line">            BTree t_r = (BTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct BTREE));</span><br><span class="line">            t_r-&gt;key_num = M;</span><br><span class="line">            t_l-&gt;key_num = M;</span><br><span class="line">            <span class="comment">//如果这个结点是因为下层结点上升才分裂的，则为非叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> (is_key_to_up)</span><br><span class="line">            &#123;</span><br><span class="line">                t_r-&gt;isleaf = <span class="literal">false</span>;</span><br><span class="line">                t_l-&gt;isleaf = <span class="literal">false</span>;</span><br><span class="line">                t_r-&gt;child_num = M + <span class="number">1</span>;</span><br><span class="line">                t_l-&gt;child_num = M + <span class="number">1</span>;</span><br><span class="line">                t_r-&gt;parent = node_to_insert-&gt;parent;</span><br><span class="line">                t_l-&gt;parent = node_to_insert-&gt;parent;</span><br><span class="line">                <span class="comment">//非叶子结点，说明其child为满的，并且还有上升结点带来的tree_left 和 tree_right</span></span><br><span class="line">                <span class="comment">//放置child</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_l-&gt;child[i] = node_to_insert-&gt;child[i];</span><br><span class="line">                    t_l-&gt;child[i]-&gt;parent = t_l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= <span class="number">2</span> * M + <span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_r-&gt;child[i - M - <span class="number">1</span>] = node_to_insert-&gt;child[i];</span><br><span class="line">                    t_r-&gt;child[i - M - <span class="number">1</span>]-&gt;parent = t_r;</span><br><span class="line">                    t_l-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= <span class="number">2</span> * M + <span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_l-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">                    t_r-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//放置key</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M - <span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_l-&gt;key[i] = node_to_insert-&gt;key[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= <span class="number">2</span> * M; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_r-&gt;key[i - M - <span class="number">1</span>] = node_to_insert-&gt;key[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//叶子的分裂 不需要分配child</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                t_r-&gt;isleaf = <span class="literal">true</span>;</span><br><span class="line">                t_l-&gt;isleaf = <span class="literal">true</span>;</span><br><span class="line">                t_r-&gt;child_num = <span class="number">0</span>;</span><br><span class="line">                t_l-&gt;child_num = <span class="number">0</span>;</span><br><span class="line">                t_r-&gt;parent = node_to_insert-&gt;parent;</span><br><span class="line">                t_l-&gt;parent = node_to_insert-&gt;parent;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span> * M + <span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_l-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">                    t_r-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//放置key</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M - <span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_l-&gt;key[i] = node_to_insert-&gt;key[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= <span class="number">2</span> * M; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    t_r-&gt;key[i - M - <span class="number">1</span>] = node_to_insert-&gt;key[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">insert_into_node</span>(tree, <span class="literal">NULL</span>, key_to_up, <span class="literal">true</span>, <span class="number">-1</span>, t_l, t_r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="function">BTree <span class="title">delete_btree</span><span class="params">(BTree tree, <span class="keyword">bool</span> useindex, BTree del_tree, <span class="keyword">int</span> del_key_index, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 删除叶子节点 且 删除之后key_num&gt;=M , 直接删除</span></span><br><span class="line">    <span class="comment">//2. 删除叶子节点但是删除过后 keu_num&lt;M ,则</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找要删除的数据 不使用index</span></span><br><span class="line">    <span class="keyword">if</span> (useindex == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        del_tree = <span class="built_in">search</span>(tree, key, &amp;del_key_index);</span><br><span class="line">        <span class="keyword">if</span> (del_tree)</span><br><span class="line">            ; <span class="comment">//printf(&quot;search %d\n&quot;, del_tree-&gt;key[del_key_index]);</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;删除失败 没找到 %d\n&quot;</span>, key);</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        key = del_tree-&gt;key[del_key_index];</span><br><span class="line">        <span class="comment">//printf(&quot;删除 %d 使用index\n&quot;,del_tree-&gt;key[del_key_index]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;delete_btree 删除 %d \n&quot;,del_tree-&gt;key[del_key_index]);</span></span><br><span class="line">    <span class="comment">//情况一 叶子结点且删除后key_num&gt;=M 或者是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (((del_tree-&gt;key_num &gt;= M + <span class="number">1</span>) || (del_tree-&gt;parent == <span class="literal">NULL</span>)) &amp;&amp; (del_tree-&gt;isleaf == <span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;1 删除叶子结点 %d \n&quot;,del_tree-&gt;key[del_key_index]);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = del_key_index; i &lt;= del_tree-&gt;key_num - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            del_tree-&gt;key[i] = del_tree-&gt;key[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        del_tree-&gt;key_num--;</span><br><span class="line">        <span class="keyword">if</span> (del_tree-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//根节点</span></span><br><span class="line">            <span class="keyword">if</span> (del_tree-&gt;key_num == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(tree);</span><br><span class="line">                tree = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;1 删除成功\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除叶子(非根节点)，但是删除之后小于M</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((del_tree-&gt;key_num &lt; M + <span class="number">1</span>) &amp;&amp; (del_tree-&gt;isleaf == <span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;2 删除非叶子结点 %d \n&quot;,del_tree-&gt;key[del_key_index]);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = del_key_index; i &lt;= del_tree-&gt;key_num - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            del_tree-&gt;key[i] = del_tree-&gt;key[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        del_tree-&gt;key_num--;</span><br><span class="line">        <span class="comment">//判断左右哪一侧可以借key</span></span><br><span class="line">        <span class="comment">//-1: 左侧是否可以借  1: 右    0：都不可借，只有合并</span></span><br><span class="line">        <span class="keyword">int</span> borrow = <span class="built_in">borrow_direction</span>(del_tree);</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (borrow == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;borrwo -1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> index_child = <span class="built_in">childindex</span>(del_tree-&gt;parent, del_tree);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                index_child--;</span><br><span class="line">                <span class="comment">//将index_child左右两侧进行交换,返回交换过后的左侧结点剩余值</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">l_exchange</span>(del_tree-&gt;parent, index_child) &gt;= M)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (borrow == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;borrwo 1\n&quot;</span>);</span><br><span class="line">            <span class="comment">//这里的叶子为非根节点</span></span><br><span class="line">            <span class="keyword">int</span> index_child = <span class="built_in">childindex</span>(del_tree-&gt;parent, del_tree) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                index_child++;</span><br><span class="line">                <span class="comment">//将index_child左右两侧进行交换,返回交换过后的左侧结点剩余值</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">r_exchange</span>(del_tree-&gt;parent, index_child) &gt;= M)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//都不能借，进行合并</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (borrow == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先合并，合并完成之后判断是否符合标准 返回合并之后的parent,如果是根节点的话就直接返回根节点</span></span><br><span class="line">            del_tree = <span class="built_in">merge</span>(del_tree);</span><br><span class="line">            <span class="comment">//判断是否合格</span></span><br><span class="line">            <span class="keyword">if</span> (del_tree-&gt;key_num &gt;= M || del_tree-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (del_tree-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//根节点</span></span><br><span class="line">                    <span class="keyword">return</span> del_tree;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> tree;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不合格 这里的del肯定不指向根节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                del_tree = <span class="built_in">borrow_from_parent</span>(del_tree);</span><br><span class="line">                <span class="comment">//现在del_tree 指向借的最后一个结点，判断是否借成功  &gt;=M 或者是根节点</span></span><br><span class="line">                <span class="keyword">if</span> (del_tree-&gt;key_num &gt;= M || del_tree-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> tree;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//没有借成功，说明现在del为根节点的儿子且根节点只有一个key</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">merge_root</span>(tree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printf(&quot;2 删除成功\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除非叶子，递归使用后继元素进行替代并且删除后继元素。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (del_tree-&gt;isleaf == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;3 删除非叶子结点 %d \n&quot;,del_tree-&gt;key[del_key_index]);</span></span><br><span class="line">        del_tree;</span><br><span class="line">        del_key_index;</span><br><span class="line">        <span class="keyword">int</span> index_success = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (del_tree-&gt;isleaf == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BTree successor = <span class="built_in">success_btree</span>(tree, <span class="literal">true</span>, del_tree, &amp;del_key_index, <span class="number">-1</span>, &amp;index_success);</span><br><span class="line">            <span class="comment">//替换</span></span><br><span class="line">            del_tree-&gt;key[del_key_index] = successor-&gt;key[index_success];</span><br><span class="line">            del_tree = successor;</span><br><span class="line">            del_key_index = index_success;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//del_tree现在指向叶子结点，递归到上两层。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delete_btree</span>(tree, <span class="literal">true</span>, del_tree, del_key_index, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找后继 即中序遍历中的后面一位</span></span><br><span class="line"><span class="function">BTree <span class="title">success_btree</span><span class="params">(BTree tree, <span class="keyword">bool</span> useindex, BTree tree_source, <span class="keyword">int</span> *index_source, <span class="keyword">int</span> key, <span class="keyword">int</span> *index_success)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不使用index来表示一个key，而是直接传入一个key值来自动寻找。这样即使树种存在两个相同的key也可以寻找到后继了。</span></span><br><span class="line">    <span class="keyword">if</span> (useindex == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        index_source = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">        tree_source = <span class="built_in">search</span>(tree, key, index_source);</span><br><span class="line">    &#125;</span><br><span class="line">    BTree successor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree_source == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *index_success = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是叶子中非最后一个，则返回其后面的一个数据</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((tree_source-&gt;isleaf == <span class="literal">true</span>) &amp;&amp; ((*index_source) &lt; tree_source-&gt;key_num - <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        *index_success = *index_source + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> tree_source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是叶子中的最后一个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((tree_source-&gt;isleaf == <span class="literal">true</span>) &amp;&amp; ((*index_source) == tree_source-&gt;key_num - <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//递归向上遍历，直到找到一个结点不是其父节点的最后一个孩子</span></span><br><span class="line">        BTree t_up = tree_source;</span><br><span class="line">        <span class="keyword">while</span> (t_up)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t_up_child_index = <span class="built_in">childindex</span>(t_up-&gt;parent, t_up);</span><br><span class="line">            <span class="keyword">if</span> (t_up_child_index == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//到达根节点,这里肯定是从最右边到达根节点了，所以返回空</span></span><br><span class="line">                *index_success = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t_up_child_index &lt; t_up-&gt;parent-&gt;key_num)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到一个不是其父节点最后一个孩子的结点，返回父节点 key[t_up_child_index]</span></span><br><span class="line">                *index_success = t_up_child_index;</span><br><span class="line">                <span class="keyword">return</span> t_up-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t_up_child_index == t_up-&gt;parent-&gt;key_num)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//仍然是其父节点的最后一个孩子，继续向上</span></span><br><span class="line">                t_up = t_up-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非叶子</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tree_source-&gt;isleaf == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不是叶子的话总会有后继的。即以其右侧孩子为根节点的最小值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minimum</span>(tree_source-&gt;child[*index_source + <span class="number">1</span>], index_success);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是第几个孩子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">childindex</span><span class="params">(BTree pa, BTree son)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((pa == <span class="literal">NULL</span>) || (son == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= pa-&gt;key_num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa-&gt;child[i] == son)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">borrow_direction</span><span class="params">(BTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> borrow_direction = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index_child = <span class="built_in">childindex</span>(tree-&gt;parent, tree);</span><br><span class="line">    <span class="keyword">if</span> (index_child == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不可借</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num_child = tree-&gt;parent-&gt;key_num + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index_child; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree-&gt;parent-&gt;child[i]-&gt;key_num &gt;= M + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//向左借</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index_child + <span class="number">1</span>; i &lt; num_child; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree-&gt;parent-&gt;child[i]-&gt;key_num &gt;= M + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//向右借</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将index_key左右两侧进行交换,返回交换过后的左侧结点剩余值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">l_exchange</span><span class="params">(BTree tree, <span class="keyword">int</span> index_key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTree left_bro = <span class="literal">NULL</span>;</span><br><span class="line">    BTree right_bro = <span class="literal">NULL</span>;</span><br><span class="line">    left_bro = tree-&gt;child[index_key];</span><br><span class="line">    right_bro = tree-&gt;child[index_key + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> pa_key = tree-&gt;key[index_key];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = right_bro-&gt;key_num; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        right_bro-&gt;key[i] = right_bro-&gt;key[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    right_bro-&gt;key[<span class="number">0</span>] = pa_key;</span><br><span class="line">    tree-&gt;key[index_key] = left_bro-&gt;key[left_bro-&gt;key_num - <span class="number">1</span>];</span><br><span class="line">    left_bro-&gt;key_num--;</span><br><span class="line">    <span class="keyword">return</span> left_bro-&gt;key_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换左侧</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">r_exchange</span><span class="params">(BTree tree, <span class="keyword">int</span> index_key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTree left_bro = <span class="literal">NULL</span>;</span><br><span class="line">    BTree right_bro = <span class="literal">NULL</span>;</span><br><span class="line">    left_bro = tree-&gt;child[index_key];</span><br><span class="line">    right_bro = tree-&gt;child[index_key + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> pa_key = tree-&gt;key[index_key];</span><br><span class="line">    left_bro-&gt;key[left_bro-&gt;key_num++] = pa_key;</span><br><span class="line">    tree-&gt;key[index_key] = right_bro-&gt;key[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right_bro-&gt;key_num - <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        right_bro-&gt;key[i] = right_bro-&gt;key[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    right_bro-&gt;key_num--;</span><br><span class="line">    <span class="keyword">return</span> right_bro-&gt;key_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并一个结点及其孩子 用于节点只有一个key,所以只有两个孩子 这里的tree为父节点</span></span><br><span class="line"><span class="function">BTree <span class="title">merge_onekey</span><span class="params">(BTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTree pa = tree;</span><br><span class="line">    BTree left_bro = tree-&gt;child[<span class="number">0</span>];</span><br><span class="line">    BTree right_bro = tree-&gt;child[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//right_bro上位 重新插入pa和left</span></span><br><span class="line">    left_bro-&gt;parent = pa-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (pa-&gt;parent)</span><br><span class="line">        pa-&gt;parent-&gt;child[<span class="built_in">childindex</span>(pa-&gt;parent, pa)] = right_bro;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tree = right_bro;</span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    tree = <span class="built_in">insert</span>(tree, pa-&gt;key[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= left_bro-&gt;key_num - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = <span class="built_in">insert</span>(tree, left_bro-&gt;key[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并一个结点 这里的tree 是孩子结点</span></span><br><span class="line"><span class="function">BTree <span class="title">merge</span><span class="params">(BTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是最右边的那个孩子则和右兄弟合并</span></span><br><span class="line">    <span class="keyword">int</span> index_child = <span class="built_in">childindex</span>(tree-&gt;parent, tree);</span><br><span class="line">    <span class="keyword">int</span> pa_key_index = <span class="number">-1</span>;</span><br><span class="line">    BTree left_bro = <span class="literal">NULL</span>;</span><br><span class="line">    BTree right_bro = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//最右边的孩子，和左兄弟在一起</span></span><br><span class="line">    <span class="keyword">if</span> (index_child == tree-&gt;parent-&gt;key_num)</span><br><span class="line">    &#123;</span><br><span class="line">        left_bro = tree-&gt;parent-&gt;child[index_child - <span class="number">1</span>];</span><br><span class="line">        right_bro = tree;</span><br><span class="line">        pa_key_index = tree-&gt;parent-&gt;key_num - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是最右边的孩子，则和右兄弟在一起</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        right_bro = tree-&gt;parent-&gt;child[index_child + <span class="number">1</span>];</span><br><span class="line">        left_bro = tree;</span><br><span class="line">        pa_key_index = index_child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left_bro_key_num = left_bro-&gt;key_num;</span><br><span class="line">    left_bro-&gt;key[left_bro_key_num++] = tree-&gt;parent-&gt;key[pa_key_index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right_bro-&gt;key_num - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        left_bro-&gt;key[left_bro_key_num++] = right_bro-&gt;key[i];</span><br><span class="line">    &#125;</span><br><span class="line">    left_bro-&gt;key_num = left_bro_key_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将父节点key进行整合和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pa_key_index; i &lt;= tree-&gt;parent-&gt;key_num - <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;parent-&gt;key[i] = tree-&gt;parent-&gt;key[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tree-&gt;parent-&gt;key_num--;</span><br><span class="line">    <span class="comment">//child</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pa_key_index + <span class="number">1</span>; i &lt;= tree-&gt;parent-&gt;key_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;parent-&gt;child[i] = tree-&gt;parent-&gt;child[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tree-&gt;parent-&gt;child[tree-&gt;parent-&gt;key_num + <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;parent-&gt;child_num = tree-&gt;parent-&gt;key_num + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(right_bro);</span><br><span class="line">    <span class="keyword">if</span> (left_bro-&gt;parent-&gt;key_num == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//说明 left_bro-&gt;parent 为根节点 此时根节点没有key了，只有一个child,所以此时返回 left_bro;</span></span><br><span class="line">        <span class="built_in">free</span>(left_bro-&gt;parent);</span><br><span class="line">        left_bro-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        left_bro-&gt;isleaf = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> left_bro;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回合并后的 parent 以为此时的parent可能key_num&lt;M</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> left_bro-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向父节点借孩子 返回能借到结点的最后一个结点</span></span><br><span class="line"><span class="comment">//判断合并到一起的节点数是否超标，若超标则说明可借，则借一个，否则合并到一起</span></span><br><span class="line"><span class="function">BTree <span class="title">borrow_from_parent</span><span class="params">(BTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span> || tree-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直到父节点是根节点且只有一个key</span></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;parent-&gt;parent == <span class="literal">NULL</span> &amp;&amp; tree-&gt;parent-&gt;key_num == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//借到了富有结点的，不用继续了</span></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;key_num &gt;= M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是其最后一个孩子 跟左兄弟在一起</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">childindex</span>(tree-&gt;parent, tree) == tree-&gt;parent-&gt;key_num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index_child = <span class="built_in">childindex</span>(tree-&gt;parent, tree);</span><br><span class="line">        BTree left_bro = tree-&gt;parent-&gt;child[index_child - <span class="number">1</span>];</span><br><span class="line">        BTree right_bro = tree-&gt;parent-&gt;child[index_child];</span><br><span class="line">        <span class="keyword">int</span> key_num_totle = left_bro-&gt;key_num + right_bro-&gt;key_num + tree-&gt;parent-&gt;key_num;</span><br><span class="line">        <span class="keyword">if</span> (key_num_totle &lt;= <span class="number">2</span> * M)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//可以合并</span></span><br><span class="line">            <span class="built_in">merge_parent</span>(tree-&gt;parent, index_child - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">balance_two_child</span>(tree-&gt;parent, index_child - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">borrow_from_parent</span>(tree-&gt;parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是最后一个孩子</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index_child = <span class="built_in">childindex</span>(tree-&gt;parent, tree);</span><br><span class="line">        BTree left_bro = tree-&gt;parent-&gt;child[index_child];</span><br><span class="line">        BTree right_bro = tree-&gt;parent-&gt;child[index_child + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> key_num_totle = left_bro-&gt;key_num + right_bro-&gt;key_num + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (key_num_totle &lt;= <span class="number">2</span> * M)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//可以合并</span></span><br><span class="line">            <span class="built_in">merge_parent</span>(tree-&gt;parent, index_child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">balance_two_child</span>(tree-&gt;parent, index_child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">borrow_from_parent</span>(tree-&gt;parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">borrow_from_parent</span>(tree-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tree 为根节点，合并其与其孩子 事情能到这一步说明tree只有两个孩子了</span></span><br><span class="line"><span class="function">BTree <span class="title">merge_root</span><span class="params">(BTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTree left_bro = tree-&gt;child[<span class="number">0</span>];</span><br><span class="line">    BTree right_bro = tree-&gt;child[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//判断总共的key个数</span></span><br><span class="line">    <span class="keyword">int</span> key_num_totle = left_bro-&gt;key_num + right_bro-&gt;key_num + tree-&gt;key_num;</span><br><span class="line">    <span class="keyword">if</span> (key_num_totle &lt;= <span class="number">2</span> * M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可以合并到一起</span></span><br><span class="line">        <span class="keyword">int</span> left_bro_key_num = left_bro-&gt;key_num;</span><br><span class="line">        <span class="keyword">int</span> left_bro_child_num = left_bro_key_num + <span class="number">1</span>;</span><br><span class="line">        left_bro-&gt;key[left_bro_key_num++] = tree-&gt;key[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right_bro-&gt;key_num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            left_bro-&gt;key[left_bro_key_num++] = right_bro-&gt;key[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right_bro-&gt;key_num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            right_bro-&gt;child[i]-&gt;parent = left_bro;</span><br><span class="line">            left_bro-&gt;child[left_bro_child_num++] = right_bro-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        left_bro-&gt;key_num = left_bro_key_num;</span><br><span class="line">        <span class="built_in">free</span>(tree);</span><br><span class="line">        <span class="built_in">free</span>(right_bro);</span><br><span class="line">        left_bro-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> left_bro;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//太多了合并不到一起</span></span><br><span class="line">        <span class="comment">//此时结点多的哪一个借一些结点给另一个</span></span><br><span class="line">        <span class="keyword">int</span> left_bro_key_num = left_bro-&gt;key_num;</span><br><span class="line">        <span class="keyword">int</span> right_bro_key_num = right_bro-&gt;key_num;</span><br><span class="line">        <span class="keyword">if</span> (left_bro_key_num &gt; right_bro_key_num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//左侧KEY多</span></span><br><span class="line">            right_bro-&gt;key_num++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right_bro-&gt;key_num - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                right_bro-&gt;key[i] = right_bro-&gt;key[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            right_bro-&gt;key[<span class="number">0</span>] = tree-&gt;key[<span class="number">0</span>];</span><br><span class="line">            tree-&gt;key[<span class="number">0</span>] = left_bro-&gt;key[left_bro-&gt;key_num - <span class="number">1</span>];</span><br><span class="line">            left_bro-&gt;key_num--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right_bro-&gt;key_num; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                right_bro-&gt;child[i] = right_bro-&gt;child[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            right_bro-&gt;child[<span class="number">0</span>] = left_bro-&gt;child[left_bro-&gt;key_num + <span class="number">1</span>];</span><br><span class="line">            right_bro-&gt;child[<span class="number">0</span>]-&gt;parent = right_bro;</span><br><span class="line">            left_bro-&gt;child[left_bro-&gt;key_num + <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//右侧key多 从右边向左边移动一个</span></span><br><span class="line">            left_bro-&gt;key[left_bro-&gt;key_num++] = tree-&gt;key[<span class="number">0</span>];</span><br><span class="line">            tree-&gt;key[<span class="number">0</span>] = right_bro-&gt;key[<span class="number">0</span>];</span><br><span class="line">            left_bro-&gt;child[left_bro-&gt;key_num] = right_bro-&gt;child[<span class="number">0</span>];</span><br><span class="line">            right_bro-&gt;child[<span class="number">0</span>]-&gt;parent = left_bro;</span><br><span class="line">            right_bro-&gt;key_num--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right_bro-&gt;key_num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                right_bro-&gt;child[i] = right_bro-&gt;child[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right_bro-&gt;key_num - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                right_bro-&gt;key[i] = right_bro-&gt;key[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            right_bro-&gt;child[right_bro-&gt;key_num + <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//协调两个孩子的节点数量 多的给少的一个，这其中当然也要通过parent-&gt;key进行交换</span></span><br><span class="line"><span class="function">BTree <span class="title">balance_two_child</span><span class="params">(BTree tree, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//index为父节点的keyindex,协调其左右两侧的孩子</span></span><br><span class="line">    BTree pa = tree;</span><br><span class="line">    BTree left_bro = pa-&gt;child[index];</span><br><span class="line">    BTree right_bro = pa-&gt;child[index + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (left_bro-&gt;key_num &gt; M &amp;&amp; right_bro-&gt;key_num &lt; M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//左侧KEY多</span></span><br><span class="line">        <span class="comment">//更新右节点的key</span></span><br><span class="line">        right_bro-&gt;key_num++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right_bro-&gt;key_num - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            right_bro-&gt;key[i] = right_bro-&gt;key[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        right_bro-&gt;key[<span class="number">0</span>] = tree-&gt;key[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//跟新父节点</span></span><br><span class="line">        tree-&gt;key[<span class="number">0</span>] = left_bro-&gt;key[left_bro-&gt;key_num - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//更新左节点的key_num</span></span><br><span class="line">        left_bro-&gt;key_num--;</span><br><span class="line">        <span class="comment">//更新右节点的child</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right_bro-&gt;key_num; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            right_bro-&gt;child[i] = right_bro-&gt;child[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        right_bro-&gt;child[<span class="number">0</span>] = left_bro-&gt;child[left_bro-&gt;key_num + <span class="number">1</span>];</span><br><span class="line">        right_bro-&gt;child[<span class="number">0</span>]-&gt;parent = right_bro;</span><br><span class="line">        left_bro-&gt;child[left_bro-&gt;key_num + <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((right_bro-&gt;key_num &gt; M &amp;&amp; left_bro-&gt;key_num &lt; M))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//右孩子的key数量多，借给左孩子</span></span><br><span class="line">        <span class="comment">//父节点下移</span></span><br><span class="line">        left_bro-&gt;key[left_bro-&gt;key_num++] = tree-&gt;key[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//更新父节点</span></span><br><span class="line">        tree-&gt;key[<span class="number">0</span>] = right_bro-&gt;key[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//更新左节点的孩子</span></span><br><span class="line">        left_bro-&gt;child[left_bro-&gt;key_num] = right_bro-&gt;child[<span class="number">0</span>];</span><br><span class="line">        right_bro-&gt;child[<span class="number">0</span>]-&gt;parent = left_bro;</span><br><span class="line">        <span class="comment">//更新右节点</span></span><br><span class="line">        right_bro-&gt;key_num--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right_bro-&gt;key_num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            right_bro-&gt;child[i] = right_bro-&gt;child[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right_bro-&gt;key_num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            right_bro-&gt;key[i] = right_bro-&gt;key[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        right_bro-&gt;child[right_bro-&gt;key_num + <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并tree index 两边的孩子 前提是合并之后不超</span></span><br><span class="line"><span class="function">BTree <span class="title">merge_parent</span><span class="params">(BTree tree, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//index为父节点的keyindex,合并其左右两侧的孩子</span></span><br><span class="line">    BTree pa = tree;</span><br><span class="line">    BTree left_bro = pa-&gt;child[index];</span><br><span class="line">    BTree right_bro = pa-&gt;child[index + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    left_bro-&gt;child_num = left_bro-&gt;key_num + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//整合left</span></span><br><span class="line">    left_bro-&gt;key[left_bro-&gt;key_num++] = pa-&gt;key[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right_bro-&gt;key_num - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        left_bro-&gt;key[left_bro-&gt;key_num++] = right_bro-&gt;key[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right_bro-&gt;key_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        left_bro-&gt;child[left_bro-&gt;child_num++] = right_bro-&gt;child[i];</span><br><span class="line">        right_bro-&gt;child[i]-&gt;parent = left_bro;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//整合pa</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= pa-&gt;key_num - <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pa-&gt;key[i] = pa-&gt;key[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt;= pa-&gt;key_num - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pa-&gt;child[i] = pa-&gt;child[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    pa-&gt;child[pa-&gt;key_num--] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁b树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(BTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 128</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BTree.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一亿条数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_NUM 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//阶数增大但又不太大 则查询时间增大，其余时间减少</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;效率test 当前阶数为 %d \n&quot;</span>, M);</span><br><span class="line">    <span class="keyword">time_t</span> start, end, t1, t2;</span><br><span class="line"></span><br><span class="line">    start = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    BTree tree = <span class="built_in">BTree_Init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ITEM_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = <span class="built_in">insert</span>(tree, i);</span><br><span class="line">    &#125;</span><br><span class="line">    end = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入 %d%% 个数用时 %d s\n&quot;</span>, ITEM_NUM, end - start);</span><br><span class="line"></span><br><span class="line">    start = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">preorder</span>(tree);</span><br><span class="line">    <span class="built_in">inorder</span>(tree);</span><br><span class="line">    <span class="built_in">postorder</span>(tree);</span><br><span class="line">    end = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;遍历 %d 个数用时 %d s\n&quot;</span>, ITEM_NUM, end - start);</span><br><span class="line"></span><br><span class="line">    start = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ITEM_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        BTree result = <span class="built_in">search</span>(tree, i, &amp;index); <span class="comment">//4782968</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nsearch: %d index: %d\n&quot;</span>, result-&gt;key[index], index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n未找到 %d \n&quot;</span>);</span><br><span class="line">            <span class="comment">//exit(EXIT_FAILURE);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;递归查询 %d 个数用时 %d s\n&quot;</span>, ITEM_NUM, end - start);</span><br><span class="line"></span><br><span class="line">    start = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ITEM_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        BTree result = <span class="built_in">search_iterative</span>(tree, i, &amp;index); <span class="comment">//4782968</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;\nsearch: %d index: %d\n&quot;, result-&gt;key[index],index);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n未找到 %d \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;非递归查询 %d 个数用时 %d s\n&quot;</span>, ITEM_NUM, end - start);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;delete test\n&quot;</span>);</span><br><span class="line">    start = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    t1 = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ITEM_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        t2 = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (t2 - t1 == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;已删除 %f \n&quot;</span>, i * <span class="number">1.0</span> / ITEM_NUM * <span class="number">100.0</span>);</span><br><span class="line">            t1 = t2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tree = <span class="built_in">delete_btree</span>(tree, <span class="literal">false</span>, <span class="literal">NULL</span>, <span class="number">-1</span>, i);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        BTree result = <span class="built_in">search</span>(tree, i, &amp;index); <span class="comment">//4782968</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n 删除失败-----------search: %d index: %d\n&quot;</span>, result-&gt;key[index], index);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//inorder(tree);</span></span><br><span class="line">            <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除 %d 个数用时 %d s\n&quot;</span>, ITEM_NUM, end - start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;delete test finish\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>B-tree</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>B-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>json learn 一</title>
    <url>/2021/08/23/json-learn-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="json-learn-1"><a href="#json-learn-1" class="headerlink" title="json learn 1"></a>json learn 1</h1><p>之前收藏过miloyip的json教程，现在想学习一下。</p>
<blockquote>
<p>为什么现在要学习这个呢？</p>
<ul>
<li>首先这几天我对未来的方向越发的清晰了，未来我想从事有关计算机图形学底层相关职业，所以我想重新学习计算机图形学，将之前的游戏引擎重新实现一遍。</li>
<li>想要重写之前的游戏引擎就必须将模型加载自己实现一次，虽然github上有一个tinyobj_loader的项目，但是我现在看不懂，还需要学习更加多的底层知识才可以。</li>
<li>要想增强自己的底层开发能力，必须跟着几个项目进行学习。目前可以学习的资源有：tinyobj_loader，database, 郑刚的操作系统，c4编译器等。</li>
<li>目前我正在准备考研，所以并没有太多时间，只能先学习一些小的项目，不然的话做项目上瘾就没有时间准备考研了。</li>
<li>思来想去，目前来看最合适的项目就是这个json教程了。学完这个教程可以实现一个递归下降的解析器，这又为学习C4做了准备，同时也为CDB做了准备。</li>
<li>于是决定学习json</li>
</ul>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/json-tutorial">从零开始的JSON库教程</a></p>
<p><a href="https://github.com/miloyip/json-tutorial">GitHub</a></p>
<h2 id="json简介"><a href="#json简介" class="headerlink" title="json简介"></a>json简介</h2><p>json又六种数据类型，如下：</p>
<ol>
<li>null 表示为 null</li>
<li>布尔值 表示为 true false</li>
<li>数字 表示为 12345</li>
<li>string 表示为 “12345”</li>
<li>数组 表示为 [1,”23”,45]</li>
<li>对象 表示为 {……}</li>
</ol>
<p>一个基本的json库需要拥有下面三种功能：</p>
<ol>
<li>将json文件解析为数据结构 parse</li>
<li>将数据结构保存为json文件 stringify</li>
<li>对外提供接口访问解析出来的数据结构 access</li>
</ol>
]]></content>
      <categories>
        <category>project</category>
        <category>json</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 十 排序</title>
    <url>/2021/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%81-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="数据结构-十-排序"><a href="#数据结构-十-排序" class="headerlink" title="数据结构 十 排序"></a>数据结构 十 排序</h1><h2 id="sort-h"><a href="#sort-h" class="headerlink" title="sort.h"></a>sort.h</h2><p>对于基数排序的实现，这位<a href="https://wangkuiwu.github.io/2013/05/10/radix-sort/">大神</a>太厉害了。<a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/algrightm/sort/radix_sort/c/radix_sort.c">代码</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 内部排序</span></span><br><span class="line"><span class="comment">    1. 插入排序</span></span><br><span class="line"><span class="comment">        1. 直接插入排序</span></span><br><span class="line"><span class="comment">        2. 折半插入排序</span></span><br><span class="line"><span class="comment">        3. 希尔排序</span></span><br><span class="line"><span class="comment">    2. 交换排序</span></span><br><span class="line"><span class="comment">        1. 冒泡排序</span></span><br><span class="line"><span class="comment">        2. 快速排序</span></span><br><span class="line"><span class="comment">    3. 选择排序</span></span><br><span class="line"><span class="comment">        1. 简单选择排序</span></span><br><span class="line"><span class="comment">        2. 堆排序</span></span><br><span class="line"><span class="comment">    4. 归并排序</span></span><br><span class="line"><span class="comment">    5. 基数排序  </span></span><br><span class="line"><span class="comment">2. 外部排序</span></span><br><span class="line"><span class="comment">    1. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_result</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">direct_insert_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">half_insert_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_select_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"><span class="comment">//调整heap的一个子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_adjust</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end, <span class="keyword">int</span> seq, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"><span class="comment">//归并 归并low-mid mid+1-high</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="sort-c"><a href="#sort-c" class="headerlink" title="sort.c"></a>sort.c</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_result</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; begin != end; begin++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *begin);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *begin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">direct_insert_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;direct_insert_sort\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *a = begin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将a[i]放在前面合适的地方</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; temp; j--)</span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">        a[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">half_insert_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;half_insert_sort\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *a = begin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//折半查找插入的位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[mid] &gt; temp)</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= low + <span class="number">1</span>; j--)</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">        a[low] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shell_sort\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> step = num;</span><br><span class="line">    <span class="keyword">int</span> *a = begin;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        step /= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//分段排序 直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt;= step - <span class="number">1</span>; start++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//每一段的起始位start</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + step; i &lt;= num - <span class="number">1</span>; i += step)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将a[i]放在前面合适的地方</span></span><br><span class="line">                <span class="keyword">int</span> temp = a[i];</span><br><span class="line">                <span class="keyword">int</span> j = start;</span><br><span class="line">                <span class="keyword">for</span> (j = i - step; j &gt;= start &amp;&amp; a[j] &gt; temp; j -= step)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[j + step] = a[j];</span><br><span class="line">                &#125;</span><br><span class="line">                a[j + step] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (step != <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bubble_sort\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *a = begin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= num - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;quick_sort\n&quot;</span>);</span><br><span class="line">    <span class="comment">//选择一个基准，不断地从后向前，从前向后进行交换</span></span><br><span class="line">    <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *a = begin;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> high = num - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从右向左找</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; a[high] &gt;= mid)</span><br><span class="line">                high--;</span><br><span class="line">            a[low] = a[high];</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; a[low] &lt;= mid)</span><br><span class="line">                low++;</span><br><span class="line">            a[high] = a[low];</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = mid;</span><br><span class="line">        <span class="built_in">quick_sort</span>(begin, begin + low - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quick_sort</span>(begin + low + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_select_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;simple_select_sort\n&quot;</span>);</span><br><span class="line">    <span class="comment">//每一次从乱序的序列中选择一个最小的放在顺序序列的最后面。</span></span><br><span class="line">    <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *a = begin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从 i - num-i中选择一个最下的放在i</span></span><br><span class="line">        <span class="keyword">int</span> min_index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= num - <span class="number">1</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[min_index])</span><br><span class="line">                min_index = j;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[min_index];</span><br><span class="line">        a[min_index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;heap_sort\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//首先建立大根堆，即对 n/2 - 1 为根的子树进行调整。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">heap_adjust</span>(begin, end, i, num);</span><br><span class="line">    <span class="comment">//循环输出最大值，并调整堆。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = begin[<span class="number">0</span>];</span><br><span class="line">        begin[<span class="number">0</span>] = begin[num - i - <span class="number">1</span>];</span><br><span class="line">        begin[num - i - <span class="number">1</span>] = temp;</span><br><span class="line">        <span class="built_in">heap_adjust</span>(begin, end, <span class="number">0</span>, num - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调整heap的一个子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_adjust</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end, <span class="keyword">int</span> seq, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将树根与其最大的孩子进行交换，递归直到叶子。</span></span><br><span class="line">    <span class="keyword">int</span> temp = begin[seq];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = seq * <span class="number">2</span> + <span class="number">1</span>; i &lt; len; i = i * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//指向大的孩子</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; begin[i] &lt; begin[i + <span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; begin[i])</span><br><span class="line">        &#123;</span><br><span class="line">            begin[seq] = begin[i];</span><br><span class="line">            seq = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt;= begin[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    begin[seq] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = num / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">merge_sort</span>(begin, begin + mid - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">merge_sort</span>(begin + mid, end);</span><br><span class="line">        <span class="built_in">merge</span>(begin, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并 归并low-mid mid+1-high</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//即将传进来的数组进行排序。</span></span><br><span class="line">    <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = num / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 0-mid-1 mid-end</span></span><br><span class="line">    <span class="keyword">int</span> num_a = mid;</span><br><span class="line">    <span class="keyword">int</span> num_b = num - mid;</span><br><span class="line">    <span class="keyword">int</span> *a = begin;</span><br><span class="line">    <span class="keyword">int</span> *b = begin + num_a;</span><br><span class="line">    <span class="keyword">int</span> *c = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(num * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; num_a &amp;&amp; j &lt; num_b)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= b[j])</span><br><span class="line">            c[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c[k++] = b[j++];</span><br><span class="line">    <span class="comment">//将剩下的全部放入c中</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; num_a)</span><br><span class="line">        <span class="keyword">while</span> (i &lt; num_a)</span><br><span class="line">            c[k++] = a[i++];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; num_b)</span><br><span class="line">            c[k++] = b[j++];</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= num - <span class="number">1</span>; k++)</span><br><span class="line">        begin[k] = c[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bucket_sort\n&quot;</span>);</span><br><span class="line">    <span class="comment">//建立一个桶数组，将元素放在对应的桶中，取出。</span></span><br><span class="line">    <span class="comment">//就好像统计每一个元素的个数并根据该信息创造出来一个一摸一样的元素序列。</span></span><br><span class="line">    <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (max &lt; begin[i])</span><br><span class="line">            max = begin[i];</span><br><span class="line">    <span class="keyword">int</span> *bucket = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((max + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(bucket, <span class="number">0</span>, (max + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">        bucket[begin[i]]++;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bucket[i] - <span class="number">1</span>; j++)</span><br><span class="line">            begin[num++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span> *begin, <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;radix_sort\n&quot;</span>);</span><br><span class="line">    <span class="comment">//对关键字的每一位进行依次桶排序，从低位到高位。</span></span><br><span class="line">    <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (max &lt; begin[i])</span><br><span class="line">            max = begin[i];</span><br><span class="line">    <span class="keyword">int</span> radix[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> *output = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(num * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> exp = <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(radix, <span class="number">0</span>, <span class="number">10</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="built_in">memset</span>(output, <span class="number">0</span>, num * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++) <span class="comment">//&#123;2, 6, 4, 1, 3, 7, 9, 45, 4, 23, 0&#125;;</span></span><br><span class="line">            radix[(begin[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line">        <span class="comment">//重组radix,令其代表其数应该在的位置。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">            radix[i] += radix[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//将排序好的数输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            output[(radix[(begin[i] / exp) % <span class="number">10</span>]--) - <span class="number">1</span>] = begin[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存输出</span></span><br><span class="line">        <span class="built_in">memcpy</span>(begin, output, num * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sort.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[] = &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">45</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//direct_insert_sort(num, num + 10);</span></span><br><span class="line">    <span class="comment">//half_insert_sort(num, num + 10);</span></span><br><span class="line">    <span class="comment">//shell_sort(num,num+10);</span></span><br><span class="line">    <span class="comment">//bubble_sort(num,num+10);</span></span><br><span class="line">    <span class="comment">//quick_sort(num,num+10);</span></span><br><span class="line">    <span class="comment">//simple_select_sort(num,num+10);</span></span><br><span class="line">    <span class="comment">//heap_sort(num, num + 10);</span></span><br><span class="line">    <span class="comment">//merge_sort(num,num+10);</span></span><br><span class="line">    <span class="comment">//bucket_sort(num,num+10);</span></span><br><span class="line">    <span class="comment">//radix_sort(num, num + 10);</span></span><br><span class="line">    <span class="built_in">printf_result</span>(num, num + <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
