<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="Hello, here is wenyao&#39;s space, how do you come in???" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    os 003 protected mode |  这里是文耀的space
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

<link rel="alternate" href="/atom.xml" title="这里是文耀的space" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-os-003-protected-mode"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  os 003 protected mode
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/05/14/os-003-protected-mode/" class="article-date">
  <time datetime="2021-05-14T02:45:15.000Z" itemprop="datePublished">2021-05-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/os/">os</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">27 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected mode"></a>protected mode</h1><h4 id="保护模式简介"><a href="#保护模式简介" class="headerlink" title="保护模式简介"></a>保护模式简介</h4><h6 id="实模式的缺陷"><a href="#实模式的缺陷" class="headerlink" title="实模式的缺陷"></a>实模式的缺陷</h6><ol>
<li><p>实模式下操作系统与用户程序属于听一个特权级，容易引起系统崩溃。</p>
</li>
<li><p>程序引用的地址指向真实的物理地址，即逻辑地址等于物理地址，不利于内存分片管理，容易造成内存碎片化。</p>
</li>
<li><p>用户程序可以随意访问任意内存。</p>
</li>
<li><p>一个短只能访问64KB地址，太小了，操作不方便。</p>
</li>
<li><p>一次只能运行一个程序。</p>
</li>
<li><p>只有20根地址线，只能寻址1M的空间，太小啦。   </p>
</li>
</ol>
<blockquote>
<p>为了克服实模式低劣的内存管理方式，开发出了保护模式。  </p>
</blockquote>
<h6 id="保护模式的特点"><a href="#保护模式的特点" class="headerlink" title="保护模式的特点"></a>保护模式的特点</h6><ol>
<li>寄存器扩展。</li>
<li>寻址空间扩展为4GB。</li>
<li>对内存分段并进行描述。全局描述符表，全局描述符表寄存器，段描述符缓冲寄存器。</li>
<li></li>
</ol>
<h6 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h6><p>进入保护模式的步骤为：</p>
<ol>
<li>打开A20</li>
<li>加载gdt</li>
<li>将cr0的pe位置1</li>
<li>jmp 刷新流水线</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;-----------------  打开A20  ----------------</span><br><span class="line">in al,0x92</span><br><span class="line">or al,0000_0010B</span><br><span class="line">out 0x92,al</span><br><span class="line"></span><br><span class="line">;-----------------  加载GDT  ----------------</span><br><span class="line">lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------  cr0第0位置1  ----------------</span><br><span class="line">mov eax, cr0</span><br><span class="line">or eax, 0x00000001</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>

<h4 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h4><h6 id="段描述符的结构"><a href="#段描述符的结构" class="headerlink" title="段描述符的结构"></a>段描述符的结构</h6><table>
<thead>
<tr>
<th>位</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>高32位</td>
<td></td>
</tr>
<tr>
<td>31-24</td>
<td>段基址31-24</td>
</tr>
<tr>
<td>23</td>
<td>G</td>
</tr>
<tr>
<td>22</td>
<td>D/B</td>
</tr>
<tr>
<td>21</td>
<td>L</td>
</tr>
<tr>
<td>20</td>
<td>AVL</td>
</tr>
<tr>
<td>19-16</td>
<td>段界限19-16</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
</tr>
<tr>
<td>14-13</td>
<td>DPL</td>
</tr>
<tr>
<td>12</td>
<td>S</td>
</tr>
<tr>
<td>11-8</td>
<td>TYPE</td>
</tr>
<tr>
<td>7-0</td>
<td>段基址23-16</td>
</tr>
<tr>
<td>低32位</td>
<td></td>
</tr>
<tr>
<td>31-16</td>
<td>段基址15-0</td>
</tr>
<tr>
<td>15-0</td>
<td>段界限15-0</td>
</tr>
</tbody></table>
<ol>
<li>实际的段界限值=（描述符中的段界限值+1）*（段界限的粒度，1B 或者 4KB) - 1</li>
<li>G=0，粒度为1B，G=1，粒度为4KB.<br>3、E=0，向上扩展，常用于代码段与数据段。E=1，向下扩展，常用于栈段。</li>
</ol>
<h6 id="全局描述符表-GDT"><a href="#全局描述符表-GDT" class="headerlink" title="全局描述符表 GDT"></a>全局描述符表 GDT</h6><p>全局描述符表相当于描述符的数组，每一个元素是8字节的描述符，使用选择子进行索引。GDT中的第0个描述符是不可用的。</p>
<h6 id="全局描述符表寄存器-GDTR"><a href="#全局描述符表寄存器-GDTR" class="headerlink" title="全局描述符表寄存器 GDTR"></a>全局描述符表寄存器 GDTR</h6><p>GDT存在于内存中，GDTR是一个专门指向全局描述符表的寄存器。结构如下：</p>
<table>
<thead>
<tr>
<th>47-15</th>
<th>15-0</th>
</tr>
</thead>
<tbody><tr>
<td>GDT初始地址</td>
<td>GDT界限</td>
</tr>
</tbody></table>
<p>在实模式先使用lgdt加载描述符表，但是由于实模式的限制，此时的GTD只能处于1M地址空间以内，所以到了保护模式可以再次进行lgdt更改GDT的位置。</p>
<p>lgdt [48位内存数据]<br>按小端字节序，前16位用于舒适化GDT界限，后32位，用于指定GDT的初始地址。</p>
<h6 id="选择子"><a href="#选择子" class="headerlink" title="选择子"></a>选择子</h6><p>在实模式下，段寄存器选择的是段基址，在开启内存分段后，段寄存器存储的是对应段描述符表的索引和相关数据。选择子的结构如下：</p>
<table>
<thead>
<tr>
<th>15-4</th>
<th>3</th>
<th>2-0</th>
</tr>
</thead>
<tbody><tr>
<td>描述符索引值</td>
<td>TI</td>
<td>RPL</td>
</tr>
</tbody></table>
<p>描述符索引值正好为12位，刚好和GDTR界限所确定的最大描述符数量相匹配。</p>
<h4 id="获得内存信息"><a href="#获得内存信息" class="headerlink" title="获得内存信息"></a>获得内存信息</h4><p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">;-------  int 15h eax &#x3D; 0000E820h ,edx &#x3D; 534D4150h (&#39;SMAP&#39;) 获取内存布局  -------</span><br><span class="line"></span><br><span class="line">   xor ebx, ebx		      ;第一次调用时，ebx值要为0</span><br><span class="line">   mov edx, 0x534d4150	      ;edx只赋值一次，循环体中不会改变</span><br><span class="line">   mov di, ards_buf	      ;ards结构缓冲区</span><br><span class="line">.e820_mem_get_loop:	      ;循环获取每个ARDS内存范围描述结构</span><br><span class="line">   mov eax, 0x0000e820	      ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span><br><span class="line">   mov ecx, 20		      ;ARDS地址范围描述符结构大小是20字节</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能</span><br><span class="line">   add di, cx		      ;使di增加20字节指向缓冲区中新的ARDS结构位置</span><br><span class="line">   inc word [ards_nr]	      ;记录ARDS数量</span><br><span class="line">   cmp ebx, 0		      ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span><br><span class="line">   jnz .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span><br><span class="line">   mov cx, [ards_nr]	      ;遍历每一个ARDS结构体,循环次数是ARDS的数量</span><br><span class="line">   mov ebx, ards_buf </span><br><span class="line">   xor edx, edx		      ;edx为最大的内存容量,在此先清0</span><br><span class="line">.find_max_mem_area:	      ;无须判断type是否为1,最大的内存块一定是可被使用</span><br><span class="line">   mov eax, [ebx]	      ;base_add_low</span><br><span class="line">   add eax, [ebx+8]	      ;length_low</span><br><span class="line">   add ebx, 20		      ;指向缓冲区中下一个ARDS结构</span><br><span class="line">   cmp edx, eax		      ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span><br><span class="line">   jge .next_ards</span><br><span class="line">   mov edx, eax		      ;edx为总内存大小</span><br><span class="line">.next_ards:</span><br><span class="line">   loop .find_max_mem_area</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;------  int 15h ax &#x3D; E801h 获取内存大小,最大支持4G  ------</span><br><span class="line">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span><br><span class="line">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span><br><span class="line">.e820_failed_so_try_e801:</span><br><span class="line">   mov ax,0xe801</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法</span><br><span class="line"></span><br><span class="line">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span><br><span class="line">   mov cx,0x400	     ;cx和ax值一样,cx用做乘数</span><br><span class="line">   mul cx </span><br><span class="line">   shl edx,16</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">   or edx,eax</span><br><span class="line">   add edx, 0x100000 ;ax只是15MB,故要加1MB</span><br><span class="line">   mov esi,edx	     ;先把低15MB的内存容量存入esi寄存器备份</span><br><span class="line"></span><br><span class="line">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span><br><span class="line">   xor eax,eax</span><br><span class="line">   mov ax,bx		</span><br><span class="line">   mov ecx, 0x10000	;0x10000十进制为64KB</span><br><span class="line">   mul ecx		;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span><br><span class="line">   add esi,eax		;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span><br><span class="line">   mov edx,esi		;edx为总内存大小</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;-----------------  int 15h ah &#x3D; 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88: </span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">      </span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16	     ;把dx移到高16位</span><br><span class="line">   or edx, eax	     ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx	 ;将内存换为byte单位后存入total_mem_bytes处。</span><br></pre></td></tr></table></figure>

<h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p><strong>分段是分页的前提</strong></p>
<h6 id="内存分段模式下的问题"><a href="#内存分段模式下的问题" class="headerlink" title="内存分段模式下的问题"></a>内存分段模式下的问题</h6><ol>
<li>物理内存不足时怎么把？</li>
<li>内存碎片化问题怎么解决。</li>
</ol>
<blockquote>
<p>在保护模式下，段描述符是内存段的身份证，cpu根据一个段描述符来引用一个段。很多时候，段描述符对应的段并不在内存中。如果一个描述符的P位为1，则表示该段在内存中存在。访问过一个段后，cpu将该描述符中的A为置1。如果P位为0，则说明内存中不存在这个段，则cpu抛出np异常，操作系统将对应的段加载到内存中。</p>
</blockquote>
<blockquote>
<p>分页机制的思想是，通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的额线性地址在物理上可以不连续。分页机制将大小不不等的段分解为大小相等的页，再将页映射到物理页。分页机制的作用有：将线性地址转化为物理地址，用大小相等的页代替大小不等的段。有了页表的映射关系，经过段部件的处理输出的则为虚拟地址。在分页机制下，每个进程都认为自己独享整个4GB空间。即程序以为自己身处于段式存储下并拥有4GB空间，但是他的地址经由页部件处理之后才是真正的物理地址。</p>
</blockquote>
<h6 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h6><blockquote>
<p>页表用于存储线性地址与物理地址之间的映射。页表中的每一项为大小为4字节的页表项，用来记录4GB空间的物理地址。当访问一个线性地址的时候，实际上就是在访问页表项中对应的物理地址。</p>
</blockquote>
<blockquote>
<p>每个页大小为4KB，一个页表可以存储1M个页表项，加起来一个页表可以表示整个4GB物理空间。</p>
</blockquote>
<blockquote>
<p>一级页表的地址转换过程为：用线性地址的高20位作为页表项的索引，每个页表项占用4字节的大小，索引值乘上4就可以得到该页表项在页表中的偏移量。用cr3寄存器中的页表物理地址加上此偏移量就可以得到该页表项的物理地址，从该页表项中得到映射的物理地址，再与低12位的线性地址相加就可以得到最终要访问的物理地址。</p>
</blockquote>
<blockquote>
<p>假设咱们是在平坦模型下工作，不管段选择子值是多少，其所指向的段基址都是 0，指令 mov ax，<br>[0x1234]中的 0x1234 称为有效地址，它作为“段基址：段内偏移地址”中的段内偏移地址。这样段基址<br>为 0，段内偏移地址为 0x1234，经过段部件处理后，输出的线性地址是 0x1234。由于咱们是演示分页机制，必须假定系统已经打开了分页机制，所以线性地址 0x1234 被送入了页部件。页部件分析 0x1234 的高20 位，用十六进制表示高 20 位是 0x00001。将此项作为页表项索引，再将该索引乘以 4 后加上 cr3 寄存器中页表的物理地址，这样便得到索引所指代的页表项的物理地址，从该物理地址处（页表项中）读取所映射的物理页地址：0x9000。线性地址的低 12 位是 0x234，它作为物理页的页内偏移地址与物理页地址0x9000 相加，和为 0x9234，这就是线性地址 0x1234 最终转换成的物理地址。     </p>
</blockquote>
<h6 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h6><blockquote>
<p>二级页表将4GB空间按每一个标准页大小4KB分为1M个页，将这1M个页分1K*1K个页，每1K个页表项又正好可以组成一个新的页（1K*4B=4KB），将这个新产生的页记录为一个页表项，则总共会产生1K个新的页表项，再将这1K个页表项组成一个标准页，则最后产生的这个标准页为页目录表，其中每一项为页目录项PDE。</p>
</blockquote>
<blockquote>
<p>二级页表地址转换原理是将 32 位虚拟地址拆分成高 10 位、中间 10 位、低 12 位三部分，它们<br>的作用是：高 10 位作为页表的索引，用于在页目录表中定位一个页目录项 PDE，页目录项中有页表物理地址，也就是定位到了某个页表。中间 10 位作为物理页的索引，用于在页表内定位到某个页表项 PTE，页表项中有分配的物理页地址，也就是定位到了某个物理页。低 12 位作为页内偏移量用于在已经定位到的物理页内寻址。</p>
</blockquote>
<blockquote>
<p>转换过程背后的具体步骤如下。<br>（1）用虚拟地址的高 10 位乘以 4，作为页目录表内的偏移地址，加上页目录表的物理地址，所得的<br>和，便是页目录项的物理地址。读取该页目录项，从中获取到页表的物理地址。<br>（2）用虚拟地址的中间 10 位乘以 4，作为页表内的偏移地址，加上在第 1 步中得到的页表物理地址，<br>所得的和，便是页表项的物理地址。读取该页表项，从中获取到分配的物理页地址。<br>（3）虚拟地址的高 10 位和中间 10 位分别是 PDE 和 PTE 的索引值，所以它们需要乘以 4。但低 12 位就不是索引值啦，其表示的范围是 0～0xfff，作为页内偏移最合适，所以虚拟地址的低 12 位加上第 2 步中得到的物理页地址，所得的和便是最终转换的物理地址。 </p>
</blockquote>
<h6 id="页目录项和页表项的结构"><a href="#页目录项和页表项的结构" class="headerlink" title="页目录项和页表项的结构"></a>页目录项和页表项的结构</h6><p><strong>页目录项</strong>    </p>
<table>
<thead>
<tr>
<th>31-12</th>
<th>11-9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>页表物理页地址31-12位</td>
<td>AVL</td>
<td>G</td>
<td>0</td>
<td>D</td>
<td>A</td>
<td>PCD</td>
<td>PWT</td>
<td>US</td>
<td>RW</td>
<td>P</td>
</tr>
</tbody></table>
<p><strong>页表项</strong>    </p>
<table>
<thead>
<tr>
<th>31-12</th>
<th>11-9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>物理页地址31-12位</td>
<td>AVL</td>
<td>G</td>
<td>PAT</td>
<td>D</td>
<td>A</td>
<td>PCD</td>
<td>PWT</td>
<td>US</td>
<td>RW</td>
<td>P</td>
</tr>
</tbody></table>
<blockquote>
<p>页表目录项和页表项中的都是物理页地址，标准页大小就是4KB，所以地址都是4K的倍数，即低12位全为零，所以只需要记录高20位就可以了。省下来的12位可以用于其他属性。</p>
</blockquote>
<blockquote>
<p>P，Present，意为存在位。若为 1 表示该页存在于物理内存中，若为 0 表示该表不在物理内存中。操<br>作系统的页式虚拟内存管理便是通过 P 位和相应的 pagefault 异常来实现的。</p>
</blockquote>
<blockquote>
<p>RW，Read/Write，意为读写位。若为 1 表示可读可写，若为 0 表示可读不可写。</p>
</blockquote>
<blockquote>
<p>US，User/Supervisor，意为普通用户/超级用户位。若为 1 时，表示处于 User 级，任意级别（0、1、2、 3）特权的程序都可以访问该页。若为 0，表示处于 Supervisor 级，特权级别为 3 的程序不允许访问该页，该页只允许特权级别为 0、1、2 的程序可以访问。</p>
</blockquote>
<blockquote>
<p>PWT，Page-level Write-Through，意为页级通写位，也称页级写透位。若为 1 表示此项采用通写方式，表示该页不仅是普通内存，还是高速缓存。此项和高速缓存有关，“通写”是高速缓存的一种工作方式，本位用来间接决定是否用此方式改善该页的访问效率。这里咱们直接置为 0 就可以啦。</p>
</blockquote>
<blockquote>
<p>PCD，Page-level Cache Disable，意为页级高速缓存禁止位。若为 1 表示该页启用高速缓存，为 0 表示禁止将该页缓存。这里咱们将其置为 0。 A，Accessed，意为访问位。若为 1 表示该页被 CPU 访问过啦，所以该位是由 CPU 设置的。还记得段描述符中的 A 位和 P 位吗？这两位在一起可以实现段式虚拟内存管理。和它们一样，这里页目录项和页表项中的 A 位也可以用来记录某一内存页的使用频率（操作系统定期将该位清 0，统计一段时间内变成 1 的次数），从而当内存不足时，可以将使用频率较低的页面换出到外存（如硬盘），同时将页目录项或页表项的 P位置 0，下次访问该页引起 pagefault 异常时，中断处理程序将硬盘上的页再次换入，同时将 P 位置 1。 D，Dirty，意为脏页位。当 CPU 对一个页面执行写操作时，就会设置对应页表项的 D 位为 1。此项仅针对页表项有效，并不会修改页目录项中的 D 位。</p>
</blockquote>
<blockquote>
<p>PAT，Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。比较复杂，将此位置 0 即可。</p>
</blockquote>
<blockquote>
<p>G,Global，意为全局位。由于内存地址转换也是颇费周折，先得拆分虚拟地址，然后又要查页目录，又要查页表的，所以为了提高获取物理地址的速度，将虚拟地址与物理地址转换结果存储在 TLB（Translation Lookaside Buffer）中，TLB 以后咱们会细说。在此先知道 TLB 是用来缓存地址转换结果的高速缓存就 ok 啦。此 G 位用来指定该页是否为全局页，为 1 表示是全局页，为 0 表示不是全局页。若为全局页，该页将在高速缓存 TLB 中一直保存，给出虚拟地址直接就出物理地址啦，无需那三步骤转换。由于 TLB 容量比较小（一般速度较快的存储设备容量都比较小），所以这里面就存放使用频率较高的页面。顺便说一句，清空 TLB 有两种方式，一是用 invlpg 指令针对单独虚拟地址条目清理，或者是重新加载 cr3 寄存器，这将直接清空 TLB。</p>
</blockquote>
<blockquote>
<p>AVL，意为 Available 位，表示可用，谁可以用？当然是软件，操作系统可用该位，CPU 不理会该位<br>的值，那咱们也不理会吧。</p>
</blockquote>
<h6 id="开启分页"><a href="#开启分页" class="headerlink" title="开启分页"></a>开启分页</h6><p>开启分页需要顺序做以下三件事情。</p>
<ol>
<li>准备好页目录表和页表。</li>
<li>将页表地址写入控制寄存器cr3。</li>
<li>寄存器的PG位置1.</li>
</ol>
<h4 id="elf-executable-and-linkable-format"><a href="#elf-executable-and-linkable-format" class="headerlink" title="elf (executable and linkable format)"></a>elf (executable and linkable format)</h4><h6 id="elf中的数据类型"><a href="#elf中的数据类型" class="headerlink" title="elf中的数据类型"></a>elf中的数据类型</h6><table>
<thead>
<tr>
<th>数据类型名称</th>
<th>字节大小</th>
<th>对齐</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>Elf_Half</td>
<td>2</td>
<td>2</td>
<td>无符号中等大小的整数</td>
</tr>
<tr>
<td>Elf_Word</td>
<td>4</td>
<td>4</td>
<td>无符号大整数</td>
</tr>
<tr>
<td>Elf_Addr</td>
<td>4</td>
<td>4</td>
<td>无符号程序运行地址</td>
</tr>
<tr>
<td>Elf_Off</td>
<td>4</td>
<td>4</td>
<td>无符号文件偏移量</td>
</tr>
</tbody></table>
<h4 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h4><blockquote>
<p>RPL:请求特权级指令请求访问其他资源的能力成为请求特权级，指令存放在代码段中，所所以使用CS中选择子的RPL位表示代码请求别人资源的能力。    </p>
</blockquote>
<blockquote>
<p>CPL：表示处理器当亲的特权级。指令最终是由处理器执行的，执行到不同特权的代码，处理器的特权级就切换到不同的等级。代码段描述符中的DPL便是当前处理器所处的特权级。    </p>
</blockquote>
<blockquote>
<p>对于数据段来讲，只有访问者的权限大于或等于段描述符中的DPL表示的最低权限时才能够访问。</p>
</blockquote>
<blockquote>
<p>对于代码段来讲，只有访问者的权限<strong>等于</strong>段描述符中的DPL才能访问。即只能平级访问。访问一个代码段实质上就是跳转到这个段进行执行。唯一一种处理器从高特权级降到低特权级执行的情况是处理器从中断处理程序中返回到用户态。</p>
</blockquote>
<blockquote>
<p>一致性代码段：一致性代码段也成为依从代码段，用来实现从低特权级的代码向高特权级代码的转移。一致性代码段是指如果自己是转移后的目标段，则自己的特权级一定能要大于等于转移前的CPL，也就是说一致性代码段的DPL是特权的上限。处理器遇到目标端位一致性代码段的时候并不会将CPL用该段的DPL来替换。代码段可以有一致性与不一致性的段，但是数据段只能有非一致性，即数据段不允许比自己特权级低的代码段访问。</p>
</blockquote>
<h4 id="函数调约定"><a href="#函数调约定" class="headerlink" title="函数调约定"></a>函数调约定</h4><h6 id="cdecl-c-declaration-即c声明"><a href="#cdecl-c-declaration-即c声明" class="headerlink" title="cdecl (c declaration 即c声明)"></a>cdecl (c declaration 即c声明)</h6><p>函数参数从右到左顺序入栈，EAX,ECX,EDX,寄存器由<strong>调用者</strong>保存，其余的寄存器由<strong>被调用者</strong>保存。函数的返回值存储在EAX寄存器中。由<strong>调用者</strong>清理栈空间。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int subtract(int a, int b); &#x2F;&#x2F;被调用者</span><br><span class="line">int sub &#x3D; subtract (3,2); &#x2F;&#x2F; 主调用者</span><br><span class="line">主调用者：</span><br><span class="line">; 从右到左将参数入栈</span><br><span class="line">push 2 ;压入参数 b </span><br><span class="line">push 3 ;压入参数 a </span><br><span class="line">call subtract ;调用函数 subtract </span><br><span class="line">add esp, 8 ;回收（清理）栈空间</span><br><span class="line">被调用者：</span><br><span class="line">push ebp ;压入 ebp 备份</span><br><span class="line">mov ebp,esp ;将 esp 赋值给 ebp </span><br><span class="line"> ;用 ebp 作为基址来访问栈中参数</span><br><span class="line">mov eax,[ebp+0x8] ;偏移 8 字节处为第 1 个参数 a </span><br><span class="line">add eax,[ebp+0xc] ;偏移 0xc 字节处是第 2 个参数 b </span><br><span class="line"> ;参数 a 和 b 相加后存入 eax </span><br><span class="line">mov esp,ebp ;为防止中间有入栈操作，用 ebp 恢复 esp </span><br><span class="line"> ;本句在此例子中可有可无,属于通用代码</span><br><span class="line">pop ebp ;将 ebp 恢复</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>


<h4 id="C与汇编混合编程"><a href="#C与汇编混合编程" class="headerlink" title="C与汇编混合编程"></a>C与汇编混合编程</h4><p>c语言和汇编语言混合编程分为两种：</p>
<ol>
<li>单独的汇编代码文件与单独的c语言文件分别编译成目标文件后，再进行连接成可执行程序。</li>
<li>再c语言中嵌入汇编语言，直接编译成生可执行程序。这种也叫做内联汇编。</li>
</ol>
<h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><h6 id="基本内联汇编"><a href="#基本内联汇编" class="headerlink" title="基本内联汇编"></a>基本内联汇编</h6><p>格式：<br>asm [volatile](“asm code”)       </p>
<ol>
<li>指令必须要用双引号括起来</li>
<li>一对双引号不可以跨行，如果跨行需要在结尾使用’\‘转义。</li>
<li>指令之间使用’;’,’\n’,’\t’分隔开。</li>
<li>即使指令分隔在多个双引号中也要使用分隔符。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> char* str&#x3D;&quot;hello,world\n&quot;; </span><br><span class="line"> int count &#x3D; 0; </span><br><span class="line"> void main()&#123; </span><br><span class="line"> asm(&quot;pusha; \ </span><br><span class="line"> movl $4,%eax; \ </span><br><span class="line"> movl $1,%ebx; \ </span><br><span class="line"> movl str,%ecx; \ </span><br><span class="line"> movl $12,%edx; \ </span><br><span class="line"> int $0x80; \ </span><br><span class="line">mov %eax,count;\ </span><br><span class="line">popa \ </span><br><span class="line">&quot;); </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h6 id="扩展内联汇编"><a href="#扩展内联汇编" class="headerlink" title="扩展内联汇编"></a>扩展内联汇编</h6><p>格式：<br>asm [volatile] (“assembly code”:output : input : clobber/modify)</p>
<ol>
<li><p>assembly code：还是用户写入的汇编指令，和基本内联汇编一样。</p>
</li>
<li><p>output:output 用来指定汇编代码的数据如何输出给 C 代码使用。内嵌的汇编指令运行结束后，如果想将运行结果存储到 c 变量中，就用此项指定输出的位置。</p>
</li>
<li><p>input：input 用来指定 C 中数据如何输入给汇编使用。要想让汇编使用 C 中的变量作为参数，就要在此指定。</p>
</li>
<li><p>clobber/modify：汇编代码执行后会破坏一些内存或寄存器资源，通过此项通知编译器，可能造成寄<br>存器或内存数据的破坏，这样 gcc 就知道哪些寄存器或内存需要提前保护起来。</p>
</li>
</ol>
<p><strong>约束</strong></p>
<ol>
<li>寄存器约束  </li>
</ol>
<p>寄存器约束就是要求 gcc 使用哪个寄存器，将 input 或 output 中变量约束在某个寄存器中。常见的寄存器约束有：<br>a：表示寄存器 eax/ax/al<br>b：表示寄存器 ebx/bx/bl<br>c：表示寄存器 ecx/cx/cl<br>d：表示寄存器 edx/dx/dl<br>D：表示寄存器 edi/di<br>S：表示寄存器 esi/si<br>q：表示任意这 4 个通用寄存器之一：eax/ebx/ecx/edx<br>r：表示任意这 6 个通用寄存器之一：eax/ebx/ecx/edx/esi/edi<br>g：表示可以存放到任意地点（寄存器和内存）。相当于除了同 q 一样外，还可以让 gcc 安排在内存中<br>A：把 eax 和 edx 组合成 64 位整数<br>f：表示浮点寄存器<br>t：表示第 1 个浮点寄存器<br>u：表示第 2 个浮点寄存器      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">void main() &#123; </span><br><span class="line">int in_a &#x3D; 1, in_b &#x3D; 2, out_sum; </span><br><span class="line">asm(&quot;addl %%ebx, %%eax&quot;:&quot;&#x3D;a&quot;(out_sum):&quot;a&quot;(in_a),&quot;b&quot;(in_b)); </span><br><span class="line">printf(&quot;sum is %d\n&quot;,out_sum); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>内存约束</li>
</ol>
<p>内存约束是要求 gcc 直接将位于 input 和 output 中的 C 变量的内存地址作为内联汇编代码的操作数，不需要寄存器做中转，直接进行内存读写，也就是汇编代码的操作数是 C 变量的指针。    </p>
<p>m：表示操作数可以使用任意一种内存形式。<br>o：操作数为内存变量，但访问它是通过偏移量的形式访问，即包含 offset_address 的格式。       </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">void main() &#123; </span><br><span class="line">int in_a &#x3D; 1, in_b &#x3D; 2; </span><br><span class="line">printf(&quot;in_b is %d\n&quot;, in_b); </span><br><span class="line">asm(&quot;movb %b0, %1;&quot;::&quot;a&quot;(in_a),&quot;m&quot;(in_b)); </span><br><span class="line">printf(&quot;in_b now is %d\n&quot;, in_b); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>立即数约束</li>
</ol>
<p>i：表示操作数为整数立即数<br>F：表示操作数为浮点数立即数<br>I：表示操作数为 0～31 之间的立即数<br>J：表示操作数为 0～63 之间的立即数<br>N：表示操作数为 0～255 之间的立即数<br>O：表示操作数为 0～32 之间的立即数<br>X：表示操作数为任何类型立即数    </p>
<ol start="4">
<li>通用约束</li>
</ol>
<p>0～9：此约束只用在 input 部分，但表示可与 output 和 input 中第 n 个操作数用相同的寄存器或内存。</p>
<h4 id="AT-amp-T汇编"><a href="#AT-amp-T汇编" class="headerlink" title="AT&amp;T汇编"></a>AT&amp;T汇编</h4><p>intel 与 AT&amp;T 语法风格对比</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>intel</th>
<th>AT&amp;T</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>寄存器没有钱追你</td>
<td>寄存器有前缀%</td>
<td></td>
</tr>
<tr>
<td>操作数顺序</td>
<td>目的操作数在左边，源操作数在右边</td>
<td>相反</td>
<td></td>
</tr>
<tr>
<td>操作数指定大小</td>
<td>有关内存的操作数要加数据类型指定大小，byte：8位，word:16位，dword:32位</td>
<td>指令的最后一个字母代表指令操作数大小，b:8位，w:16位，l:32位。</td>
<td></td>
</tr>
<tr>
<td>立即数</td>
<td>没有前缀</td>
<td>有前缀$</td>
<td></td>
</tr>
<tr>
<td>远跳转</td>
<td>jmp far segment:offset</td>
<td>ljmp $segment:$offset</td>
<td></td>
</tr>
<tr>
<td>远调用</td>
<td>call far segment:offset</td>
<td>lcall $segment:$offset</td>
<td></td>
</tr>
<tr>
<td>远返回</td>
<td>ret far n</td>
<td>lret $n</td>
<td></td>
</tr>
</tbody></table>
<p>内存寻址格式：<br>segreg(段基址):base_address(offset,index,size)        </p>
<p>segreg:base_address+offset+index*size</p>
<h4 id="打印-printf-的实现"><a href="#打印-printf-的实现" class="headerlink" title="打印 printf 的实现"></a>打印 printf 的实现</h4><h6 id="打印字符"><a href="#打印字符" class="headerlink" title="打印字符"></a>打印字符</h6><p>在printf.h中声明函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void put_char(uint8_t char_asci)</span><br></pre></td></tr></table></figure>

<p>在print.s中完成函数的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">global put_char</span><br><span class="line">;外部符号声明 </span><br><span class="line">pushad   ;备份8个32位寄存器</span><br><span class="line">mov ax,SELECTOR_VIDEO</span><br><span class="line">mov gs,ax</span><br><span class="line"></span><br><span class="line">;获取光标位置</span><br><span class="line">;高8位</span><br><span class="line">mov dx,0x03d4  ;索引寄存器</span><br><span class="line">mov al,0x0e    ;光标位置高8位</span><br><span class="line">out dx,al      </span><br><span class="line">mov dx,0x03d5     </span><br><span class="line">in al,dx</span><br><span class="line">mov ah,al</span><br><span class="line">;低8位</span><br><span class="line">mov dx,0x03d4  ;索引寄存器</span><br><span class="line">mov al,0x0f   ;光标位置高8位</span><br><span class="line">out dx,al      </span><br><span class="line">mov dx,0x03d5     </span><br><span class="line">in al,dx</span><br><span class="line"></span><br><span class="line">;光标为值存放在bx中</span><br><span class="line">mov ax,bx</span><br><span class="line">;取得要打印的字符</span><br><span class="line">mov ecx,[esp+36]</span><br><span class="line">cmp cl,0xd</span><br><span class="line">jz .is_carriage_return</span><br><span class="line">cmp cl,0xa</span><br><span class="line">jz .is_line_feed</span><br><span class="line">cmp cl,0x8</span><br><span class="line">jz .is_backspace</span><br><span class="line">jmp .put_other</span><br><span class="line"></span><br><span class="line">.is_backspace:</span><br><span class="line">dec bx   ;光标位置减一</span><br><span class="line">shl bx,1    ;左移一位，bx乘二得到光标处字符所在为内存地址。</span><br><span class="line">mov word [gs:bx],0   ;将这一个字符为位置清零包括颜色属性</span><br><span class="line">shr bx,1    ;bx恢复原状</span><br><span class="line">jmp .set_cursor</span><br><span class="line"></span><br><span class="line">.put_other:</span><br><span class="line">shl bx,1</span><br><span class="line">mov [gs:bx],cl</span><br><span class="line">inc bx</span><br><span class="line">mov byte [gs:bx],0x07</span><br><span class="line">shr bx,1</span><br><span class="line">inc bx</span><br><span class="line">;若光标值小于2000，则表示该页现存没有写完，若超出2000，则回车换行处理</span><br><span class="line">cmp bx,2000</span><br><span class="line">jl .set_cursor</span><br><span class="line"></span><br><span class="line">.is_line_feed:</span><br><span class="line">.is_carriage_return:</span><br><span class="line">xor dx,dx</span><br><span class="line">mov ax,bx</span><br><span class="line">mov si,80</span><br><span class="line">div si</span><br><span class="line">sub bx,dx</span><br><span class="line">;先让光标回到行首再下一行，判断是否超出。</span><br><span class="line">.is_carriage_return_end:</span><br><span class="line">add bx,80</span><br><span class="line">cmp bx,2000</span><br><span class="line">.is_line_feed_end:</span><br><span class="line">jl .set_cursor</span><br><span class="line"></span><br><span class="line">;超出屏幕大小开始滚屏</span><br><span class="line">.roll_screen:</span><br><span class="line">cld</span><br><span class="line">mov ecx,960 ;共搬运 2000-80&#x3D;1920个字符</span><br><span class="line">mov esi,0xb80a0   ;第一行行首</span><br><span class="line">mov edi,0xb8000   ;第零行行首</span><br><span class="line">rep movsd</span><br><span class="line">;将最后一行填充为空白</span><br><span class="line">mov ebx,3840</span><br><span class="line">mov ecx,80</span><br><span class="line">.cls:</span><br><span class="line">mov word [gs:ebx],0</span><br><span class="line">add ebx,2</span><br><span class="line">loop .cls</span><br><span class="line">mov bx,1920</span><br><span class="line"></span><br><span class="line">;设置光标值</span><br><span class="line">.set_cursor:</span><br><span class="line">;将光标设为bx值</span><br><span class="line">   mov dx, 0x03d4			  ;索引寄存器</span><br><span class="line">   mov al, 0x0e				  ;用于提供光标位置的高8位</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5			  ;通过读写数据端口0x3d5来获得或设置光标位置 </span><br><span class="line">   mov al, bh</span><br><span class="line">   out dx, al</span><br><span class="line"></span><br><span class="line">   mov dx, 0x03d4</span><br><span class="line">   mov al, 0x0f</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5 </span><br><span class="line">   mov al, bl</span><br><span class="line">   out dx, al</span><br><span class="line"></span><br><span class="line">.put_char_done:</span><br><span class="line">   popad</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>

<h6 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h6><p>在printf.h中声明函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void put_str(char* message)</span><br></pre></td></tr></table></figure>

<p>在print.s中完成函数的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">global put_str</span><br><span class="line">put_str:</span><br><span class="line">;由于本函数中只用到了ebx和ecx,只备份这两个寄存器</span><br><span class="line">   push ebx</span><br><span class="line">   push ecx</span><br><span class="line">   xor ecx, ecx		      ; 准备用ecx存储参数,清空</span><br><span class="line">   mov ebx, [esp + 12]	      ; 从栈中得到待打印的字符串地址 </span><br><span class="line">.goon:</span><br><span class="line">   mov cl, [ebx]</span><br><span class="line">   cmp cl, 0		      ; 如果处理到了字符串尾,跳到结束处返回</span><br><span class="line">   jz .str_over</span><br><span class="line">   push ecx		      ; 为put_char函数传递参数</span><br><span class="line">   call put_char</span><br><span class="line">   add esp, 4		      ; 回收参数所占的栈空间</span><br><span class="line">                        ;由调用者回收栈空间，C语言调用的话编译器会自动完成但是汇编语言不会，需要我们手动回收。</span><br><span class="line">   inc ebx		      ; 使ebx指向下一个字符</span><br><span class="line">   jmp .goon</span><br><span class="line">.str_over:</span><br><span class="line">   pop ecx</span><br><span class="line">   pop ebx</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>

<h6 id="打印整数"><a href="#打印整数" class="headerlink" title="打印整数"></a>打印整数</h6><p>在printf.h中声明函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void put_int(uint32_t num);</span><br></pre></td></tr></table></figure>

<p>在print.s中完成函数的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">global put_int</span><br><span class="line">put_int:</span><br><span class="line">pushad</span><br><span class="line">mov ebp,esp</span><br><span class="line">mov eax,[ebp+36]</span><br><span class="line">mov edx,eax</span><br><span class="line">mov edi,7</span><br><span class="line">mov ecx,8   ;32位数字共分为8块</span><br><span class="line">mov ebx,put_int_buffer</span><br><span class="line"></span><br><span class="line">.16based_4bits:</span><br><span class="line">and edx,0x0000000F</span><br><span class="line">cmp,9</span><br><span class="line">jg .isA2F</span><br><span class="line">add edx,&#39;0&#39;</span><br><span class="line">jmp .store</span><br><span class="line">.is_A2F:</span><br><span class="line">sub edx,10</span><br><span class="line">add edx,&#39;A&#39;</span><br><span class="line">;从大往小存储在缓冲区内，最后一个数字放在最高位</span><br><span class="line">.store:</span><br><span class="line">mov [ebx+edi],dl</span><br><span class="line">dec edi</span><br><span class="line">shr eax,4</span><br><span class="line">mov edx,4</span><br><span class="line">loop .16based_4bits</span><br><span class="line"></span><br><span class="line">.ready_to_print:</span><br><span class="line">inc edi</span><br><span class="line">.skip_prefix_0    ;判断是不是8位全零</span><br><span class="line">cmp edi,8</span><br><span class="line">je .full0</span><br><span class="line">.go_on_skip:</span><br><span class="line">mov cl,[put_int_buffer+edi]</span><br><span class="line">inc edi</span><br><span class="line">cmp cl,&#39;0&#39;</span><br><span class="line">je .skip_prefix_0</span><br><span class="line">dec edi</span><br><span class="line">jmp .put_each_num</span><br><span class="line"></span><br><span class="line">.full0:</span><br><span class="line">mov cl,&#39;0&#39;</span><br><span class="line">.put_each_num:</span><br><span class="line">push ecx</span><br><span class="line">call put_char</span><br><span class="line">add esp,4</span><br><span class="line">inc edi</span><br><span class="line">mov cl,[put_int_buffer+edi]</span><br><span class="line">cmp edi,8</span><br><span class="line">jl .put_each_num</span><br><span class="line">popad</span><br><span class="line">ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h4 id="杂项问题"><a href="#杂项问题" class="headerlink" title="杂项问题"></a>杂项问题</h4><ol>
<li>对于push指令，处于对齐的要求，操作数要么是16位要么是32位，所以8位操作数会被扩展为运行模式下的默认操作数宽度。实模式为16位，保护模式为32位。</li>
<li>使用伪指令 [bits 16] [bits 32] 指定编译器进行模式指定。 </li>
<li>操作数反转前缀 0x66 寻址方式反转前缀 0x67</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://blog.cuimouren.cn/2021/05/14/os-003-protected-mode/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/os/" rel="tag">os</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/05/20/nasm-%E4%BD%BF%E7%94%A8/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            nasm 使用
          
        </div>
      </a>
    
    
      <a href="/2021/05/13/gcc-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">gcc 使用入门</div>
      </a>
    
  </nav>

   
 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> 崔文耀
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="https://beian.miit.gov.cn/" target="_black" rel="nofollow">豫ICP备20002729号</a>
        </li>
        
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="这里是文耀的space"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">photos</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯奶茶吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>